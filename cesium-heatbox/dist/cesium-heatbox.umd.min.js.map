{"version":3,"file":"cesium-heatbox.umd.min.js","mappings":"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","sources":["webpack://CesiumHeatbox/webpack/universalModuleDefinition","webpack://CesiumHeatbox/external umd {\"commonjs\":\"cesium\",\"commonjs2\":\"cesium\",\"amd\":\"cesium\",\"root\":\"Cesium\"}","webpack://CesiumHeatbox/webpack/bootstrap","webpack://CesiumHeatbox/webpack/runtime/define property getters","webpack://CesiumHeatbox/webpack/runtime/hasOwnProperty shorthand","webpack://CesiumHeatbox/./src/utils/constants.js","webpack://CesiumHeatbox/./src/utils/logger.js","webpack://CesiumHeatbox/./src/utils/validation.js","webpack://CesiumHeatbox/./src/core/CoordinateTransformer.js","webpack://CesiumHeatbox/./src/core/VoxelGrid.js","webpack://CesiumHeatbox/./src/core/DataProcessor.js","webpack://CesiumHeatbox/./src/core/VoxelRenderer.js","webpack://CesiumHeatbox/./src/index.js","webpack://CesiumHeatbox/./src/Heatbox.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"cesium\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"cesium\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CesiumHeatbox\"] = factory(require(\"cesium\"));\n\telse\n\t\troot[\"CesiumHeatbox\"] = factory(root[\"Cesium\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__50__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__50__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * CesiumJS Heatbox ライブラリの定数定義\n */\n\n/**\n * デフォルト設定値\n */\nexport const DEFAULT_OPTIONS = {\n  voxelSize: 20,\n  opacity: 0.8,\n  emptyOpacity: 0.03,\n  showOutline: true,\n  showEmptyVoxels: false,\n  minColor: [0, 32, 255],\n  maxColor: [255, 64, 0],\n  maxRenderVoxels: 50000,\n  batchMode: 'auto',\n  debug: false, // ログ制御（false で本番モード、true で開発モード、またはオブジェクト）\n  autoVoxelSize: false, // v0.1.4: 自動ボクセルサイズ決定（既存互換性のためfalse）\n  // v0.1.5: 新機能\n  colorMap: 'custom', // 'custom', 'viridis', 'inferno'\n  diverging: false, // 二極性データ対応\n  divergingPivot: 0, // 二極性配色のピボット値\n  highlightTopN: null, // トップN強調表示（null: 無効）\n  highlightStyle: {\n    outlineWidth: 4,\n    boostOpacity: 0.2\n  },\n  // v0.1.6: 枠線重なり対策・柔軟化\n  voxelGap: 0, // ボクセル間ギャップ（メートル）\n  outlineOpacity: 1.0, // 枠線透明度（0-1）\n  outlineWidthResolver: null, // 関数: (params) => number で動的太さ制御\n  // 実質的な太さ表現のための代替描画（WebGLの線幅制限回避用）\n  outlineEmulation: 'off', // 'off' | 'topn' | 'non-topn' | 'all'（ポリラインで太線エミュレーション：TopNのみ | TopN以外のみ | すべて）\n  // v0.1.6.1: インセット枠線（ADR-0004）\n  outlineInset: 0, // インセット枠線のオフセット距離（メートル、0で無効）\n  outlineInsetMode: 'all', // インセット枠線の適用範囲：'all'（全体） | 'topn'（TopNのみ）\n  enableThickFrames: false, // 厚い枠線表示（インセット枠線とメイン枠線の間をフレームで埋める）\n  \n  // v0.1.7: 適応的枠線制御とエミュレーション専用表示モード（ADR-0005）\n  outlineRenderMode: 'standard', // 'standard' | 'inset' | 'emulation-only' 表示モード\n  adaptiveOutlines: false, // 適応的枠線制御を有効化（オプトイン）\n  outlineWidthPreset: 'uniform', // 'adaptive-density' | 'topn-focus' | 'uniform' プリセット\n  \n  // v0.1.7: 透明度resolver\n  boxOpacityResolver: null, // 関数: (ctx) => number(0-1) でボックス透明度制御\n  outlineOpacityResolver: null, // 関数: (ctx) => number(0-1) で枠線透明度制御\n  \n  // v0.1.7: 適応的制御パラメータ\n  adaptiveParams: {\n    neighborhoodRadius: 50, // 近傍密度計算の半径（メートル）\n    densityThreshold: 5, // 密度しきい値（エンティティ数/ボクセル）\n    cameraDistanceFactor: 1.0, // カメラ距離補正係数\n    overlapRiskFactor: 0.3 // 重なりリスク補正係数\n  }\n};\n\n/**\n * パフォーマンス制限値\n */\nexport const PERFORMANCE_LIMITS = {\n  maxEntities: 5000,\n  maxVoxels: 50000,\n  maxEmptyVoxelsRendered: 10000,\n  minVoxelSize: 5,\n  maxVoxelSize: 1000,\n  warningThreshold: 30000\n};\n\n/**\n * 座標変換定数\n */\nexport const COORDINATE_CONSTANTS = {\n  EARTH_RADIUS: 6378137,\n  DEGREES_TO_METERS_LAT: 111000,\n  DEGREES_TO_RADIANS: Math.PI / 180\n};\n\n/**\n * エラーメッセージ\n */\nexport const ERROR_MESSAGES = {\n  NO_ENTITIES: '対象エンティティがありません',\n  NO_VIEWER: 'CesiumJS Viewerが初期化されていません',\n  INVALID_VIEWER: 'CesiumJS Viewerが無効です',\n  VOXEL_LIMIT_EXCEEDED: 'ボクセル数が上限を超えています',\n  MEMORY_WARNING: '推定メモリ使用量が警告値を超えています',\n  WEBGL_NOT_SUPPORTED: 'WebGLがサポートされていません',\n  INVALID_VOXEL_SIZE: 'ボクセルサイズが無効です'\n};\n\n/**\n * 統計情報のデフォルト値\n */\nexport const DEFAULT_STATISTICS = {\n  totalVoxels: 0,\n  renderedVoxels: 0,\n  nonEmptyVoxels: 0,\n  emptyVoxels: 0,\n  totalEntities: 0,\n  minCount: 0,\n  maxCount: 0,\n  averageCount: 0\n};\n\n/**\n * 色分け関連定数\n */\nexport const COLOR_CONSTANTS = {\n  MIN_HUE: 240, // 青\n  MAX_HUE: 0,   // 赤\n  SATURATION: 0.8,\n  BRIGHTNESS: 0.7,\n  SATURATION_RANGE: 0.2,\n  BRIGHTNESS_RANGE: 0.3\n};\n","/**\n * ログ出力制御ユーティリティ\n * NODE_ENVやdebugフラグによってログレベルを制御\n */\n\n/**\n * ログレベル定数\n */\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3\n};\n\n/**\n * 現在のログレベルを決定\n * NODE_ENV=production では ERROR と WARN のみ\n * DEBUG=true または NODE_ENV=development では全レベル出力\n */\nfunction getLogLevel() {\n  // 明示的にDEBUG=trueが設定されている場合\n  if (typeof process !== 'undefined' && process.env && process.env.DEBUG === 'true') {\n    return LOG_LEVELS.DEBUG;\n  }\n  \n  // NODE_ENVをチェック\n  if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production') {\n    return LOG_LEVELS.WARN;\n  }\n  \n  // デフォルトは開発モード（全ログ出力）\n  return LOG_LEVELS.DEBUG;\n}\n\nlet currentLogLevel = getLogLevel();\n\n/**\n * ログ出力の共通ユーティリティ\n */\nexport const Logger = {\n  /**\n   * エラーログ（常に出力）\n   * @param {...any} args - ログ引数\n   */\n  error(...args) {\n    if (currentLogLevel >= LOG_LEVELS.ERROR) {\n      console.error('[Heatbox ERROR]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * 警告ログ\n   * @param {...any} args - ログ引数\n   */\n  warn(...args) {\n    if (currentLogLevel >= LOG_LEVELS.WARN) {\n      console.warn('[Heatbox WARN]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * 情報ログ\n   * @param {...any} args - ログ引数\n   */\n  info(...args) {\n    if (currentLogLevel >= LOG_LEVELS.INFO) {\n      console.log('[Heatbox INFO]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * デバッグログ\n   * @param {...any} args - ログ引数\n   */\n  debug(...args) {\n    if (currentLogLevel >= LOG_LEVELS.DEBUG) {\n      console.log('[Heatbox DEBUG]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * オプション設定によるログレベル制御\n   * v0.1.5: debugオプションがオブジェクトの場合に対応\n   * @param {Object} options - オプション\n   */\n  setLogLevel(options) {\n    if (options && options.debug !== undefined) {\n      if (typeof options.debug === 'boolean') {\n        // debug: true → 詳細ログ、debug: false → 重要ログのみ\n        currentLogLevel = options.debug ? LOG_LEVELS.DEBUG : LOG_LEVELS.WARN;\n      } else if (typeof options.debug === 'object' && options.debug !== null) {\n        // オブジェクトの場合はログレベルをDEBUGに設定（境界表示制御は別途処理）\n        currentLogLevel = LOG_LEVELS.DEBUG;\n      }\n    }\n    return currentLogLevel;\n  }\n};\n\n/**\n * 下位互換のためのラッパー関数群\n * 既存のconsole.log置き換え用\n */\nexport const log = Logger.debug;\nexport const warn = Logger.warn;\nexport const error = Logger.error;\nexport const info = Logger.info;\n","/**\n * バリデーション関連のユーティリティ関数\n */\n\nimport * as Cesium from 'cesium';\nimport { PERFORMANCE_LIMITS, ERROR_MESSAGES } from './constants.js';\nimport { Logger } from './logger.js';\n\n/**\n * CesiumJS Viewerが有効かチェック\n * @param {Object} viewer - CesiumJS Viewer\n * @returns {boolean} 有効な場合はtrue\n */\nexport function isValidViewer(viewer) {\n  if (!viewer) {\n    return false;\n  }\n  \n  // 必要なプロパティが存在するかチェック\n  if (!viewer.scene || !viewer.entities || !viewer.scene.canvas) {\n    return false;\n  }\n  \n  // WebGL対応チェック（WebGL2 も許容）\n  const canvas = viewer.scene.canvas;\n  const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  if (!gl) {\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * エンティティ配列が有効かチェック\n * @param {Array} entities - エンティティ配列\n * @returns {boolean} 有効な場合はtrue\n */\nexport function isValidEntities(entities) {\n  if (!Array.isArray(entities)) {\n    return false;\n  }\n  \n  if (entities.length === 0) {\n    return false;\n  }\n  \n  if (entities.length > PERFORMANCE_LIMITS.maxEntities) {\n    Logger.warn(`エンティティ数が推奨値(${PERFORMANCE_LIMITS.maxEntities})を超えています: ${entities.length}`);\n  }\n  \n  return true;\n}\n\n/**\n * ボクセルサイズが有効かチェック\n * @param {number} voxelSize - ボクセルサイズ\n * @returns {boolean} 有効な場合はtrue\n */\nexport function isValidVoxelSize(voxelSize) {\n  if (typeof voxelSize !== 'number' || isNaN(voxelSize)) {\n    return false;\n  }\n  \n  if (voxelSize < PERFORMANCE_LIMITS.minVoxelSize || voxelSize > PERFORMANCE_LIMITS.maxVoxelSize) {\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * エンティティが有効な位置情報を持つかチェック\n * @param {Object} entity - Cesium Entity\n * @returns {boolean} 有効な場合はtrue\n */\nexport function hasValidPosition(entity) {\n  if (!entity || !entity.position) {\n    return false;\n  }\n  \n  // Propertyベースの位置情報の場合\n  if (typeof entity.position.getValue === 'function') {\n    const position = entity.position.getValue(Cesium.JulianDate.now());\n    return position && !isNaN(position.x) && !isNaN(position.y) && !isNaN(position.z);\n  }\n  \n  // 直接Cartesian3の場合\n  if (entity.position.x !== undefined) {\n    return !isNaN(entity.position.x) && !isNaN(entity.position.y) && !isNaN(entity.position.z);\n  }\n  \n  return false;\n}\n\n/**\n * 処理するボクセル数が制限内かチェック\n * @param {number} totalVoxels - 総ボクセル数\n * @param {number} voxelSize - ボクセルサイズ\n * @returns {Object} チェック結果\n */\nexport function validateVoxelCount(totalVoxels, voxelSize) {\n  const result = {\n    valid: true,\n    warning: false,\n    error: null,\n    recommendedSize: null\n  };\n  \n  if (totalVoxels > PERFORMANCE_LIMITS.maxVoxels) {\n    result.valid = false;\n    result.error = ERROR_MESSAGES.VOXEL_LIMIT_EXCEEDED;\n    result.recommendedSize = Math.ceil(voxelSize * Math.pow(totalVoxels / PERFORMANCE_LIMITS.maxVoxels, 1/3));\n  } else if (totalVoxels > PERFORMANCE_LIMITS.warningThreshold) {\n    result.warning = true;\n    result.error = ERROR_MESSAGES.MEMORY_WARNING;\n  }\n  \n  return result;\n}\n\n/**\n * オプションを検証して正規化\n * v0.1.5: batchMode非推奨化と新機能バリデーションを追加\n * @param {Object} options - ユーザー指定のオプション\n * @returns {Object} 正規化されたオプション\n */\nexport function validateAndNormalizeOptions(options = {}) {\n  const normalized = { ...options };\n  \n  // v0.1.5: batchMode非推奨化警告（debug時のみ）\n  if (normalized.batchMode && normalized.debug) {\n    Logger.warn('batchMode option is deprecated and will be removed in v1.0.0. It is currently ignored.');\n  }\n  \n  // ボクセルサイズのバリデーション\n  if (normalized.voxelSize !== undefined && !isValidVoxelSize(normalized.voxelSize)) {\n    throw new Error(`${ERROR_MESSAGES.INVALID_VOXEL_SIZE}: ${normalized.voxelSize}`);\n  }\n  \n  // 透明度のバリデーション\n  if (normalized.opacity !== undefined) {\n    normalized.opacity = Math.max(0, Math.min(1, normalized.opacity));\n  }\n  \n  if (normalized.emptyOpacity !== undefined) {\n    normalized.emptyOpacity = Math.max(0, Math.min(1, normalized.emptyOpacity));\n  }\n  \n  // 色のバリデーション\n  if (normalized.minColor && Array.isArray(normalized.minColor) && normalized.minColor.length === 3) {\n    normalized.minColor = normalized.minColor.map(c => Math.max(0, Math.min(255, Math.floor(c))));\n  }\n  \n  if (normalized.maxColor && Array.isArray(normalized.maxColor) && normalized.maxColor.length === 3) {\n    normalized.maxColor = normalized.maxColor.map(c => Math.max(0, Math.min(255, Math.floor(c))));\n  }\n  \n  // v0.1.5: 新機能のバリデーション\n  if (normalized.colorMap !== undefined) {\n    const validColorMaps = ['custom', 'viridis', 'inferno'];\n    if (!validColorMaps.includes(normalized.colorMap)) {\n      Logger.warn(`Invalid colorMap: ${normalized.colorMap}. Using 'custom'.`);\n      normalized.colorMap = 'custom';\n    }\n  }\n  \n  if (normalized.highlightTopN !== undefined && normalized.highlightTopN !== null) {\n    if (typeof normalized.highlightTopN !== 'number' || normalized.highlightTopN <= 0) {\n      Logger.warn(`Invalid highlightTopN: ${normalized.highlightTopN}. Must be a positive number.`);\n      normalized.highlightTopN = null;\n    }\n  }\n  \n  // v0.1.6: 枠線重なり対策のバリデーション\n  if (normalized.voxelGap !== undefined) {\n    normalized.voxelGap = Math.max(0, Math.min(100, parseFloat(normalized.voxelGap) || 0));\n  }\n  \n  if (normalized.outlineOpacity !== undefined) {\n    normalized.outlineOpacity = Math.max(0, Math.min(1, parseFloat(normalized.outlineOpacity) || 1));\n  }\n  \n  if (normalized.outlineWidthResolver !== undefined && normalized.outlineWidthResolver !== null) {\n    if (typeof normalized.outlineWidthResolver !== 'function') {\n      Logger.warn('outlineWidthResolver must be a function. Ignoring.');\n      normalized.outlineWidthResolver = null;\n    }\n  }\n\n  // v0.1.6+: 太線エミュレーションモード\n  if (normalized.outlineEmulation !== undefined) {\n    const validModes = ['off', 'topn', 'non-topn', 'all'];\n    if (!validModes.includes(normalized.outlineEmulation)) {\n      Logger.warn(`Invalid outlineEmulation: ${normalized.outlineEmulation}. Using 'off'.`);\n      normalized.outlineEmulation = 'off';\n    }\n  }\n\n  // v0.1.6.1 (ADR-0004): インセット枠線\n  if (normalized.outlineInset !== undefined) {\n    const v = parseFloat(normalized.outlineInset);\n    normalized.outlineInset = isNaN(v) || v < 0 ? 0 : v;\n  }\n  if (normalized.outlineInsetMode !== undefined) {\n    const validModes = ['all', 'topn'];\n    if (!validModes.includes(normalized.outlineInsetMode)) {\n      Logger.warn(`Invalid outlineInsetMode: ${normalized.outlineInsetMode}. Using 'all'.`);\n      normalized.outlineInsetMode = 'all';\n    }\n  }\n\n  // v0.1.6.1: インセット枠線（ADR-0004）\n  if (normalized.outlineInset !== undefined) {\n    // 0〜100mの範囲にクランプ（安全上限）\n    const inset = parseFloat(normalized.outlineInset);\n    normalized.outlineInset = Math.max(0, Math.min(100, isNaN(inset) ? 0 : inset));\n  }\n  \n  if (normalized.outlineInsetMode !== undefined) {\n    const validInsetModes = ['all', 'topn'];\n    if (!validInsetModes.includes(normalized.outlineInsetMode)) {\n      Logger.warn(`Invalid outlineInsetMode: ${normalized.outlineInsetMode}. Using 'all'.`);\n      normalized.outlineInsetMode = 'all';\n    }\n  }\n  \n  // 厚い枠線表示\n  if (normalized.enableThickFrames !== undefined) {\n    normalized.enableThickFrames = Boolean(normalized.enableThickFrames);\n  }\n  \n  return normalized;\n}\n\n/**\n * データ範囲に基づいて初期ボクセルサイズを推定\n * @param {Object} bounds - 境界情報\n * @param {number} entityCount - エンティティ数\n * @returns {number} 推定ボクセルサイズ（メートル）\n */\nexport function estimateInitialVoxelSize(bounds, entityCount) {\n  try {\n    // 1. データ範囲（X/Y/Z軸の物理的範囲）を計算\n    const dataRange = calculateDataRange(bounds);\n    \n    // 2. エンティティ密度を推定\n    const volume = dataRange.x * dataRange.y * Math.max(dataRange.z, 10); // 最小高度差10m\n    const density = entityCount / volume; // エンティティ/立方メートル\n    \n    // 3. 密度に応じて適切なボクセルサイズを推定\n    // - 高密度: 細かいサイズ（10-20m）\n    // - 中密度: 標準サイズ（20-50m）\n    // - 低密度: 粗いサイズ（50-100m）\n    let estimatedSize;\n    \n    if (density > 0.001) {\n      // 高密度：細かいサイズ\n      estimatedSize = Math.max(10, Math.min(20, 20 / Math.sqrt(density * 1000)));\n    } else if (density > 0.0001) {\n      // 中密度：標準サイズ\n      estimatedSize = Math.max(20, Math.min(50, 50 / Math.sqrt(density * 10000)));\n    } else {\n      // 低密度：粗いサイズ\n      estimatedSize = Math.max(50, Math.min(100, 100 / Math.sqrt(density * 100000)));\n    }\n    \n    // 制限値内に収める\n    estimatedSize = Math.max(PERFORMANCE_LIMITS.minVoxelSize, \n                            Math.min(PERFORMANCE_LIMITS.maxVoxelSize, estimatedSize));\n    \n    Logger.debug(`Estimated voxel size: ${estimatedSize}m (density: ${density}, volume: ${volume})`);\n    return Math.round(estimatedSize);\n    \n  } catch (error) {\n    Logger.warn('Initial voxel size estimation failed:', error);\n    return 20; // デフォルトサイズ\n  }\n}\n\n/**\n * 境界からデータ範囲を計算\n * @param {Object} bounds - 境界情報\n * @returns {Object} データ範囲 {x, y, z}（メートル）\n */\nexport function calculateDataRange(bounds) {\n  try {\n    // 緯度経度をメートルに変換（簡易変換）\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    const cosLat = Math.cos(centerLat * Math.PI / 180);\n    \n    const lonRangeMeters = (bounds.maxLon - bounds.minLon) * 111000 * cosLat;\n    const latRangeMeters = (bounds.maxLat - bounds.minLat) * 111000;\n    const altRangeMeters = Math.max(bounds.maxAlt - bounds.minAlt, 1); // 最小1m\n    \n    return {\n      x: Math.max(lonRangeMeters, 1),\n      y: Math.max(latRangeMeters, 1),\n      z: altRangeMeters\n    };\n    \n  } catch (error) {\n    Logger.warn('Data range calculation failed:', error);\n    // フォールバック値\n    return { x: 1000, y: 1000, z: 100 };\n  }\n}\n","/**\n * 座標変換を担当するクラス（シンプル実装）\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../utils/logger.js';\n\n/**\n * 座標変換機能を提供するクラス\n */\nexport class CoordinateTransformer {\n  /**\n   * エンティティ配列から3D境界を計算\n   * @param {Array} entities - エンティティ配列\n   * @returns {Object} 境界情報\n   */\n  static calculateBounds(entities) {\n    if (!Array.isArray(entities) || entities.length === 0) {\n      throw new Error('エンティティが提供されていません');\n    }\n    \n    let minLon = Infinity;\n    let maxLon = -Infinity;\n    let minLat = Infinity;\n    let maxLat = -Infinity;\n    let minAlt = Infinity;\n    let maxAlt = -Infinity;\n    \n    let validCount = 0;\n    const currentTime = Cesium.JulianDate.now();\n    \n    entities.forEach((entity, index) => {\n      try {\n        // エンティティの位置を取得\n        let position;\n        if (entity.position) {\n          if (typeof entity.position.getValue === 'function') {\n            position = entity.position.getValue(currentTime);\n          } else {\n            position = entity.position;\n          }\n        }\n        \n        if (!position) {\n          return; // 位置情報がない場合はスキップ\n        }\n        \n        // Cartesian3からCartographic（経度、緯度、高度）に変換\n        const cartographic = Cesium.Cartographic.fromCartesian(position);\n        if (!cartographic) return;\n        \n        const lon = Cesium.Math.toDegrees(cartographic.longitude);\n        const lat = Cesium.Math.toDegrees(cartographic.latitude);\n        const alt = cartographic.height;\n        \n        minLon = Math.min(minLon, lon);\n        maxLon = Math.max(maxLon, lon);\n        minLat = Math.min(minLat, lat);\n        maxLat = Math.max(maxLat, lat);\n        minAlt = Math.min(minAlt, alt);\n        maxAlt = Math.max(maxAlt, alt);\n        \n        validCount++;\n      } catch (error) {\n        Logger.warn(`エンティティ ${index} の処理に失敗:`, error);\n      }\n    });\n    \n    if (validCount === 0) {\n      throw new Error('有効な位置情報を持つエンティティが見つかりません');\n    }\n    \n    // デバッグ出力\n    Logger.debug('座標範囲計算完了:', {\n      validCount,\n      bounds: {\n        minLon, maxLon, \n        minLat, maxLat, \n        minAlt, maxAlt\n      }\n    });\n    \n    return {\n      minLon,\n      maxLon,\n      minLat,\n      maxLat,\n      minAlt,\n      maxAlt,\n      centerLon: (minLon + maxLon) / 2,\n      centerLat: (minLat + maxLat) / 2,\n      centerAlt: (minAlt + maxAlt) / 2\n    };\n  }\n  \n  /**\n   * ボクセルインデックスを地理座標（中心位置）に変換\n   * @param {number} x - X軸ボクセルインデックス\n   * @param {number} y - Y軸ボクセルインデックス\n   * @param {number} z - Z軸ボクセルインデックス\n   * @param {Object} bounds - 境界情報\n   * @param {Object} grid - グリッド情報\n   * @returns {Object} 地理座標 {lon, lat, alt}\n   */\n  static voxelIndexToCoordinate(x, y, z, bounds, grid) {\n    const { minLon, maxLon, minLat, maxLat, minAlt, maxAlt } = bounds;\n    const { numVoxelsX, numVoxelsY, numVoxelsZ } = grid;\n    \n    // ボクセルの中心位置を計算（シンプルな線形補間）\n    const normalizedLon = (x + 0.5) / numVoxelsX;\n    const normalizedLat = (y + 0.5) / numVoxelsY;\n    const normalizedAlt = (z + 0.5) / numVoxelsZ;\n    \n    return {\n      lon: minLon + normalizedLon * (maxLon - minLon),\n      lat: minLat + normalizedLat * (maxLat - minLat),\n      alt: minAlt + normalizedAlt * (maxAlt - minAlt)\n    };\n  }\n  \n  /**\n   * 地理座標をCesium Cartesian3に変換\n   * @param {number} lon - 経度\n   * @param {number} lat - 緯度\n   * @param {number} alt - 高度\n   * @returns {Cesium.Cartesian3} Cesium Cartesian3\n   */\n  static coordinateToCartesian3(lon, lat, alt) {\n    return Cesium.Cartesian3.fromDegrees(lon, lat, alt);\n  }\n}","/**\n * ボクセルグリッドを管理するクラス（シンプル実装）\n */\nimport { Logger } from '../utils/logger.js';\n\n/**\n * 3Dボクセルグリッドを管理するクラス\n */\nexport class VoxelGrid {\n  /**\n   * 境界情報とボクセルサイズからグリッドを作成（シンプル版）\n   * @param {Object} bounds - 境界情報\n   * @param {number} voxelSizeMeters - 目標ボクセルサイズ（メートル）。実セルサイズは各軸で範囲/分割数。\n   * @returns {Object} グリッド情報 { numVoxelsX, numVoxelsY, numVoxelsZ, totalVoxels, voxelSizeMeters, cellSizeX, cellSizeY, cellSizeZ, lonRangeMeters, latRangeMeters, altRangeMeters }\n   */\n  static createGrid(bounds, voxelSizeMeters) {\n    // 緯度・経度をメートルに概算変換（シンプルな公式）\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    const lonRangeMeters = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);\n    const latRangeMeters = (bounds.maxLat - bounds.minLat) * 111000;\n    const altRangeMeters = bounds.maxAlt - bounds.minAlt;\n    \n    // 各軸のボクセル数を計算\n    const numVoxelsX = Math.max(1, Math.ceil(lonRangeMeters / voxelSizeMeters));\n    const numVoxelsY = Math.max(1, Math.ceil(latRangeMeters / voxelSizeMeters));\n    const numVoxelsZ = Math.max(1, Math.ceil(altRangeMeters / voxelSizeMeters));\n\n    // 実際の各軸セルサイズ（メートル）\n    // ceil により分割数が増える場合があるため、実セルサイズは指定サイズ以下になる。\n    const cellSizeX = numVoxelsX > 0 ? (lonRangeMeters / numVoxelsX) : voxelSizeMeters;\n    const cellSizeY = numVoxelsY > 0 ? (latRangeMeters / numVoxelsY) : voxelSizeMeters;\n    // 高度差が極小の場合に0にならないよう最低1mを確保\n    const cellSizeZ = numVoxelsZ > 0 ? Math.max(altRangeMeters / numVoxelsZ, 1) : Math.max(voxelSizeMeters, 1);\n    \n    const totalVoxels = numVoxelsX * numVoxelsY * numVoxelsZ;\n    \n    Logger.debug('VoxelGrid created:', {\n      numVoxelsX,\n      numVoxelsY,\n      numVoxelsZ,\n      totalVoxels,\n      voxelSizeMeters,\n      cellSizeX,\n      cellSizeY,\n      cellSizeZ,\n      lonRangeMeters,\n      latRangeMeters,\n      altRangeMeters\n    });\n    \n    return {\n      numVoxelsX,\n      numVoxelsY,\n      numVoxelsZ,\n      totalVoxels,\n      voxelSizeMeters,\n      cellSizeX,\n      cellSizeY,\n      cellSizeZ,\n      lonRangeMeters,\n      latRangeMeters,\n      altRangeMeters\n    };\n  }\n  \n  /**\n   * ボクセルインデックスからキーを生成\n   * @param {number} x - X軸インデックス\n   * @param {number} y - Y軸インデックス\n   * @param {number} z - Z軸インデックス\n   * @returns {string} ボクセルキー\n   */\n  static getVoxelKey(x, y, z) {\n    return `${x},${y},${z}`;\n  }\n  \n  /**\n   * ボクセルキーからインデックスを解析\n   * @param {string} key - ボクセルキー\n   * @returns {Object} インデックス {x, y, z}\n   */\n  static parseVoxelKey(key) {\n    const [x, y, z] = key.split(',').map(Number);\n    return { x, y, z };\n  }\n  \n  /**\n   * グリッド内の全ボクセルを反復処理\n   * @param {Object} grid - グリッド情報\n   * @param {Function} callback - 各ボクセルに対するコールバック関数\n   */\n  static iterateAllVoxels(grid, callback) {\n    const { numVoxelsX, numVoxelsY, numVoxelsZ } = grid;\n    \n    for (let x = 0; x < numVoxelsX; x++) {\n      for (let y = 0; y < numVoxelsY; y++) {\n        for (let z = 0; z < numVoxelsZ; z++) {\n          const key = this.getVoxelKey(x, y, z);\n          callback(x, y, z, key);\n        }\n      }\n    }\n  }\n}\n","/**\n * データ処理を担当するクラス（シンプル実装）\n */\nimport * as Cesium from 'cesium';\nimport { VoxelGrid } from './VoxelGrid.js';\nimport { Logger } from '../utils/logger.js';\n\n/**\n * エンティティデータの処理を担当するクラス\n */\nexport class DataProcessor {\n  /**\n   * エンティティをボクセルに分類（シンプル実装）\n   * @param {Array} entities - エンティティ配列\n   * @param {Object} bounds - 境界情報\n   * @param {Object} grid - グリッド情報\n   * @returns {Map} ボクセルデータ（キー: ボクセルキー, 値: ボクセル情報）\n   */\n  static classifyEntitiesIntoVoxels(entities, bounds, grid) {\n    const voxelData = new Map();\n    let processedCount = 0;\n    let skippedCount = 0;\n    \n    Logger.debug(`Processing ${entities.length} entities for classification`);\n    \n    const currentTime = Cesium.JulianDate.now();\n    \n    entities.forEach((entity, index) => {\n      try {\n        // エンティティの位置を取得（シンプルなアプローチ）\n        let position;\n        if (entity.position) {\n          if (typeof entity.position.getValue === 'function') {\n            position = entity.position.getValue(currentTime);\n          } else {\n            position = entity.position;\n          }\n        }\n        \n        if (!position) {\n          skippedCount++;\n          return; // 位置がない場合はスキップ\n        }\n        \n        // Cartesian3からCartographicに変換\n        const cartographic = Cesium.Cartographic.fromCartesian(position);\n        if (!cartographic) {\n          skippedCount++;\n          return;\n        }\n        \n        // 地理座標に変換\n        const lon = Cesium.Math.toDegrees(cartographic.longitude);\n        const lat = Cesium.Math.toDegrees(cartographic.latitude);\n        const alt = cartographic.height;\n        \n        // 範囲外チェック（少しマージンを持たせる）\n        if (lon < bounds.minLon - 0.001 || lon > bounds.maxLon + 0.001 ||\n            lat < bounds.minLat - 0.001 || lat > bounds.maxLat + 0.001 ||\n            alt < bounds.minAlt - 1 || alt > bounds.maxAlt + 1) {\n          skippedCount++;\n          return;\n        }\n        \n        // ボクセルインデックスを計算（範囲0の安全対策）\n        const lonDen = (bounds.maxLon - bounds.minLon);\n        const latDen = (bounds.maxLat - bounds.minLat);\n        const altDen = (bounds.maxAlt - bounds.minAlt);\n\n        const voxelX = lonDen === 0 ? 0 : Math.floor(\n          (lon - bounds.minLon) / lonDen * grid.numVoxelsX\n        );\n        const voxelY = latDen === 0 ? 0 : Math.floor(\n          (lat - bounds.minLat) / latDen * grid.numVoxelsY\n        );\n        const voxelZ = altDen === 0 ? 0 : Math.floor(\n          (alt - bounds.minAlt) / altDen * grid.numVoxelsZ\n        );\n        \n        // インデックスが有効範囲内かチェック\n        if (voxelX >= 0 && voxelX < grid.numVoxelsX &&\n            voxelY >= 0 && voxelY < grid.numVoxelsY &&\n            voxelZ >= 0 && voxelZ < grid.numVoxelsZ) {\n            \n          const voxelKey = VoxelGrid.getVoxelKey(voxelX, voxelY, voxelZ);\n          \n          if (!voxelData.has(voxelKey)) {\n            voxelData.set(voxelKey, {\n              x: voxelX,\n              y: voxelY,\n              z: voxelZ,\n              entities: [],\n              count: 0\n            });\n          }\n          \n          const voxelInfo = voxelData.get(voxelKey);\n          voxelInfo.entities.push(entity);\n          voxelInfo.count++;\n          \n          processedCount++;\n        } else {\n          skippedCount++;\n        }\n      } catch (error) {\n        Logger.warn(`エンティティ ${index} の処理に失敗:`, error);\n        skippedCount++;\n      }\n    });\n    \n    Logger.info(`${processedCount}個のエンティティを${voxelData.size}個のボクセルに分類（${skippedCount}個はスキップ）`);\n    return voxelData;\n  }\n  \n  /**\n   * ボクセルデータから統計情報を計算\n   * @param {Map} voxelData - ボクセルデータ\n   * @param {Object} grid - グリッド情報\n   * @returns {Object} 統計情報\n   */\n  static calculateStatistics(voxelData, grid) {\n    if (voxelData.size === 0) {\n      return {\n        totalVoxels: grid.totalVoxels,\n        renderedVoxels: 0,\n        nonEmptyVoxels: 0,\n        emptyVoxels: grid.totalVoxels,\n        totalEntities: 0,\n        minCount: 0,\n        maxCount: 0,\n        averageCount: 0,\n        // v0.1.4: 自動調整情報の初期化\n        autoAdjusted: false,\n        originalVoxelSize: null,\n        finalVoxelSize: null,\n        adjustmentReason: null\n      };\n    }\n    \n    const counts = Array.from(voxelData.values()).map(voxel => voxel.count);\n    const totalEntities = counts.reduce((sum, count) => sum + count, 0);\n    \n    const stats = {\n      totalVoxels: grid.totalVoxels,\n      renderedVoxels: 0, // 実際の描画後にVoxelRendererから設定される\n      nonEmptyVoxels: voxelData.size,\n      emptyVoxels: grid.totalVoxels - voxelData.size,\n      totalEntities: totalEntities,\n      minCount: Math.min(...counts),\n      maxCount: Math.max(...counts),\n      averageCount: totalEntities / voxelData.size,\n      // v0.1.4: 自動調整情報の初期化\n      autoAdjusted: false,\n      originalVoxelSize: null,\n      finalVoxelSize: null,\n      adjustmentReason: null\n    };\n    \n    Logger.debug('統計情報計算完了:', stats);\n    return stats;\n  }\n  \n  /**\n   * 上位N個のボクセルを取得\n   * @param {Map} voxelData - ボクセルデータ\n   * @param {number} topN - 取得する上位の数\n   * @returns {Array} 上位N個のボクセル情報\n   */\n  static getTopNVoxels(voxelData, topN) {\n    if (voxelData.size === 0 || topN <= 0) {\n      return [];\n    }\n    \n    // ボクセルを密度でソート\n    const sortedVoxels = Array.from(voxelData.values())\n      .sort((a, b) => b.count - a.count);\n    \n    // 上位N個を返す\n    return sortedVoxels.slice(0, Math.min(topN, sortedVoxels.length));\n  }\n}\n","/**\n * ボクセルの描画を担当するクラス\n * プロトタイプ実装ベース（シンプル・確実動作重視）\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../utils/logger.js';\n\n// v0.1.5: カラーマップ定義（256段階のLUTテーブル）\nconst COLOR_MAPS = {\n  // Viridisカラーマップ（簡略化した16段階）\n  viridis: [\n    [68, 1, 84], [71, 44, 122], [59, 81, 139], [44, 113, 142],\n    [33, 144, 141], [39, 173, 129], [92, 200, 99], [170, 220, 50],\n    [253, 231, 37], [255, 255, 255], [255, 255, 255], [255, 255, 255],\n    [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]\n  ],\n  // Infernoカラーマップ（簡略化した16段階）\n  inferno: [\n    [0, 0, 4], [31, 12, 72], [85, 15, 109], [136, 34, 106],\n    [186, 54, 85], [227, 89, 51], [249, 142, 8], [252, 187, 17],\n    [245, 219, 76], [252, 255, 164], [255, 255, 255], [255, 255, 255],\n    [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]\n  ],\n  // 二極性配色（blue-white-red）\n  diverging: [\n    [0, 0, 255], [32, 64, 255], [64, 128, 255], [96, 160, 255],\n    [128, 192, 255], [160, 224, 255], [192, 240, 255], [224, 248, 255],\n    [255, 255, 255], [255, 248, 224], [255, 240, 192], [255, 224, 160],\n    [255, 192, 128], [255, 160, 96], [255, 128, 64], [255, 64, 32], [255, 0, 0]\n  ]\n};\n\n/**\n * 3Dボクセルの描画を担当するクラス\n */\nexport class VoxelRenderer {\n  /**\n   * コンストラクタ\n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer\n   * @param {Object} options - 描画オプション\n   */\n  constructor(viewer, options = {}) {\n    this.viewer = viewer;\n    this.options = {\n      minColor: [0, 0, 255],\n      maxColor: [255, 0, 0],\n      opacity: 0.8,\n      emptyOpacity: 0.03,\n      showOutline: true,\n      showEmptyVoxels: false,\n      wireframeOnly: false,    // 枠線のみ表示\n      heightBased: false,      // 高さベース表現\n      outlineWidth: 2,         // 枠線の太さ\n      // v0.1.6.1: インセット枠線のデフォルト値\n      outlineInset: 0,         // インセット枠線オフセット（メートル）\n      outlineInsetMode: 'all', // インセット枠線適用範囲\n      // v0.1.7: 新オプション\n      outlineRenderMode: 'standard',\n      adaptiveOutlines: false,\n      outlineWidthPreset: 'uniform',\n      boxOpacityResolver: null,\n      outlineOpacityResolver: null,\n      adaptiveParams: {\n        neighborhoodRadius: 50,\n        densityThreshold: 5,\n        cameraDistanceFactor: 1.0,\n        overlapRiskFactor: 0.3\n      },\n      ...options\n    };\n    this.voxelEntities = [];\n    \n    Logger.debug('VoxelRenderer initialized with options:', this.options);\n  }\n\n  /**\n   * 適応的枠線パラメータを計算 (v0.1.7)\n   * @param {Object} voxelInfo - ボクセル情報\n   * @param {boolean} isTopN - TopNボクセルかどうか\n   * @param {Map} voxelData - 全ボクセルデータ\n   * @param {Object} statistics - 統計情報\n   * @returns {Object} 適応的パラメータ\n   * @private\n   */\n  _calculateAdaptiveParams(voxelInfo, isTopN, voxelData, statistics) {\n    if (!this.options.adaptiveOutlines) {\n      return {\n        outlineWidth: null,\n        boxOpacity: null,\n        outlineOpacity: null,\n        shouldUseEmulation: false\n      };\n    }\n\n    const { x, y, z, count } = voxelInfo;\n    const normalizedDensity = statistics.maxCount > statistics.minCount ? \n      (count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;\n    \n    // 近働密度を計算\n    let neighborhoodDensity = 0;\n    let neighborCount = 0;\n    const radius = Math.max(1, Math.floor(this.options.adaptiveParams.neighborhoodRadius / 20)); // 簡略化\n    \n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          if (dx === 0 && dy === 0 && dz === 0) continue;\n          const neighborKey = `${x + dx},${y + dy},${z + dz}`;\n          const neighbor = voxelData.get(neighborKey);\n          if (neighbor) {\n            neighborhoodDensity += neighbor.count;\n            neighborCount++;\n          }\n        }\n      }\n    }\n    \n    const avgNeighborhoodDensity = neighborCount > 0 ? neighborhoodDensity / neighborCount : 0;\n    const isDenseArea = avgNeighborhoodDensity > this.options.adaptiveParams.densityThreshold;\n    \n    // カメラ距離は簡略化（実装では固定値を使用）\n    const cameraDistance = 1000; // 固定値、実際の実装ではカメラからの距離を取得\n    const cameraFactor = Math.min(1.0, 1000 / cameraDistance) * this.options.adaptiveParams.cameraDistanceFactor;\n    \n    // 重なりリスクの算出\n    const overlapRisk = isDenseArea ? this.options.adaptiveParams.overlapRiskFactor : 0;\n    \n    // プリセットによる調整\n    let adaptiveWidth, adaptiveBoxOpacity, adaptiveOutlineOpacity;\n    \n    switch (this.options.outlineWidthPreset) {\n      case 'adaptive-density':\n        adaptiveWidth = isDenseArea ? \n          Math.max(0.5, this.options.outlineWidth * (0.5 + normalizedDensity * 0.5)) :\n          this.options.outlineWidth;\n        adaptiveBoxOpacity = isDenseArea ? this.options.opacity * 0.8 : this.options.opacity;\n        adaptiveOutlineOpacity = isDenseArea ? 0.6 : 1.0;\n        break;\n        \n      case 'topn-focus':\n        adaptiveWidth = isTopN ? \n          this.options.outlineWidth * (1.5 + normalizedDensity * 0.5) :\n          Math.max(0.5, this.options.outlineWidth * 0.7);\n        adaptiveBoxOpacity = isTopN ? this.options.opacity : this.options.opacity * 0.6;\n        adaptiveOutlineOpacity = isTopN ? 1.0 : 0.4;\n        break;\n        \n      case 'uniform':\n      default:\n        adaptiveWidth = this.options.outlineWidth;\n        adaptiveBoxOpacity = this.options.opacity;\n        adaptiveOutlineOpacity = this.options.outlineOpacity || 1.0;\n        break;\n    }\n    \n    // カメラ距離と重なりリスクで調整\n    adaptiveWidth *= cameraFactor;\n    adaptiveOutlineOpacity = Math.max(0.2, adaptiveOutlineOpacity * (1 - overlapRisk));\n    \n    return {\n      outlineWidth: Math.max(0.5, adaptiveWidth),\n      boxOpacity: Math.max(0.1, Math.min(1.0, adaptiveBoxOpacity)),\n      outlineOpacity: Math.max(0.2, Math.min(1.0, adaptiveOutlineOpacity)),\n      shouldUseEmulation: isDenseArea || (adaptiveWidth > 2 && this.options.outlineRenderMode !== 'standard')\n    };\n  }\n\n  /**\n   * ボクセルデータを描画（シンプル実装）\n   * @param {Map} voxelData - ボクセルデータ\n   * @param {Object} bounds - 境界情報\n   * @param {Object} grid - グリッド情報\n   * @param {Object} statistics - 統計情報\n   * @returns {number} 実際に描画されたボクセル数\n   */\n  render(voxelData, bounds, grid, statistics) {\n    this.clear();\n    Logger.debug('VoxelRenderer.render - Starting render with simplified approach', {\n      voxelDataSize: voxelData.size,\n      bounds,\n      grid,\n      statistics\n    });\n\n    // バウンディングボックスのデバッグ表示制御（v0.1.5: debug.showBounds対応）\n    const shouldShowBounds = this._shouldShowBounds();\n    if (shouldShowBounds) {\n      this._renderBoundingBox(bounds);\n    }\n\n    // 表示するボクセルのリスト\n    let displayVoxels = [];\n    const topNVoxels = new Set(); // v0.1.5: TopN強調表示用\n\n    // 空ボクセルのフィルタリング\n    if (this.options.showEmptyVoxels) {\n      // 全ボクセルを生成（これは上限値が大きいとメモリ消費とパフォーマンスに影響する）\n      const maxVoxels = Math.min(grid.totalVoxels, this.options.maxRenderVoxels || 10000);\n      Logger.debug(`Generating grid for up to ${maxVoxels} voxels`);\n      \n      // 空のボクセルも含めて全ボクセルを追加\n      for (let x = 0; x < grid.numVoxelsX; x++) {\n        for (let y = 0; y < grid.numVoxelsY; y++) {\n          for (let z = 0; z < grid.numVoxelsZ; z++) {\n            const voxelKey = `${x},${y},${z}`;\n            const voxelInfo = voxelData.get(voxelKey) || { x, y, z, count: 0 };\n            \n            displayVoxels.push({\n              key: voxelKey,\n              info: voxelInfo\n            });\n            \n            if (displayVoxels.length >= maxVoxels) {\n              Logger.debug(`Reached maximum voxel limit of ${maxVoxels}`);\n              break;\n            }\n          }\n          if (displayVoxels.length >= maxVoxels) break;\n        }\n        if (displayVoxels.length >= maxVoxels) break;\n      }\n    } else {\n      // データがあるボクセルのみ表示\n      displayVoxels = Array.from(voxelData.entries()).map(([key, info]) => {\n        return { key, info };\n      });\n      \n      // 密度でソートして上位を表示\n      if (this.options.maxRenderVoxels && displayVoxels.length > this.options.maxRenderVoxels) {\n        displayVoxels.sort((a, b) => b.info.count - a.info.count);\n        displayVoxels = displayVoxels.slice(0, this.options.maxRenderVoxels);\n        Logger.debug(`Limited to ${displayVoxels.length} highest density voxels`);\n      }\n    }\n\n    // v0.1.5: TopN強調表示の前処理\n    if (this.options.highlightTopN && this.options.highlightTopN > 0) {\n      const sortedForTopN = [...displayVoxels].sort((a, b) => b.info.count - a.info.count);\n      const topN = sortedForTopN.slice(0, this.options.highlightTopN);\n      topN.forEach(voxel => topNVoxels.add(voxel.key));\n      Logger.debug(`TopN highlight enabled: ${topNVoxels.size} voxels will be highlighted`);\n    }\n    \n    Logger.debug(`Rendering ${displayVoxels.length} voxels`);\n    \n    // レンダリングカウント\n    let renderedCount = 0;\n\n    // 実際にボクセルを描画\n    displayVoxels.forEach(({ key, info }) => {\n      try {\n        const { x, y, z } = info;\n        \n        // ボクセル中心座標を計算（シンプルな方法）\n        const centerLon = bounds.minLon + (x + 0.5) * (bounds.maxLon - bounds.minLon) / grid.numVoxelsX;\n        const centerLat = bounds.minLat + (y + 0.5) * (bounds.maxLat - bounds.minLat) / grid.numVoxelsY;\n        const centerAlt = bounds.minAlt + (z + 0.5) * (bounds.maxAlt - bounds.minAlt) / grid.numVoxelsZ;\n        \n        const isTopN = topNVoxels.has(key); // v0.1.5: TopNハイライト判定\n        \n        // v0.1.7: 適応的パラメータの計算\n        const adaptiveParams = this._calculateAdaptiveParams(info, isTopN, voxelData, statistics);\n        \n        // 密度に応じた色を計算\n        let color, opacity;\n        \n        if (info.count === 0) {\n          // 空ボクセルの場合\n          color = Cesium.Color.LIGHTGRAY;\n          opacity = this.options.emptyOpacity;\n        } else {\n          // データありボクセルの場合\n          const normalizedDensity = statistics.maxCount > statistics.minCount ? \n            (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;\n          \n          color = this.interpolateColor(normalizedDensity, info.count);\n          \n          // v0.1.7: 透明度resolverの適用（優先順位：resolver > 適応的 > 固定値）\n          if (this.options.boxOpacityResolver && typeof this.options.boxOpacityResolver === 'function') {\n            const resolverCtx = {\n              voxel: { x, y, z, count: info.count },\n              isTopN,\n              normalizedDensity,\n              statistics,\n              adaptiveParams\n            };\n            try {\n              const resolverOpacity = this.options.boxOpacityResolver(resolverCtx);\n              opacity = isNaN(resolverOpacity) ? this.options.opacity : Math.max(0, Math.min(1, resolverOpacity));\n            } catch (e) {\n              Logger.warn('boxOpacityResolver error, using fallback:', e);\n              opacity = adaptiveParams.boxOpacity || this.options.opacity;\n            }\n          } else {\n            opacity = adaptiveParams.boxOpacity || this.options.opacity;\n          }\n          \n          // v0.1.5: TopN強調表示で非TopNボクセルを淡色化（resolver適用後）\n          if (this.options.highlightTopN && !isTopN && !this.options.boxOpacityResolver) {\n            opacity *= (1 - (this.options.highlightStyle?.boostOpacity || 0.2));\n          }\n        }\n        \n        // v0.1.6: ボクセル寸法計算（voxelGap対応）\n        // 各軸のセルサイズ（グリッドが持つ実セルサイズを優先、なければvoxelSizeMetersにフォールバック）\n        let cellSizeX = grid.cellSizeX || (grid.lonRangeMeters ? (grid.lonRangeMeters / grid.numVoxelsX) : grid.voxelSizeMeters);\n        let cellSizeY = grid.cellSizeY || (grid.latRangeMeters ? (grid.latRangeMeters / grid.numVoxelsY) : grid.voxelSizeMeters);\n        let baseCellSizeZ = grid.cellSizeZ || (grid.altRangeMeters ? Math.max(grid.altRangeMeters / Math.max(grid.numVoxelsZ, 1), 1) : Math.max(grid.voxelSizeMeters, 1));\n\n        // v0.1.6: voxelGap による寸法縮小（枠線重なり対策）\n        if (this.options.voxelGap > 0) {\n          cellSizeX = Math.max(cellSizeX - this.options.voxelGap, cellSizeX * 0.1);\n          cellSizeY = Math.max(cellSizeY - this.options.voxelGap, cellSizeY * 0.1);\n          baseCellSizeZ = Math.max(baseCellSizeZ - this.options.voxelGap, baseCellSizeZ * 0.1);\n        }\n\n        let boxHeight = baseCellSizeZ;\n        if (this.options.heightBased && info.count > 0) {\n          const normalizedDensity = statistics.maxCount > statistics.minCount ? \n            (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;\n          boxHeight = baseCellSizeZ * (0.1 + normalizedDensity * 0.9); // 10%から100%の高さ\n        }\n        \n        // v0.1.7: 動的枠線太さ制御（優先順位：resolver > 適応的 > 固定値）\n        let finalOutlineWidth;\n        if (this.options.outlineWidthResolver && typeof this.options.outlineWidthResolver === 'function') {\n          // outlineWidthResolver による動的制御\n          const normalizedDensity = statistics.maxCount > statistics.minCount ? \n            (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;\n          const resolverParams = {\n            voxel: { x, y, z, count: info.count },\n            isTopN,\n            normalizedDensity,\n            statistics,\n            adaptiveParams\n          };\n          try {\n            finalOutlineWidth = this.options.outlineWidthResolver(resolverParams);\n            if (isNaN(finalOutlineWidth)) {\n              finalOutlineWidth = adaptiveParams.outlineWidth || this.options.outlineWidth;\n            }\n          } catch (e) {\n            Logger.warn('outlineWidthResolver error, using fallback:', e);\n            finalOutlineWidth = adaptiveParams.outlineWidth || this.options.outlineWidth;\n          }\n        } else {\n          // v0.1.7: 適応的パラメータを優先、なければ従来の静的制御\n          if (this.options.adaptiveOutlines && adaptiveParams.outlineWidth !== null) {\n            finalOutlineWidth = adaptiveParams.outlineWidth;\n          } else {\n            finalOutlineWidth = isTopN && this.options.highlightTopN ? \n              (this.options.highlightStyle?.outlineWidth || this.options.outlineWidth) : \n              this.options.outlineWidth;\n          }\n        }\n\n        // v0.1.7: 枠線透明度制御（resolver > 適応的 > 固定値）\n        let finalOutlineOpacity;\n        if (this.options.outlineOpacityResolver && typeof this.options.outlineOpacityResolver === 'function') {\n          const normalizedDensity = statistics.maxCount > statistics.minCount ? \n            (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;\n          const resolverCtx = {\n            voxel: { x, y, z, count: info.count },\n            isTopN,\n            normalizedDensity,\n            statistics,\n            adaptiveParams\n          };\n          try {\n            const resolverOpacity = this.options.outlineOpacityResolver(resolverCtx);\n            finalOutlineOpacity = isNaN(resolverOpacity) ? (this.options.outlineOpacity ?? 1.0) : Math.max(0, Math.min(1, resolverOpacity));\n          } catch (e) {\n            Logger.warn('outlineOpacityResolver error, using fallback:', e);\n            finalOutlineOpacity = adaptiveParams.outlineOpacity || (this.options.outlineOpacity ?? 1.0);\n          }\n        } else {\n          finalOutlineOpacity = adaptiveParams.outlineOpacity || (this.options.outlineOpacity ?? 1.0);\n        }\n        \n        const outlineColorWithOpacity = color.withAlpha(finalOutlineOpacity);\n\n        // v0.1.7: outlineRenderModeによる表示モード制御\n        let shouldShowStandardOutline = true;\n        let shouldShowInsetOutline = false;\n        let shouldUseEmulationOnly = false;\n        \n        switch (this.options.outlineRenderMode) {\n          case 'standard':\n            shouldShowStandardOutline = this.options.showOutline;\n            shouldShowInsetOutline = this.options.outlineInset > 0;\n            break;\n          case 'inset':\n            shouldShowStandardOutline = false; // インセットモードでは標準枠線を無効化\n            shouldShowInsetOutline = true;\n            break;\n          case 'emulation-only':\n            shouldShowStandardOutline = false;\n            shouldShowInsetOutline = false;\n            shouldUseEmulationOnly = true;\n            break;\n        }\n        \n        // v0.1.7: 適応的エミュレーション判定を組み込み\n        let emulateThickForThis = shouldUseEmulationOnly;\n        if (!shouldUseEmulationOnly) {\n          // 従来のoutlineEmulationオプションを尊重\n          if (this.options.outlineEmulation === 'topn') {\n            emulateThickForThis = isTopN && (finalOutlineWidth || 1) > 1;\n          } else if (this.options.outlineEmulation === 'non-topn') {\n            emulateThickForThis = !isTopN && (finalOutlineWidth || 1) > 1;\n          } else if (this.options.outlineEmulation === 'all') {\n            emulateThickForThis = (finalOutlineWidth || 1) > 1;\n          } else if (this.options.adaptiveOutlines && adaptiveParams.shouldUseEmulation) {\n            emulateThickForThis = true;\n          }\n        }\n        \n        // エンティティの設定\n        const entityConfig = {\n          position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt),\n          box: {\n            dimensions: new Cesium.Cartesian3(\n              cellSizeX,\n              cellSizeY,\n              boxHeight\n            ),\n            outline: shouldShowStandardOutline && !emulateThickForThis,\n            outlineColor: outlineColorWithOpacity,\n            outlineWidth: Math.max(finalOutlineWidth || 1, 0) // 負値防止\n          },\n          properties: {\n            type: 'voxel',\n            key: key,\n            count: info.count,\n            x: x,\n            y: y,\n            z: z\n          },\n          description: this.createVoxelDescription(info, key)\n        };\n\n        // wireframeOnlyモードの場合は透明、そうでなければ通常の材質\n        if (this.options.wireframeOnly) {\n          entityConfig.box.material = Cesium.Color.TRANSPARENT;\n          entityConfig.box.fill = false;\n        } else {\n          entityConfig.box.material = color.withAlpha(opacity);\n          entityConfig.box.fill = true;\n        }\n        \n        // エンティティを作成\n        const entity = this.viewer.entities.add(entityConfig);\n        \n        this.voxelEntities.push(entity);\n\n        // v0.1.7: インセット枠線の実装（outlineRenderModeに応じて制御）\n        if (shouldShowInsetOutline && this._shouldApplyInsetOutline(isTopN)) {\n          try {\n            const insetAmount = this.options.outlineInset > 0 ? this.options.outlineInset : 1; // emulation-onlyでは最低1m\n            this._createInsetOutline(\n              centerLon, centerLat, centerAlt,\n              cellSizeX, cellSizeY, boxHeight,\n              outlineColorWithOpacity, Math.max(finalOutlineWidth || 1, 1),\n              key, insetAmount\n            );\n          } catch (e) {\n            Logger.warn('Failed to create inset outline:', e);\n          }\n        }\n        \n        // 太線エミュレーション（条件に応じてポリラインでエッジを追加）\n        // 隣接枠線の被りを避けるため、外縁ではなく“インセット後”の寸法でエッジを描く\n        if (emulateThickForThis) {\n          try {\n            const centerCart = entity.position.getValue(Cesium.JulianDate.now());\n\n            const maxInsetX = cellSizeX * 0.2;\n            const maxInsetY = cellSizeY * 0.2;\n            const maxInsetZ = boxHeight * 0.2;\n            const baseInset = (this.options.outlineInset && this.options.outlineInset > 0) ? this.options.outlineInset : 0;\n            const autoInsetX = cellSizeX * 0.05;\n            const autoInsetY = cellSizeY * 0.05;\n            const autoInsetZ = boxHeight * 0.05;\n            const effInsetX = Math.min(baseInset > 0 ? baseInset : autoInsetX, maxInsetX);\n            const effInsetY = Math.min(baseInset > 0 ? baseInset : autoInsetY, maxInsetY);\n            const effInsetZ = Math.min(baseInset > 0 ? baseInset : autoInsetZ, maxInsetZ);\n\n            // 外縁とインセットの“中間”に相当する寸法（片側ぶんだけ縮める）\n            const midSizeX = Math.max(cellSizeX - effInsetX, cellSizeX * 0.1);\n            const midSizeY = Math.max(cellSizeY - effInsetY, cellSizeY * 0.1);\n            const midSizeZ = Math.max(boxHeight - effInsetZ, boxHeight * 0.1);\n\n            this._addEdgePolylines(\n              centerCart,\n              midSizeX,\n              midSizeY,\n              midSizeZ,\n              outlineColorWithOpacity,\n              Math.max(finalOutlineWidth, 1)\n            );\n          } catch (e) {\n            Logger.warn('Failed to add emulated thick outline polylines:', e);\n          }\n        }\n        renderedCount++;\n      } catch (error) {\n        Logger.warn('Error rendering voxel:', error);\n      }\n    });\n\n    Logger.info(`Successfully rendered ${renderedCount} voxels`);\n    \n    // 実際に描画されたボクセル数を返す\n    return renderedCount;\n  }\n\n  /**\n   * バウンディングボックスを描画（デバッグ用）\n   * @param {Object} bounds - 境界情報\n   * @private\n   */\n  _renderBoundingBox(bounds) {\n    if (!bounds) return;\n\n    try {\n      // 中心点\n      const centerLon = (bounds.minLon + bounds.maxLon) / 2;\n      const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n      const centerAlt = (bounds.minAlt + bounds.maxAlt) / 2;\n      \n      // サイズ計算（概算）\n      const widthMeters = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);\n      const depthMeters = (bounds.maxLat - bounds.minLat) * 111000;\n      const heightMeters = bounds.maxAlt - bounds.minAlt;\n      \n      // 境界ボックスの作成\n      const boundingBox = this.viewer.entities.add({\n        position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt),\n        box: {\n          dimensions: new Cesium.Cartesian3(widthMeters, depthMeters, heightMeters),\n          material: Cesium.Color.YELLOW.withAlpha(0.1),\n          outline: true,\n          outlineColor: Cesium.Color.YELLOW.withAlpha(0.3),\n          outlineWidth: 2\n        },\n        description: `バウンディングボックス<br>サイズ: ${widthMeters.toFixed(1)} x ${depthMeters.toFixed(1)} x ${heightMeters.toFixed(1)} m`\n      });\n      \n      this.voxelEntities.push(boundingBox);\n      \n      Logger.debug('Debug bounding box added:', {\n        center: { lon: centerLon, lat: centerLat, alt: centerAlt },\n        size: { width: widthMeters, depth: depthMeters, height: heightMeters }\n      });\n      \n    } catch (error) {\n      Logger.warn('Failed to render bounding box:', error);\n    }\n  }\n\n  /**\n   * ボックスのエッジをポリラインで描画（太線エミュレーション）\n   * @param {Cesium.Cartesian3} centerCart - ボックス中心\n   * @param {number} sx - X寸法（m）\n   * @param {number} sy - Y寸法（m）\n   * @param {number} sz - Z寸法（m）\n   * @param {Cesium.Color} color - 線色\n   * @param {number} width - 線幅（px）\n   * @private\n   */\n  _addEdgePolylines(centerCart, sx, sy, sz, color, width) {\n    try {\n      const halfX = sx / 2, halfY = sy / 2, halfZ = sz / 2;\n      const enu = Cesium.Transforms.eastNorthUpToFixedFrame(centerCart);\n      const toWorld = (dx, dy, dz) => {\n        const local = new Cesium.Cartesian3(dx, dy, dz);\n        return Cesium.Matrix4.multiplyByPoint(enu, local, new Cesium.Cartesian3());\n      };\n      const C = [\n        toWorld(-halfX, -halfY, -halfZ),\n        toWorld( halfX, -halfY, -halfZ),\n        toWorld( halfX,  halfY, -halfZ),\n        toWorld(-halfX,  halfY, -halfZ),\n        toWorld(-halfX, -halfY,  halfZ),\n        toWorld( halfX, -halfY,  halfZ),\n        toWorld( halfX,  halfY,  halfZ),\n        toWorld(-halfX,  halfY,  halfZ)\n      ];\n      const edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];\n      edges.forEach(([i, j]) => {\n        const poly = this.viewer.entities.add({\n          polyline: {\n            positions: [C[i], C[j]],\n            width: width,\n            material: color,\n            arcType: Cesium.ArcType.NONE\n          }\n        });\n        this.voxelEntities.push(poly);\n      });\n    } catch (error) {\n      Logger.warn('Edge polyline creation failed:', error);\n    }\n  }\n\n  /**\n   * 密度に基づいて色を補間（v0.1.5: カラーマップ対応）\n   * @param {number} normalizedDensity - 正規化された密度 (0-1)\n   * @param {number} [rawValue] - 生値（二極性配色用）\n   * @returns {Cesium.Color} 計算された色\n   */\n  interpolateColor(normalizedDensity, rawValue = null) {\n    // v0.1.5: 二極性配色対応（pivot<=0 の場合は安全にフォールバック）\n    if (this.options.diverging && rawValue !== null) {\n      const pivot = typeof this.options.divergingPivot === 'number' ? this.options.divergingPivot : 0;\n      if (pivot > 0) {\n        return this._interpolateDivergingColor(rawValue);\n      }\n      // pivot が 0 以下の場合は従来の補間にフォールバック\n    }\n    \n    // v0.1.5: カラーマップ対応\n    if (this.options.colorMap && this.options.colorMap !== 'custom') {\n      return this._interpolateFromColorMap(normalizedDensity, this.options.colorMap);\n    }\n    \n    // 従来のmin/max色補間（後方互換）\n    const [minR, minG, minB] = this.options.minColor;\n    const [maxR, maxG, maxB] = this.options.maxColor;\n    \n    const r = Math.round(minR + (maxR - minR) * normalizedDensity);\n    const g = Math.round(minG + (maxG - minG) * normalizedDensity);\n    const b = Math.round(minB + (maxB - minB) * normalizedDensity);\n    \n    return Cesium.Color.fromBytes(r, g, b);\n  }\n  \n  /**\n   * カラーマップから色を補間\n   * @param {number} normalizedValue - 正規化された値 (0-1)\n   * @param {string} colorMapName - カラーマップ名\n   * @returns {Cesium.Color} 計算された色\n   * @private\n   */\n  _interpolateFromColorMap(normalizedValue, colorMapName) {\n    const colorMap = COLOR_MAPS[colorMapName];\n    if (!colorMap) {\n      Logger.warn(`Unknown color map: ${colorMapName}. Falling back to custom.`);\n      return this.interpolateColor(normalizedValue);\n    }\n    \n    // マップインデックスを計算\n    const scaledValue = normalizedValue * (colorMap.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.min(lowerIndex + 1, colorMap.length - 1);\n    const fraction = scaledValue - lowerIndex;\n    \n    // 線形補間\n    const [r1, g1, b1] = colorMap[lowerIndex];\n    const [r2, g2, b2] = colorMap[upperIndex];\n    \n    const r = Math.round(r1 + (r2 - r1) * fraction);\n    const g = Math.round(g1 + (g2 - g1) * fraction);\n    const b = Math.round(b1 + (b2 - b1) * fraction);\n    \n    return Cesium.Color.fromBytes(r, g, b);\n  }\n  \n  /**\n   * 二極性配色（blue-white-red）で色を補間\n   * @param {number} rawValue - 生値\n   * @returns {Cesium.Color} 計算された色\n   * @private\n   */\n  _interpolateDivergingColor(rawValue) {\n    const pivot = this.options.divergingPivot || 0;\n    \n    // ピボットからの偏差を正規化\n    let normalizedValue;\n    if (rawValue <= pivot) {\n      // 青い側 (0 to 0.5)\n      normalizedValue = 0.5 * (rawValue / pivot);\n      normalizedValue = Math.max(0, Math.min(0.5, normalizedValue));\n    } else {\n      // 赤い側 (0.5 to 1)\n      normalizedValue = 0.5 + 0.5 * ((rawValue - pivot) / pivot);\n      normalizedValue = Math.max(0.5, Math.min(1, normalizedValue));\n    }\n    \n    return this._interpolateFromColorMap(normalizedValue, 'diverging');\n  }\n\n  /**\n   * ボクセルの説明文を生成\n   * @param {Object} voxelInfo - ボクセル情報\n   * @param {string} voxelKey - ボクセルキー\n   * @returns {string} HTML形式の説明文\n   */\n  createVoxelDescription(voxelInfo, voxelKey) {\n    return `\n      <div style=\"padding: 10px; font-family: Arial, sans-serif;\">\n        <h3 style=\"margin-top: 0;\">ボクセル [${voxelInfo.x}, ${voxelInfo.y}, ${voxelInfo.z}]</h3>\n        <table style=\"width: 100%;\">\n          <tr><td><b>エンティティ数:</b></td><td>${voxelInfo.count}</td></tr>\n          <tr><td><b>ID:</b></td><td>${voxelKey}</td></tr>\n        </table>\n      </div>\n    `;\n  }\n\n  /**\n   * 描画されたエンティティを全てクリア\n   */\n  clear() {\n    Logger.debug('VoxelRenderer.clear - Removing', this.voxelEntities.length, 'entities');\n    \n    this.voxelEntities.forEach(entity => {\n      try {\n        // isDestroyedのチェックを安全に行う\n        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n        \n        if (entity && !isDestroyed) {\n          this.viewer.entities.remove(entity);\n        }\n      } catch (error) {\n        Logger.warn('Entity removal error:', error);\n      }\n    });\n    \n    this.voxelEntities = [];\n  }\n\n  /**\n   * デバッグ境界ボックス表示の判定（v0.1.5: debug.showBounds対応）\n   * @returns {boolean} 境界ボックスを表示する場合はtrue\n   * @private\n   */\n  _shouldShowBounds() {\n    if (!this.options.debug) {\n      return false;\n    }\n    \n    if (typeof this.options.debug === 'boolean') {\n      // 従来の動作：debugがtrueの場合はバウンディングボックス表示\n      return this.options.debug;\n    }\n    \n    if (typeof this.options.debug === 'object' && this.options.debug !== null) {\n      // 新しい動作：debug.showBoundsで明示的に制御\n      return this.options.debug.showBounds === true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * インセット枠線を適用すべきかどうかを判定（ADR-0004）\n   * @param {boolean} isTopN - TopNボクセルかどうか\n   * @returns {boolean} インセット枠線を適用する場合はtrue\n   * @private\n   */\n  _shouldApplyInsetOutline(isTopN) {\n    const mode = this.options.outlineInsetMode || 'all';\n    switch (mode) {\n      case 'topn':\n        return isTopN;\n      case 'all':\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * インセット枠線用のセカンダリBoxエンティティを作成（ADR-0004）\n   * @param {number} centerLon - 中心経度\n   * @param {number} centerLat - 中心緯度  \n   * @param {number} centerAlt - 中心高度\n   * @param {number} baseSizeX - 基本サイズX\n   * @param {number} baseSizeY - 基本サイズY\n   * @param {number} baseSizeZ - 基本サイズZ\n   * @param {Cesium.Color} outlineColor - 枠線色\n   * @param {number} outlineWidth - 枠線太さ\n   * @param {string} voxelKey - ボクセルキー\n   * @param {number} [insetAmount] - v0.1.7: インセット量のオーバーライド\n   * @private\n   */\n  _createInsetOutline(centerLon, centerLat, centerAlt, baseSizeX, baseSizeY, baseSizeZ, outlineColor, outlineWidth, voxelKey, insetAmount = null) {\n    // インセット距離の適用（ADR-0004の境界条件：両側合計で各軸寸法の最大40%まで＝片側20%）\n    // 片側20%までに制限することで、最終寸法は元の60%以上を保証する\n    const maxInsetX = baseSizeX * 0.2;\n    const maxInsetY = baseSizeY * 0.2;\n    const maxInsetZ = baseSizeZ * 0.2;\n    \n    const baseInset = insetAmount !== null ? insetAmount : this.options.outlineInset;\n    const effectiveInsetX = Math.min(baseInset, maxInsetX);\n    const effectiveInsetY = Math.min(baseInset, maxInsetY);  \n    const effectiveInsetZ = Math.min(baseInset, maxInsetZ);\n    \n    // インセット後の寸法計算（各軸から2倍のインセットを引く）\n    const insetSizeX = Math.max(baseSizeX - (effectiveInsetX * 2), baseSizeX * 0.1);\n    const insetSizeY = Math.max(baseSizeY - (effectiveInsetY * 2), baseSizeY * 0.1);\n    const insetSizeZ = Math.max(baseSizeZ - (effectiveInsetZ * 2), baseSizeZ * 0.1);\n    \n    // セカンダリBoxエンティティの設定（枠線のみ、塗りなし）\n    const insetEntity = this.viewer.entities.add({\n      position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt),\n      box: {\n        dimensions: new Cesium.Cartesian3(insetSizeX, insetSizeY, insetSizeZ),\n        fill: false,\n        outline: true,\n        outlineColor: outlineColor,\n        outlineWidth: Math.max(outlineWidth || 1, 0)\n      },\n      properties: {\n        type: 'voxel-inset-outline',\n        parentKey: voxelKey,\n        insetSize: { x: insetSizeX, y: insetSizeY, z: insetSizeZ }\n      }\n    });\n    \n    this.voxelEntities.push(insetEntity);\n    \n    // 枠線の厚み部分を視覚化（WebGL 1px制限の回避）\n    if (this.options.enableThickFrames && (effectiveInsetX > 0.1 || effectiveInsetY > 0.1 || effectiveInsetZ > 0.1)) {\n      this._createThickOutlineFrames(\n        centerLon, centerLat, centerAlt,\n        baseSizeX, baseSizeY, baseSizeZ,\n        insetSizeX, insetSizeY, insetSizeZ,\n        outlineColor, voxelKey\n      );\n    }\n    \n    Logger.debug(`Inset outline created for voxel ${voxelKey}:`, {\n      originalSize: { x: baseSizeX, y: baseSizeY, z: baseSizeZ },\n      insetSize: { x: insetSizeX, y: insetSizeY, z: insetSizeZ },\n      effectiveInset: { x: effectiveInsetX, y: effectiveInsetY, z: effectiveInsetZ }\n    });\n  }\n\n  /**\n   * 枠線の厚み部分を視覚化するフレーム構造を作成\n   * メインボックスとインセットボックスの間を12個のボックスで埋める\n   * @param {number} centerLon - 中心経度\n   * @param {number} centerLat - 中心緯度\n   * @param {number} centerAlt - 中心高度\n   * @param {number} outerX - 外側サイズX\n   * @param {number} outerY - 外側サイズY\n   * @param {number} outerZ - 外側サイズZ\n   * @param {number} innerX - 内側サイズX\n   * @param {number} innerY - 内側サイズY\n   * @param {number} innerZ - 内側サイズZ\n   * @param {Cesium.Color} frameColor - フレーム色\n   * @param {string} voxelKey - ボクセルキー\n   * @private\n   */\n  _createThickOutlineFrames(centerLon, centerLat, centerAlt, outerX, outerY, outerZ, innerX, innerY, innerZ, frameColor, voxelKey) {\n    // フレーム厚み計算（外側と内側の差を2で割ったもの）\n    const frameThickX = (outerX - innerX) / 2;\n    const frameThickY = (outerY - innerY) / 2;\n    const frameThickZ = (outerZ - innerZ) / 2;\n    \n    // 境界計算：各軸での内側・外側の境界\n    const outerBoundX = outerX / 2;    // 外側境界（中心からの距離）\n    const outerBoundY = outerY / 2;\n    const outerBoundZ = outerZ / 2;\n    const innerBoundX = innerX / 2;    // 内側境界（中心からの距離）\n    const innerBoundY = innerY / 2;\n    const innerBoundZ = innerZ / 2;\n    \n    Logger.debug(`Frame bounds for ${voxelKey}:`, {\n      frameThick: { x: frameThickX, y: frameThickY, z: frameThickZ },\n      outerBound: { x: outerBoundX, y: outerBoundY, z: outerBoundZ },\n      innerBound: { x: innerBoundX, y: innerBoundY, z: innerBoundZ }\n    });\n    \n    // 12個のフレームボックスを配置（外側と内側の境界間に正確にフィット）\n    const frames = [\n      // 上面の枠線（4つ）- Z軸上側\n      { \n        pos: [0, (outerBoundY + innerBoundY) / 2, outerBoundZ - frameThickZ / 2], \n        size: [innerX, frameThickY, frameThickZ], \n        name: 'top-back' \n      },\n      { \n        pos: [0, -(outerBoundY + innerBoundY) / 2, outerBoundZ - frameThickZ / 2], \n        size: [innerX, frameThickY, frameThickZ], \n        name: 'top-front' \n      },\n      { \n        pos: [(outerBoundX + innerBoundX) / 2, 0, outerBoundZ - frameThickZ / 2], \n        size: [frameThickX, outerY, frameThickZ], \n        name: 'top-right' \n      },\n      { \n        pos: [-(outerBoundX + innerBoundX) / 2, 0, outerBoundZ - frameThickZ / 2], \n        size: [frameThickX, outerY, frameThickZ], \n        name: 'top-left' \n      },\n      \n      // 下面の枠線（4つ）- Z軸下側\n      { \n        pos: [0, (outerBoundY + innerBoundY) / 2, -outerBoundZ + frameThickZ / 2], \n        size: [innerX, frameThickY, frameThickZ], \n        name: 'bottom-back' \n      },\n      { \n        pos: [0, -(outerBoundY + innerBoundY) / 2, -outerBoundZ + frameThickZ / 2], \n        size: [innerX, frameThickY, frameThickZ], \n        name: 'bottom-front' \n      },\n      { \n        pos: [(outerBoundX + innerBoundX) / 2, 0, -outerBoundZ + frameThickZ / 2], \n        size: [frameThickX, outerY, frameThickZ], \n        name: 'bottom-right' \n      },\n      { \n        pos: [-(outerBoundX + innerBoundX) / 2, 0, -outerBoundZ + frameThickZ / 2], \n        size: [frameThickX, outerY, frameThickZ], \n        name: 'bottom-left' \n      },\n      \n      // 縦の枠線（4つ）- 角の柱\n      { \n        pos: [(outerBoundX + innerBoundX) / 2, (outerBoundY + innerBoundY) / 2, 0], \n        size: [frameThickX, frameThickY, innerZ], \n        name: 'vertical-back-right' \n      },\n      { \n        pos: [(outerBoundX + innerBoundX) / 2, -(outerBoundY + innerBoundY) / 2, 0], \n        size: [frameThickX, frameThickY, innerZ], \n        name: 'vertical-front-right' \n      },\n      { \n        pos: [-(outerBoundX + innerBoundX) / 2, (outerBoundY + innerBoundY) / 2, 0], \n        size: [frameThickX, frameThickY, innerZ], \n        name: 'vertical-back-left' \n      },\n      { \n        pos: [-(outerBoundX + innerBoundX) / 2, -(outerBoundY + innerBoundY) / 2, 0], \n        size: [frameThickX, frameThickY, innerZ], \n        name: 'vertical-front-left' \n      }\n    ];\n    \n    // 各フレームボックスを作成\n    frames.forEach(frame => {\n      if (frame.size[0] > 0.1 && frame.size[1] > 0.1 && frame.size[2] > 0.1) {\n        try {\n          // より正確な座標計算：経度・緯度・高度で直接オフセット\n          const DEG_PER_METER_LON = 1 / (111000 * Math.cos(centerLat * Math.PI / 180));\n          const DEG_PER_METER_LAT = 1 / 111000;\n          \n          const frameLon = centerLon + frame.pos[0] * DEG_PER_METER_LON;\n          const frameLat = centerLat + frame.pos[1] * DEG_PER_METER_LAT;\n          const frameAlt = centerAlt + frame.pos[2];\n          \n          const frameEntity = this.viewer.entities.add({\n            position: Cesium.Cartesian3.fromDegrees(frameLon, frameLat, frameAlt),\n            box: {\n              dimensions: new Cesium.Cartesian3(frame.size[0], frame.size[1], frame.size[2]),\n              material: frameColor.withAlpha(0.8), // 少し透明度を下げて重なりを考慮\n              outline: false, // 内部フレームには枠線なし\n              fill: true\n            },\n            properties: {\n              type: 'voxel-outline-frame',\n              parentKey: voxelKey,\n              frameName: frame.name\n            }\n          });\n          \n          this.voxelEntities.push(frameEntity);\n        } catch (e) {\n          Logger.warn(`Failed to create outline frame ${frame.name}:`, e);\n        }\n      }\n    });\n    \n    Logger.debug(`Thick outline frames created for voxel ${voxelKey}: ${frames.length} frames`);\n  }\n\n  /**\n   * 表示/非表示を切り替え\n   * @param {boolean} show - 表示する場合はtrue\n   */\n  setVisible(show) {\n    Logger.debug('VoxelRenderer.setVisible:', show);\n    \n    this.voxelEntities.forEach(entity => {\n      try {\n        // isDestroyedのチェックを安全に行う\n        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n        \n        if (entity && !isDestroyed) {\n          entity.show = show;\n        }\n      } catch (error) {\n        Logger.warn('Entity visibility error:', error);\n      }\n    });\n  }\n}\n","/**\n * CesiumJS Heatbox - エントリーポイント\n */\n\nimport { Heatbox } from './Heatbox.js';\nimport { Logger } from './utils/logger.js';\nimport { getAllEntities, generateTestEntities } from './utils/sampleData.js';\n\n// デフォルトエクスポート\nexport default Heatbox;\n\n// 名前付きエクスポート\nexport { Heatbox };\nexport { getAllEntities, generateTestEntities };\n\n// 互換性のための追加エクスポート\nexport { Heatbox as CesiumHeatbox };\n\n/**\n * ライブラリのメタ情報\n */\nexport const VERSION = '0.1.7';\nexport const AUTHOR = 'hiro-nyon';\nexport const REPOSITORY = 'https://github.com/hiro-nyon/cesium-heatbox';\n\n/**\n * Quick start helper function\n * @param {Object} viewer - CesiumJS Viewer\n * @param {Object} options - Configuration options\n * @returns {Heatbox} New Heatbox instance\n */\nexport function createHeatbox(viewer, options) {\n  return new Heatbox(viewer, options);\n}\n\n/**\n * 環境情報を取得\n * @returns {Object} 環境情報\n */\nexport function getEnvironmentInfo() {\n  // WebGL サポートの確認\n  let webglSupport = false;\n  try {\n    if (typeof WebGLRenderingContext !== 'undefined') {\n      const canvas = document.createElement('canvas');\n      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n      webglSupport = !!gl;\n    }\n  } catch (_e) {\n    webglSupport = false;\n  }\n  \n  return {\n    version: VERSION,\n    cesiumVersion: typeof Cesium !== 'undefined' ? Cesium.VERSION : 'N/A',\n    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'N/A',\n    webglSupport: webglSupport,\n    timestamp: new Date().toISOString()\n  };\n}\n\n// ライブラリの初期化ログ\nLogger.info(`CesiumJS Heatbox v${VERSION} loaded`);\n","/**\n * CesiumJS Heatbox - メインクラス\n */\nimport * as Cesium from 'cesium';\nimport { DEFAULT_OPTIONS, ERROR_MESSAGES, PERFORMANCE_LIMITS } from './utils/constants.js';\nimport { isValidViewer, isValidEntities, validateAndNormalizeOptions, validateVoxelCount, estimateInitialVoxelSize, calculateDataRange } from './utils/validation.js';\nimport { Logger } from './utils/logger.js';\nimport { CoordinateTransformer } from './core/CoordinateTransformer.js';\nimport { VoxelGrid } from './core/VoxelGrid.js';\nimport { DataProcessor } from './core/DataProcessor.js';\nimport { VoxelRenderer } from './core/VoxelRenderer.js';\n\n/**\n * CesiumJS Heatbox メインクラス\n * 3Dボクセルベースのヒートマップ可視化を提供\n */\nexport class Heatbox {\n  /**\n   * コンストラクタ\n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer インスタンス\n   * @param {Object} options - 設定オプション\n   */\n  constructor(viewer, options = {}) {\n    if (!isValidViewer(viewer)) {\n      throw new Error(ERROR_MESSAGES.INVALID_VIEWER);\n    }\n    \n    this.viewer = viewer;\n    this.options = validateAndNormalizeOptions({ ...DEFAULT_OPTIONS, ...options });\n    // ログレベルをオプションに基づいて設定\n    Logger.setLogLevel(this.options);\n    this.renderer = new VoxelRenderer(this.viewer, this.options);\n    \n    this._bounds = null;\n    this._grid = null;\n    this._voxelData = null;\n    this._statistics = null;\n    this._eventHandler = null;\n\n    this._initializeEventListeners();\n  }\n\n  /**\n   * ヒートマップデータを設定し、描画を実行\n   * @param {Cesium.Entity[]} entities - 対象エンティティ配列\n   */\n  setData(entities) {\n    if (!isValidEntities(entities)) {\n      this.clear();\n      return;\n    }\n    \n    try {\n      Logger.debug('Heatbox.setData - 処理開始:', entities.length, '個のエンティティ');\n      \n      // 1. 境界計算\n      Logger.debug('Step 1: 境界計算');\n      this._bounds = CoordinateTransformer.calculateBounds(entities);\n      if (!this._bounds) {\n        Logger.error('境界計算に失敗');\n        this.clear();\n        return;\n      }\n      Logger.debug('境界計算完了:', this._bounds);\n\n      // v0.1.4: 自動ボクセルサイズ調整\n      let finalVoxelSize = this.options.voxelSize || DEFAULT_OPTIONS.voxelSize;\n      let autoAdjustmentInfo = null;\n      \n      if (this.options.autoVoxelSize && !this.options.voxelSize) {\n        try {\n          Logger.debug('自動ボクセルサイズ調整開始');\n          const estimatedSize = estimateInitialVoxelSize(this._bounds, entities.length);\n          const tempGrid = VoxelGrid.createGrid(this._bounds, estimatedSize);\n          const validation = validateVoxelCount(tempGrid.totalVoxels, estimatedSize);\n          \n          if (!validation.valid && validation.recommendedSize) {\n            finalVoxelSize = validation.recommendedSize;\n            autoAdjustmentInfo = {\n              enabled: true,\n              originalSize: estimatedSize,\n              finalSize: finalVoxelSize,\n              adjusted: true,\n              reason: `Performance limit exceeded: ${tempGrid.totalVoxels} > ${PERFORMANCE_LIMITS.maxVoxels}`\n            };\n            Logger.info(`Auto-adjusted voxelSize: ${estimatedSize}m → ${finalVoxelSize}m (${tempGrid.totalVoxels} voxels)`);\n          } else {\n            finalVoxelSize = estimatedSize;\n            autoAdjustmentInfo = {\n              enabled: true,\n              originalSize: estimatedSize,\n              finalSize: finalVoxelSize,\n              adjusted: false,\n              reason: null\n            };\n            Logger.info(`Auto-determined voxelSize: ${finalVoxelSize}m`);\n          }\n        } catch (error) {\n          Logger.warn('Auto voxel size adjustment failed, using default:', error);\n          finalVoxelSize = DEFAULT_OPTIONS.voxelSize;\n          autoAdjustmentInfo = {\n            enabled: true,\n            adjusted: false,\n            reason: 'Estimation failed, using default size',\n            originalSize: null,\n            finalSize: finalVoxelSize\n          };\n        }\n      }\n\n      // 2. グリッド生成（最終的なボクセルサイズを使用）\n      Logger.debug('Step 2: グリッド生成 (サイズ:', finalVoxelSize, 'm)');\n      this._grid = VoxelGrid.createGrid(this._bounds, finalVoxelSize);\n      Logger.debug('グリッド生成完了:', this._grid);\n      \n      // 3. エンティティ分類\n      Logger.debug('Step 3: エンティティ分類');\n      this._voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, this._bounds, this._grid);\n      Logger.debug('エンティティ分類完了:', this._voxelData.size, '個のボクセル');\n      \n      // 4. 統計計算\n      Logger.debug('Step 4: 統計計算');\n      this._statistics = DataProcessor.calculateStatistics(this._voxelData, this._grid);\n      Logger.debug('統計情報:', this._statistics);\n      \n      // 統計情報に自動調整情報を追加\n      if (autoAdjustmentInfo) {\n        this._statistics.autoAdjusted = autoAdjustmentInfo.adjusted;\n        this._statistics.originalVoxelSize = autoAdjustmentInfo.originalSize;\n        this._statistics.finalVoxelSize = autoAdjustmentInfo.finalSize;\n        this._statistics.adjustmentReason = autoAdjustmentInfo.reason;\n      }\n      \n      // 5. 描画\n      Logger.debug('Step 5: 描画');\n      const renderedVoxelCount = this.renderer.render(this._voxelData, this._bounds, this._grid, this._statistics);\n      \n      // 統計情報に実際の描画数を反映\n      this._statistics.renderedVoxels = renderedVoxelCount;\n      Logger.info('描画完了 - 実際の描画数:', renderedVoxelCount);\n      \n      Logger.debug('Heatbox.setData - 処理完了');\n      \n    } catch (error) {\n      Logger.error('ヒートマップ作成エラー:', error);\n      this.clear();\n      throw error;\n    }\n  }\n\n  /**\n   * エンティティからヒートマップを作成（非同期API）\n   * @param {Cesium.Entity[]} entities - 対象エンティティ配列\n   * @returns {Promise<Object>} 統計情報\n   */\n  async createFromEntities(entities) {\n    if (!isValidEntities(entities)) {\n      throw new Error(ERROR_MESSAGES.NO_ENTITIES);\n    }\n    this.setData(entities);\n    return this.getStatistics();\n  }\n\n  /**\n   * 表示/非表示を切り替え\n   * @param {boolean} show - 表示する場合はtrue\n   */\n  setVisible(show) {\n    this.renderer.setVisible(show);\n  }\n\n  /**\n   * ヒートマップをクリア\n   */\n  clear() {\n    this.renderer.clear();\n    this._bounds = null;\n    this._grid = null;\n    this._voxelData = null;\n    this._statistics = null;\n  }\n\n  /**\n   * インスタンスを破棄し、イベントリスナーを解放\n   */\n  destroy() {\n    this.clear();\n    if (this._eventHandler && !this._eventHandler.isDestroyed()) {\n      this._eventHandler.destroy();\n    }\n    this._eventHandler = null;\n  }\n\n  /**\n   * 現在のオプションを取得\n   * @returns {Object} オプション\n   */\n  getOptions() {\n    return { ...this.options };\n  }\n\n  /**\n   * オプションを更新\n   * @param {Object} newOptions - 新しいオプション\n   */\n  updateOptions(newOptions) {\n    this.options = validateAndNormalizeOptions({ ...this.options, ...newOptions });\n    this.renderer.options = this.options;\n    \n    // 既存のヒートマップがある場合は再描画\n    if (this._voxelData) {\n      const renderedVoxelCount = this.renderer.render(this._voxelData, this._bounds, this._grid, this._statistics);\n      // 統計情報を更新\n      this._statistics.renderedVoxels = renderedVoxelCount;\n    }\n  }\n\n  /**\n   * 内部のイベントリスナーを初期化\n   * @private\n   */\n  _initializeEventListeners() {\n    this._eventHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n\n    // クリックイベントでInfoBoxを更新\n    this._eventHandler.setInputAction(movement => {\n      const pickedObject = this.viewer.scene.pick(movement.position);\n      if (Cesium.defined(pickedObject) && pickedObject.id && \n          pickedObject.id.properties && \n          pickedObject.id.properties.type === 'voxel') {\n        // プロパティからキー値を取得\n        const voxelKey = pickedObject.id.properties.key;\n        const voxelInfo = {\n          x: pickedObject.id.properties.x,\n          y: pickedObject.id.properties.y,\n          z: pickedObject.id.properties.z,\n          count: pickedObject.id.properties.count\n        };\n        \n        // InfoBoxに表示するためのダミーエンティティを作成\n        const dummyEntity = new Cesium.Entity({\n          id: `voxel-${voxelKey}`,\n          description: this.renderer.createVoxelDescription(voxelInfo, voxelKey)\n        });\n        this.viewer.selectedEntity = dummyEntity;\n      }\n    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n  }\n\n  /**\n   * 統計情報を取得\n   * @returns {Object|null} 統計情報、未作成の場合はnull\n   */\n  getStatistics() {\n    return this._statistics;\n  }\n\n  /**\n   * 境界情報を取得\n   * @returns {Object|null} 境界情報、未作成の場合はnull\n   */\n  getBounds() {\n    return this._bounds;\n  }\n\n  /**\n   * デバッグ情報を取得\n   * @returns {Object} デバッグ情報\n   */\n  getDebugInfo() {\n    const baseInfo = {\n      options: { ...this.options },\n      bounds: this._bounds,\n      grid: this._grid,\n      statistics: this._statistics\n    };\n    \n    // v0.1.4: 自動調整情報を追加\n    if (this.options.autoVoxelSize) {\n      baseInfo.autoVoxelSizeInfo = {\n        enabled: this.options.autoVoxelSize,\n        originalSize: this._statistics?.originalVoxelSize,\n        finalSize: this._statistics?.finalVoxelSize,\n        adjusted: this._statistics?.autoAdjusted || false,\n        reason: this._statistics?.adjustmentReason,\n        dataRange: this._bounds ? calculateDataRange(this._bounds) : null,\n        estimatedDensity: this._bounds && this._statistics ? \n          this._statistics.totalEntities / (calculateDataRange(this._bounds).x * calculateDataRange(this._bounds).y * calculateDataRange(this._bounds).z) : null\n      };\n    }\n    \n    return baseInfo;\n  }\n\n  /**\n   * エンティティ配列をフィルタ（ユーティリティ, 静的メソッド）\n   * @param {Cesium.Entity[]} entities - エンティティ配列\n   * @param {Function} predicate - フィルタ関数\n   * @returns {Cesium.Entity[]} フィルタ済み配列\n   */\n  static filterEntities(entities, predicate) {\n    if (!Array.isArray(entities) || typeof predicate !== 'function') return [];\n    return entities.filter(predicate);\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__50__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","DEFAULT_OPTIONS","voxelSize","opacity","emptyOpacity","showOutline","showEmptyVoxels","minColor","maxColor","maxRenderVoxels","batchMode","debug","autoVoxelSize","colorMap","diverging","divergingPivot","highlightTopN","highlightStyle","outlineWidth","boostOpacity","voxelGap","outlineOpacity","outlineWidthResolver","outlineEmulation","outlineInset","outlineInsetMode","enableThickFrames","outlineRenderMode","adaptiveOutlines","outlineWidthPreset","boxOpacityResolver","outlineOpacityResolver","adaptiveParams","neighborhoodRadius","densityThreshold","cameraDistanceFactor","overlapRiskFactor","PERFORMANCE_LIMITS","ERROR_MESSAGES","Math","PI","currentLogLevel","process","env","DEBUG","Logger","error","args","console","warn","info","log","setLogLevel","options","isValidEntities","entities","Array","isArray","length","validateAndNormalizeOptions","normalized","isNaN","Error","max","min","map","c","floor","includes","parseFloat","v","inset","Boolean","calculateDataRange","bounds","centerLat","minLat","maxLat","cosLat","cos","lonRangeMeters","maxLon","minLon","latRangeMeters","altRangeMeters","maxAlt","minAlt","x","y","z","CoordinateTransformer","calculateBounds","Infinity","validCount","currentTime","Cesium","now","forEach","entity","index","position","getValue","cartographic","fromCartesian","lon","toDegrees","longitude","lat","latitude","alt","height","centerLon","centerAlt","voxelIndexToCoordinate","grid","numVoxelsX","numVoxelsY","numVoxelsZ","coordinateToCartesian3","fromDegrees","VoxelGrid","createGrid","voxelSizeMeters","ceil","cellSizeX","cellSizeY","cellSizeZ","totalVoxels","getVoxelKey","parseVoxelKey","split","Number","iterateAllVoxels","callback","DataProcessor","classifyEntitiesIntoVoxels","voxelData","Map","processedCount","skippedCount","lonDen","latDen","altDen","voxelX","voxelY","voxelZ","voxelKey","has","set","count","voxelInfo","push","size","calculateStatistics","renderedVoxels","nonEmptyVoxels","emptyVoxels","totalEntities","minCount","maxCount","averageCount","autoAdjusted","originalVoxelSize","finalVoxelSize","adjustmentReason","counts","from","values","voxel","reduce","sum","stats","getTopNVoxels","topN","sortedVoxels","sort","a","b","slice","COLOR_MAPS","viridis","inferno","VoxelRenderer","constructor","viewer","wireframeOnly","heightBased","voxelEntities","_calculateAdaptiveParams","isTopN","statistics","boxOpacity","shouldUseEmulation","normalizedDensity","neighborhoodDensity","neighborCount","radius","dx","dy","dz","neighborKey","neighbor","isDenseArea","cameraFactor","overlapRisk","adaptiveWidth","adaptiveBoxOpacity","adaptiveOutlineOpacity","render","clear","voxelDataSize","_shouldShowBounds","_renderBoundingBox","displayVoxels","topNVoxels","Set","maxVoxels","entries","add","renderedCount","color","LIGHTGRAY","interpolateColor","resolverCtx","resolverOpacity","e","baseCellSizeZ","finalOutlineWidth","finalOutlineOpacity","boxHeight","resolverParams","outlineColorWithOpacity","withAlpha","shouldShowStandardOutline","shouldShowInsetOutline","shouldUseEmulationOnly","emulateThickForThis","entityConfig","box","dimensions","outline","outlineColor","properties","type","description","createVoxelDescription","material","TRANSPARENT","fill","_shouldApplyInsetOutline","insetAmount","_createInsetOutline","centerCart","maxInsetX","maxInsetY","maxInsetZ","baseInset","autoInsetX","autoInsetY","autoInsetZ","effInsetX","effInsetY","effInsetZ","midSizeX","midSizeY","midSizeZ","_addEdgePolylines","widthMeters","depthMeters","heightMeters","boundingBox","YELLOW","toFixed","center","width","depth","sx","sy","sz","halfX","halfY","halfZ","enu","eastNorthUpToFixedFrame","toWorld","local","multiplyByPoint","C","i","j","poly","polyline","positions","arcType","NONE","rawValue","_interpolateDivergingColor","_interpolateFromColorMap","minR","minG","minB","maxR","maxG","maxB","r","round","g","fromBytes","normalizedValue","colorMapName","scaledValue","lowerIndex","upperIndex","fraction","r1","g1","b1","r2","g2","b2","pivot","isDestroyed","remove","showBounds","baseSizeX","baseSizeY","baseSizeZ","effectiveInsetX","effectiveInsetY","effectiveInsetZ","insetSizeX","insetSizeY","insetSizeZ","insetEntity","parentKey","insetSize","_createThickOutlineFrames","originalSize","effectiveInset","outerX","outerY","outerZ","innerX","innerY","innerZ","frameColor","frameThickX","frameThickY","frameThickZ","outerBoundX","outerBoundY","outerBoundZ","innerBoundX","innerBoundY","innerBoundZ","frameThick","outerBound","innerBound","frames","pos","name","frame","DEG_PER_METER_LON","DEG_PER_METER_LAT","frameLon","frameLat","frameAlt","frameEntity","frameName","setVisible","show","scene","canvas","getContext","isValidViewer","renderer","_bounds","_grid","_voxelData","_statistics","_eventHandler","_initializeEventListeners","setData","autoAdjustmentInfo","estimatedSize","entityCount","dataRange","volume","density","sqrt","estimateInitialVoxelSize","tempGrid","validation","result","valid","warning","recommendedSize","pow","validateVoxelCount","enabled","finalSize","adjusted","reason","renderedVoxelCount","createFromEntities","getStatistics","destroy","getOptions","updateOptions","newOptions","setInputAction","movement","pickedObject","pick","id","dummyEntity","selectedEntity","LEFT_CLICK","getBounds","getDebugInfo","baseInfo","autoVoxelSizeInfo","estimatedDensity","filterEntities","predicate","filter"],"sourceRoot":""}