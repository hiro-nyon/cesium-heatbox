!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("cesium")):"function"==typeof define&&define.amd?define(["cesium"],e):"object"==typeof exports?exports.CesiumHeatbox=e(require("cesium")):t.CesiumHeatbox=e(t.Cesium)}(this,t=>(()=>{"use strict";var e={50:e=>{e.exports=t}},i={};function o(t){var n=i[t];if(void 0!==n)return n.exports;var s=i[t]={exports:{}};return e[t](s,s.exports,o),s.exports}o.d=(t,e)=>{for(var i in e)o.o(e,i)&&!o.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},o.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var n={};o.d(n,{default:()=>y});var s=o(50);const a={voxelSize:20,opacity:.8,emptyOpacity:.03,showOutline:!0,showEmptyVoxels:!1,minColor:[0,32,255],maxColor:[255,64,0],maxRenderVoxels:5e4,batchMode:"auto",debug:!1,autoVoxelSize:!1,colorMap:"custom",diverging:!1,divergingPivot:0,highlightTopN:null,highlightStyle:{outlineWidth:4,boostOpacity:.2},voxelGap:0,outlineOpacity:1,outlineWidthResolver:null,outlineEmulation:"off",outlineInset:0,outlineInsetMode:"all",enableThickFrames:!1,outlineRenderMode:"standard",adaptiveOutlines:!1,outlineWidthPreset:"uniform",boxOpacityResolver:null,outlineOpacityResolver:null,adaptiveParams:{neighborhoodRadius:50,densityThreshold:5,cameraDistanceFactor:1,overlapRiskFactor:.3}},l=5e4,r=(Math.PI,"対象エンティティがありません");let h="undefined"!=typeof process&&process.env&&"true"===process.env.DEBUG?3:"undefined"!=typeof process&&process.env?1:3;const u={error(...t){h>=0&&console.error("[Heatbox ERROR]",...t)},warn(...t){h>=1&&console.warn("[Heatbox WARN]",...t)},info(...t){h>=2&&console.log("[Heatbox INFO]",...t)},debug(...t){h>=3&&console.log("[Heatbox DEBUG]",...t)},setLogLevel:t=>(t&&void 0!==t.debug&&("boolean"==typeof t.debug?h=t.debug?3:1:"object"==typeof t.debug&&null!==t.debug&&(h=3)),h)};function d(t){return!!Array.isArray(t)&&0!==t.length&&(t.length>5e3&&u.warn(`エンティティ数が推奨値(5000)を超えています: ${t.length}`),!0)}function c(t={}){const e={...t};if(e.batchMode&&e.debug&&u.warn("batchMode option is deprecated and will be removed in v1.0.0. It is currently ignored."),void 0!==e.voxelSize&&("number"!=typeof(i=e.voxelSize)||isNaN(i)||i<5||i>1e3))throw new Error(`ボクセルサイズが無効です: ${e.voxelSize}`);var i;if(void 0!==e.opacity&&(e.opacity=Math.max(0,Math.min(1,e.opacity))),void 0!==e.emptyOpacity&&(e.emptyOpacity=Math.max(0,Math.min(1,e.emptyOpacity))),e.minColor&&Array.isArray(e.minColor)&&3===e.minColor.length&&(e.minColor=e.minColor.map(t=>Math.max(0,Math.min(255,Math.floor(t))))),e.maxColor&&Array.isArray(e.maxColor)&&3===e.maxColor.length&&(e.maxColor=e.maxColor.map(t=>Math.max(0,Math.min(255,Math.floor(t))))),void 0!==e.colorMap&&(["custom","viridis","inferno"].includes(e.colorMap)||(u.warn(`Invalid colorMap: ${e.colorMap}. Using 'custom'.`),e.colorMap="custom")),void 0!==e.highlightTopN&&null!==e.highlightTopN&&("number"!=typeof e.highlightTopN||e.highlightTopN<=0)&&(u.warn(`Invalid highlightTopN: ${e.highlightTopN}. Must be a positive number.`),e.highlightTopN=null),void 0!==e.voxelGap&&(e.voxelGap=Math.max(0,Math.min(100,parseFloat(e.voxelGap)||0))),void 0!==e.outlineOpacity&&(e.outlineOpacity=Math.max(0,Math.min(1,parseFloat(e.outlineOpacity)||1))),void 0!==e.outlineWidthResolver&&null!==e.outlineWidthResolver&&"function"!=typeof e.outlineWidthResolver&&(u.warn("outlineWidthResolver must be a function. Ignoring."),e.outlineWidthResolver=null),void 0!==e.outlineEmulation&&(["off","topn","non-topn","all"].includes(e.outlineEmulation)||(u.warn(`Invalid outlineEmulation: ${e.outlineEmulation}. Using 'off'.`),e.outlineEmulation="off")),void 0!==e.outlineInset){const t=parseFloat(e.outlineInset);e.outlineInset=isNaN(t)||t<0?0:t}if(void 0!==e.outlineInsetMode&&(["all","topn"].includes(e.outlineInsetMode)||(u.warn(`Invalid outlineInsetMode: ${e.outlineInsetMode}. Using 'all'.`),e.outlineInsetMode="all")),void 0!==e.outlineInset){const t=parseFloat(e.outlineInset);e.outlineInset=Math.max(0,Math.min(100,isNaN(t)?0:t))}return void 0!==e.outlineInsetMode&&(["all","topn"].includes(e.outlineInsetMode)||(u.warn(`Invalid outlineInsetMode: ${e.outlineInsetMode}. Using 'all'.`),e.outlineInsetMode="all")),void 0!==e.enableThickFrames&&(e.enableThickFrames=Boolean(e.enableThickFrames)),e}function p(t){try{const e=(t.minLat+t.maxLat)/2,i=Math.cos(e*Math.PI/180),o=111e3*(t.maxLon-t.minLon)*i,n=111e3*(t.maxLat-t.minLat),s=Math.max(t.maxAlt-t.minAlt,1);return{x:Math.max(o,1),y:Math.max(n,1),z:s}}catch(t){return u.warn("Data range calculation failed:",t),{x:1e3,y:1e3,z:100}}}u.debug,u.warn,u.error,u.info;class m{static calculateBounds(t){if(!Array.isArray(t)||0===t.length)throw new Error("エンティティが提供されていません");let e=1/0,i=-1/0,o=1/0,n=-1/0,a=1/0,l=-1/0,r=0;const h=s.JulianDate.now();if(t.forEach((t,d)=>{try{let u;if(t.position&&(u="function"==typeof t.position.getValue?t.position.getValue(h):t.position),!u)return;const d=s.Cartographic.fromCartesian(u);if(!d)return;const c=s.Math.toDegrees(d.longitude),p=s.Math.toDegrees(d.latitude),m=d.height;e=Math.min(e,c),i=Math.max(i,c),o=Math.min(o,p),n=Math.max(n,p),a=Math.min(a,m),l=Math.max(l,m),r++}catch(t){u.warn(`エンティティ ${d} の処理に失敗:`,t)}}),0===r)throw new Error("有効な位置情報を持つエンティティが見つかりません");return u.debug("座標範囲計算完了:",{validCount:r,bounds:{minLon:e,maxLon:i,minLat:o,maxLat:n,minAlt:a,maxAlt:l}}),{minLon:e,maxLon:i,minLat:o,maxLat:n,minAlt:a,maxAlt:l,centerLon:(e+i)/2,centerLat:(o+n)/2,centerAlt:(a+l)/2}}static voxelIndexToCoordinate(t,e,i,o,n){const{minLon:s,maxLon:a,minLat:l,maxLat:r,minAlt:h,maxAlt:u}=o,{numVoxelsX:d,numVoxelsY:c,numVoxelsZ:p}=n;return{lon:s+(t+.5)/d*(a-s),lat:l+(e+.5)/c*(r-l),alt:h+(i+.5)/p*(u-h)}}static coordinateToCartesian3(t,e,i){return s.Cartesian3.fromDegrees(t,e,i)}}class x{static createGrid(t,e){const i=(t.minLat+t.maxLat)/2,o=111e3*(t.maxLon-t.minLon)*Math.cos(i*Math.PI/180),n=111e3*(t.maxLat-t.minLat),s=t.maxAlt-t.minAlt,a=Math.max(1,Math.ceil(o/e)),l=Math.max(1,Math.ceil(n/e)),r=Math.max(1,Math.ceil(s/e)),h=a>0?o/a:e,d=l>0?n/l:e,c=r>0?Math.max(s/r,1):Math.max(e,1),p=a*l*r;return u.debug("VoxelGrid created:",{numVoxelsX:a,numVoxelsY:l,numVoxelsZ:r,totalVoxels:p,voxelSizeMeters:e,cellSizeX:h,cellSizeY:d,cellSizeZ:c,lonRangeMeters:o,latRangeMeters:n,altRangeMeters:s}),{numVoxelsX:a,numVoxelsY:l,numVoxelsZ:r,totalVoxels:p,voxelSizeMeters:e,cellSizeX:h,cellSizeY:d,cellSizeZ:c,lonRangeMeters:o,latRangeMeters:n,altRangeMeters:s}}static getVoxelKey(t,e,i){return`${t},${e},${i}`}static parseVoxelKey(t){const[e,i,o]=t.split(",").map(Number);return{x:e,y:i,z:o}}static iterateAllVoxels(t,e){const{numVoxelsX:i,numVoxelsY:o,numVoxelsZ:n}=t;for(let t=0;t<i;t++)for(let i=0;i<o;i++)for(let o=0;o<n;o++)e(t,i,o,this.getVoxelKey(t,i,o))}}class g{static classifyEntitiesIntoVoxels(t,e,i){const o=new Map;let n=0,a=0;u.debug(`Processing ${t.length} entities for classification`);const l=s.JulianDate.now();return t.forEach((t,r)=>{try{let r;if(t.position&&(r="function"==typeof t.position.getValue?t.position.getValue(l):t.position),!r)return void a++;const h=s.Cartographic.fromCartesian(r);if(!h)return void a++;const u=s.Math.toDegrees(h.longitude),d=s.Math.toDegrees(h.latitude),c=h.height;if(u<e.minLon-.001||u>e.maxLon+.001||d<e.minLat-.001||d>e.maxLat+.001||c<e.minAlt-1||c>e.maxAlt+1)return void a++;const p=e.maxLon-e.minLon,m=e.maxLat-e.minLat,g=e.maxAlt-e.minAlt,f=0===p?0:Math.floor((u-e.minLon)/p*i.numVoxelsX),v=0===m?0:Math.floor((d-e.minLat)/m*i.numVoxelsY),y=0===g?0:Math.floor((c-e.minAlt)/g*i.numVoxelsZ);if(f>=0&&f<i.numVoxelsX&&v>=0&&v<i.numVoxelsY&&y>=0&&y<i.numVoxelsZ){const e=x.getVoxelKey(f,v,y);o.has(e)||o.set(e,{x:f,y:v,z:y,entities:[],count:0});const i=o.get(e);i.entities.push(t),i.count++,n++}else a++}catch(t){u.warn(`エンティティ ${r} の処理に失敗:`,t),a++}}),u.info(`${n}個のエンティティを${o.size}個のボクセルに分類（${a}個はスキップ）`),o}static calculateStatistics(t,e){if(0===t.size)return{totalVoxels:e.totalVoxels,renderedVoxels:0,nonEmptyVoxels:0,emptyVoxels:e.totalVoxels,totalEntities:0,minCount:0,maxCount:0,averageCount:0,autoAdjusted:!1,originalVoxelSize:null,finalVoxelSize:null,adjustmentReason:null};const i=Array.from(t.values()).map(t=>t.count),o=i.reduce((t,e)=>t+e,0),n={totalVoxels:e.totalVoxels,renderedVoxels:0,nonEmptyVoxels:t.size,emptyVoxels:e.totalVoxels-t.size,totalEntities:o,minCount:Math.min(...i),maxCount:Math.max(...i),averageCount:o/t.size,autoAdjusted:!1,originalVoxelSize:null,finalVoxelSize:null,adjustmentReason:null};return u.debug("統計情報計算完了:",n),n}static getTopNVoxels(t,e){if(0===t.size||e<=0)return[];const i=Array.from(t.values()).sort((t,e)=>e.count-t.count);return i.slice(0,Math.min(e,i.length))}}const f={viridis:[[68,1,84],[71,44,122],[59,81,139],[44,113,142],[33,144,141],[39,173,129],[92,200,99],[170,220,50],[253,231,37],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255]],inferno:[[0,0,4],[31,12,72],[85,15,109],[136,34,106],[186,54,85],[227,89,51],[249,142,8],[252,187,17],[245,219,76],[252,255,164],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255]],diverging:[[0,0,255],[32,64,255],[64,128,255],[96,160,255],[128,192,255],[160,224,255],[192,240,255],[224,248,255],[255,255,255],[255,248,224],[255,240,192],[255,224,160],[255,192,128],[255,160,96],[255,128,64],[255,64,32],[255,0,0]]};class v{constructor(t,e={}){this.viewer=t,this.options={minColor:[0,0,255],maxColor:[255,0,0],opacity:.8,emptyOpacity:.03,showOutline:!0,showEmptyVoxels:!1,wireframeOnly:!1,heightBased:!1,outlineWidth:2,outlineInset:0,outlineInsetMode:"all",outlineRenderMode:"standard",adaptiveOutlines:!1,outlineWidthPreset:"uniform",boxOpacityResolver:null,outlineOpacityResolver:null,adaptiveParams:{neighborhoodRadius:50,densityThreshold:5,cameraDistanceFactor:1,overlapRiskFactor:.3},...e},this.voxelEntities=[],u.debug("VoxelRenderer initialized with options:",this.options)}_calculateAdaptiveParams(t,e,i,o){if(!this.options.adaptiveOutlines)return{outlineWidth:null,boxOpacity:null,outlineOpacity:null,shouldUseEmulation:!1};const{x:n,y:s,z:a,count:l}=t,r=o.maxCount>o.minCount?(l-o.minCount)/(o.maxCount-o.minCount):0;let h=0,u=0;const d=Math.max(1,Math.floor(this.options.adaptiveParams.neighborhoodRadius/20));for(let t=-d;t<=d;t++)for(let e=-d;e<=d;e++)for(let o=-d;o<=d;o++){if(0===t&&0===e&&0===o)continue;const l=`${n+t},${s+e},${a+o}`,r=i.get(l);r&&(h+=r.count,u++)}const c=(u>0?h/u:0)>this.options.adaptiveParams.densityThreshold,p=Math.min(1,1)*this.options.adaptiveParams.cameraDistanceFactor,m=c?this.options.adaptiveParams.overlapRiskFactor:0;let x,g,f;switch(this.options.outlineWidthPreset){case"adaptive-density":x=c?Math.max(.5,this.options.outlineWidth*(.5+.5*r)):this.options.outlineWidth,g=c?.8*this.options.opacity:this.options.opacity,f=c?.6:1;break;case"topn-focus":x=e?this.options.outlineWidth*(1.5+.5*r):Math.max(.5,.7*this.options.outlineWidth),g=e?this.options.opacity:.6*this.options.opacity,f=e?1:.4;break;default:x=this.options.outlineWidth,g=this.options.opacity,f=this.options.outlineOpacity||1}return x*=p,f=Math.max(.2,f*(1-m)),{outlineWidth:Math.max(.5,x),boxOpacity:Math.max(.1,Math.min(1,g)),outlineOpacity:Math.max(.2,Math.min(1,f)),shouldUseEmulation:c||x>2&&"standard"!==this.options.outlineRenderMode}}render(t,e,i,o){this.clear(),u.debug("VoxelRenderer.render - Starting render with simplified approach",{voxelDataSize:t.size,bounds:e,grid:i,statistics:o}),this._shouldShowBounds()&&this._renderBoundingBox(e);let n=[];const a=new Set;if(this.options.showEmptyVoxels){const e=Math.min(i.totalVoxels,this.options.maxRenderVoxels||1e4);u.debug(`Generating grid for up to ${e} voxels`);for(let o=0;o<i.numVoxelsX;o++){for(let s=0;s<i.numVoxelsY;s++){for(let a=0;a<i.numVoxelsZ;a++){const i=`${o},${s},${a}`,l=t.get(i)||{x:o,y:s,z:a,count:0};if(n.push({key:i,info:l}),n.length>=e){u.debug(`Reached maximum voxel limit of ${e}`);break}}if(n.length>=e)break}if(n.length>=e)break}}else n=Array.from(t.entries()).map(([t,e])=>({key:t,info:e})),this.options.maxRenderVoxels&&n.length>this.options.maxRenderVoxels&&(n.sort((t,e)=>e.info.count-t.info.count),n=n.slice(0,this.options.maxRenderVoxels),u.debug(`Limited to ${n.length} highest density voxels`));this.options.highlightTopN&&this.options.highlightTopN>0&&([...n].sort((t,e)=>e.info.count-t.info.count).slice(0,this.options.highlightTopN).forEach(t=>a.add(t.key)),u.debug(`TopN highlight enabled: ${a.size} voxels will be highlighted`)),u.debug(`Rendering ${n.length} voxels`);let l=0;return n.forEach(({key:n,info:r})=>{try{const{x:h,y:d,z:c}=r,p=e.minLon+(h+.5)*(e.maxLon-e.minLon)/i.numVoxelsX,m=e.minLat+(d+.5)*(e.maxLat-e.minLat)/i.numVoxelsY,x=e.minAlt+(c+.5)*(e.maxAlt-e.minAlt)/i.numVoxelsZ,g=a.has(n),f=this._calculateAdaptiveParams(r,g,t,o);let v,y;if(0===r.count)v=s.Color.LIGHTGRAY,y=this.options.emptyOpacity;else{const t=o.maxCount>o.minCount?(r.count-o.minCount)/(o.maxCount-o.minCount):0;if(v=this.interpolateColor(t,r.count),this.options.boxOpacityResolver&&"function"==typeof this.options.boxOpacityResolver){const e={voxel:{x:h,y:d,z:c,count:r.count},isTopN:g,normalizedDensity:t,statistics:o,adaptiveParams:f};try{const t=this.options.boxOpacityResolver(e);y=isNaN(t)?this.options.opacity:Math.max(0,Math.min(1,t))}catch(t){u.warn("boxOpacityResolver error, using fallback:",t),y=f.boxOpacity||this.options.opacity}}else y=f.boxOpacity||this.options.opacity;!this.options.highlightTopN||g||this.options.boxOpacityResolver||(y*=1-(this.options.highlightStyle?.boostOpacity||.2))}let b=i.cellSizeX||(i.lonRangeMeters?i.lonRangeMeters/i.numVoxelsX:i.voxelSizeMeters),M=i.cellSizeY||(i.latRangeMeters?i.latRangeMeters/i.numVoxelsY:i.voxelSizeMeters),z=i.cellSizeZ||(i.altRangeMeters?Math.max(i.altRangeMeters/Math.max(i.numVoxelsZ,1),1):Math.max(i.voxelSizeMeters,1));this.options.voxelGap>0&&(b=Math.max(b-this.options.voxelGap,.1*b),M=Math.max(M-this.options.voxelGap,.1*M),z=Math.max(z-this.options.voxelGap,.1*z));let w,V,C=z;if(this.options.heightBased&&r.count>0&&(C=z*(.1+.9*(o.maxCount>o.minCount?(r.count-o.minCount)/(o.maxCount-o.minCount):0))),this.options.outlineWidthResolver&&"function"==typeof this.options.outlineWidthResolver){const t=o.maxCount>o.minCount?(r.count-o.minCount)/(o.maxCount-o.minCount):0,e={voxel:{x:h,y:d,z:c,count:r.count},isTopN:g,normalizedDensity:t,statistics:o,adaptiveParams:f};try{w=this.options.outlineWidthResolver(e),isNaN(w)&&(w=f.outlineWidth||this.options.outlineWidth)}catch(t){u.warn("outlineWidthResolver error, using fallback:",t),w=f.outlineWidth||this.options.outlineWidth}}else w=this.options.adaptiveOutlines&&null!==f.outlineWidth?f.outlineWidth:g&&this.options.highlightTopN&&this.options.highlightStyle?.outlineWidth||this.options.outlineWidth;if(this.options.outlineOpacityResolver&&"function"==typeof this.options.outlineOpacityResolver){const t=o.maxCount>o.minCount?(r.count-o.minCount)/(o.maxCount-o.minCount):0,e={voxel:{x:h,y:d,z:c,count:r.count},isTopN:g,normalizedDensity:t,statistics:o,adaptiveParams:f};try{const t=this.options.outlineOpacityResolver(e);V=isNaN(t)?this.options.outlineOpacity??1:Math.max(0,Math.min(1,t))}catch(t){u.warn("outlineOpacityResolver error, using fallback:",t),V=f.outlineOpacity||(this.options.outlineOpacity??1)}}else V=f.outlineOpacity||(this.options.outlineOpacity??1);const _=v.withAlpha(V);let S=!0,E=!1,R=!1;switch(this.options.outlineRenderMode){case"standard":S=this.options.showOutline,E=this.options.outlineInset>0;break;case"inset":S=!1,E=!0;break;case"emulation-only":S=!1,E=!1,R=!0}let L=R;R||("topn"===this.options.outlineEmulation?L=g&&(w||1)>1:"non-topn"===this.options.outlineEmulation?L=!g&&(w||1)>1:"all"===this.options.outlineEmulation?L=(w||1)>1:this.options.adaptiveOutlines&&f.shouldUseEmulation&&(L=!0));const O={position:s.Cartesian3.fromDegrees(p,m,x),box:{dimensions:new s.Cartesian3(b,M,C),outline:S&&!L,outlineColor:_,outlineWidth:Math.max(w||1,0)},properties:{type:"voxel",key:n,count:r.count,x:h,y:d,z:c},description:this.createVoxelDescription(r,n)};this.options.wireframeOnly?(O.box.material=s.Color.TRANSPARENT,O.box.fill=!1):(O.box.material=v.withAlpha(y),O.box.fill=!0);const A=this.viewer.entities.add(O);if(this.voxelEntities.push(A),E&&this._shouldApplyInsetOutline(g))try{const t=this.options.outlineInset>0?this.options.outlineInset:1;this._createInsetOutline(p,m,x,b,M,C,_,Math.max(w||1,1),n,t)}catch(t){u.warn("Failed to create inset outline:",t)}if(L)try{const t=A.position.getValue(s.JulianDate.now()),e=.2*b,i=.2*M,o=.2*C,n=this.options.outlineInset&&this.options.outlineInset>0?this.options.outlineInset:0,a=.05*b,l=.05*M,r=.05*C,h=Math.min(n>0?n:a,e),u=Math.min(n>0?n:l,i),d=Math.min(n>0?n:r,o),c=Math.max(b-h,.1*b),p=Math.max(M-u,.1*M),m=Math.max(C-d,.1*C);this._addEdgePolylines(t,c,p,m,_,Math.max(w,1))}catch(t){u.warn("Failed to add emulated thick outline polylines:",t)}l++}catch(t){u.warn("Error rendering voxel:",t)}}),u.info(`Successfully rendered ${l} voxels`),l}_renderBoundingBox(t){if(t)try{const e=(t.minLon+t.maxLon)/2,i=(t.minLat+t.maxLat)/2,o=(t.minAlt+t.maxAlt)/2,n=111e3*(t.maxLon-t.minLon)*Math.cos(i*Math.PI/180),a=111e3*(t.maxLat-t.minLat),l=t.maxAlt-t.minAlt,r=this.viewer.entities.add({position:s.Cartesian3.fromDegrees(e,i,o),box:{dimensions:new s.Cartesian3(n,a,l),material:s.Color.YELLOW.withAlpha(.1),outline:!0,outlineColor:s.Color.YELLOW.withAlpha(.3),outlineWidth:2},description:`バウンディングボックス<br>サイズ: ${n.toFixed(1)} x ${a.toFixed(1)} x ${l.toFixed(1)} m`});this.voxelEntities.push(r),u.debug("Debug bounding box added:",{center:{lon:e,lat:i,alt:o},size:{width:n,depth:a,height:l}})}catch(t){u.warn("Failed to render bounding box:",t)}}_addEdgePolylines(t,e,i,o,n,a){try{const l=e/2,r=i/2,h=o/2,u=s.Transforms.eastNorthUpToFixedFrame(t),d=(t,e,i)=>{const o=new s.Cartesian3(t,e,i);return s.Matrix4.multiplyByPoint(u,o,new s.Cartesian3)},c=[d(-l,-r,-h),d(l,-r,-h),d(l,r,-h),d(-l,r,-h),d(-l,-r,h),d(l,-r,h),d(l,r,h),d(-l,r,h)];[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]].forEach(([t,e])=>{const i=this.viewer.entities.add({polyline:{positions:[c[t],c[e]],width:a,material:n,arcType:s.ArcType.NONE}});this.voxelEntities.push(i)})}catch(t){u.warn("Edge polyline creation failed:",t)}}interpolateColor(t,e=null){if(this.options.diverging&&null!==e&&("number"==typeof this.options.divergingPivot?this.options.divergingPivot:0)>0)return this._interpolateDivergingColor(e);if(this.options.colorMap&&"custom"!==this.options.colorMap)return this._interpolateFromColorMap(t,this.options.colorMap);const[i,o,n]=this.options.minColor,[a,l,r]=this.options.maxColor,h=Math.round(i+(a-i)*t),u=Math.round(o+(l-o)*t),d=Math.round(n+(r-n)*t);return s.Color.fromBytes(h,u,d)}_interpolateFromColorMap(t,e){const i=f[e];if(!i)return u.warn(`Unknown color map: ${e}. Falling back to custom.`),this.interpolateColor(t);const o=t*(i.length-1),n=Math.floor(o),a=Math.min(n+1,i.length-1),l=o-n,[r,h,d]=i[n],[c,p,m]=i[a],x=Math.round(r+(c-r)*l),g=Math.round(h+(p-h)*l),v=Math.round(d+(m-d)*l);return s.Color.fromBytes(x,g,v)}_interpolateDivergingColor(t){const e=this.options.divergingPivot||0;let i;return t<=e?(i=t/e*.5,i=Math.max(0,Math.min(.5,i))):(i=.5+(t-e)/e*.5,i=Math.max(.5,Math.min(1,i))),this._interpolateFromColorMap(i,"diverging")}createVoxelDescription(t,e){return`\n      <div style="padding: 10px; font-family: Arial, sans-serif;">\n        <h3 style="margin-top: 0;">ボクセル [${t.x}, ${t.y}, ${t.z}]</h3>\n        <table style="width: 100%;">\n          <tr><td><b>エンティティ数:</b></td><td>${t.count}</td></tr>\n          <tr><td><b>ID:</b></td><td>${e}</td></tr>\n        </table>\n      </div>\n    `}clear(){u.debug("VoxelRenderer.clear - Removing",this.voxelEntities.length,"entities"),this.voxelEntities.forEach(t=>{try{const e="function"==typeof t.isDestroyed&&t.isDestroyed();t&&!e&&this.viewer.entities.remove(t)}catch(t){u.warn("Entity removal error:",t)}}),this.voxelEntities=[]}_shouldShowBounds(){return!!this.options.debug&&("boolean"==typeof this.options.debug?this.options.debug:"object"==typeof this.options.debug&&null!==this.options.debug&&!0===this.options.debug.showBounds)}_shouldApplyInsetOutline(t){return"topn"!==(this.options.outlineInsetMode||"all")||t}_createInsetOutline(t,e,i,o,n,a,l,r,h,d=null){const c=.2*o,p=.2*n,m=.2*a,x=null!==d?d:this.options.outlineInset,g=Math.min(x,c),f=Math.min(x,p),v=Math.min(x,m),y=Math.max(o-2*g,.1*o),b=Math.max(n-2*f,.1*n),M=Math.max(a-2*v,.1*a),z=this.viewer.entities.add({position:s.Cartesian3.fromDegrees(t,e,i),box:{dimensions:new s.Cartesian3(y,b,M),fill:!1,outline:!0,outlineColor:l,outlineWidth:Math.max(r||1,0)},properties:{type:"voxel-inset-outline",parentKey:h,insetSize:{x:y,y:b,z:M}}});this.voxelEntities.push(z),this.options.enableThickFrames&&(g>.1||f>.1||v>.1)&&this._createThickOutlineFrames(t,e,i,o,n,a,y,b,M,l,h),u.debug(`Inset outline created for voxel ${h}:`,{originalSize:{x:o,y:n,z:a},insetSize:{x:y,y:b,z:M},effectiveInset:{x:g,y:f,z:v}})}_createThickOutlineFrames(t,e,i,o,n,a,l,r,h,d,c){const p=(o-l)/2,m=(n-r)/2,x=(a-h)/2,g=o/2,f=n/2,v=a/2,y=l/2,b=r/2,M=h/2;u.debug(`Frame bounds for ${c}:`,{frameThick:{x:p,y:m,z:x},outerBound:{x:g,y:f,z:v},innerBound:{x:y,y:b,z:M}});const z=[{pos:[0,(f+b)/2,v-x/2],size:[l,m,x],name:"top-back"},{pos:[0,-(f+b)/2,v-x/2],size:[l,m,x],name:"top-front"},{pos:[(g+y)/2,0,v-x/2],size:[p,n,x],name:"top-right"},{pos:[-(g+y)/2,0,v-x/2],size:[p,n,x],name:"top-left"},{pos:[0,(f+b)/2,x/2-v],size:[l,m,x],name:"bottom-back"},{pos:[0,-(f+b)/2,x/2-v],size:[l,m,x],name:"bottom-front"},{pos:[(g+y)/2,0,x/2-v],size:[p,n,x],name:"bottom-right"},{pos:[-(g+y)/2,0,x/2-v],size:[p,n,x],name:"bottom-left"},{pos:[(g+y)/2,(f+b)/2,0],size:[p,m,h],name:"vertical-back-right"},{pos:[(g+y)/2,-(f+b)/2,0],size:[p,m,h],name:"vertical-front-right"},{pos:[-(g+y)/2,(f+b)/2,0],size:[p,m,h],name:"vertical-back-left"},{pos:[-(g+y)/2,-(f+b)/2,0],size:[p,m,h],name:"vertical-front-left"}];z.forEach(o=>{if(o.size[0]>.1&&o.size[1]>.1&&o.size[2]>.1)try{const n=1/(111e3*Math.cos(e*Math.PI/180)),a=1/111e3,l=t+o.pos[0]*n,r=e+o.pos[1]*a,h=i+o.pos[2],u=this.viewer.entities.add({position:s.Cartesian3.fromDegrees(l,r,h),box:{dimensions:new s.Cartesian3(o.size[0],o.size[1],o.size[2]),material:d.withAlpha(.8),outline:!1,fill:!0},properties:{type:"voxel-outline-frame",parentKey:c,frameName:o.name}});this.voxelEntities.push(u)}catch(t){u.warn(`Failed to create outline frame ${o.name}:`,t)}}),u.debug(`Thick outline frames created for voxel ${c}: ${z.length} frames`)}setVisible(t){u.debug("VoxelRenderer.setVisible:",t),this.voxelEntities.forEach(e=>{try{const i="function"==typeof e.isDestroyed&&e.isDestroyed();e&&!i&&(e.show=t)}catch(t){u.warn("Entity visibility error:",t)}})}}const y=class{constructor(t,e={}){if(!function(t){if(!t)return!1;if(!t.scene||!t.entities||!t.scene.canvas)return!1;const e=t.scene.canvas;return!!(e.getContext("webgl2")||e.getContext("webgl")||e.getContext("experimental-webgl"))}(t))throw new Error("CesiumJS Viewerが無効です");this.viewer=t,this.options=c({...a,...e}),u.setLogLevel(this.options),this.renderer=new v(this.viewer,this.options),this._bounds=null,this._grid=null,this._voxelData=null,this._statistics=null,this._eventHandler=null,this._initializeEventListeners()}setData(t){if(d(t))try{if(u.debug("Heatbox.setData - 処理開始:",t.length,"個のエンティティ"),u.debug("Step 1: 境界計算"),this._bounds=m.calculateBounds(t),!this._bounds)return u.error("境界計算に失敗"),void this.clear();u.debug("境界計算完了:",this._bounds);let e=this.options.voxelSize||a.voxelSize,i=null;if(this.options.autoVoxelSize&&!this.options.voxelSize)try{u.debug("自動ボクセルサイズ調整開始");const o=function(t,e){try{const i=p(t),o=i.x*i.y*Math.max(i.z,10),n=e/o;let s;return s=n>.001?Math.max(10,Math.min(20,20/Math.sqrt(1e3*n))):n>1e-4?Math.max(20,Math.min(50,50/Math.sqrt(1e4*n))):Math.max(50,Math.min(100,100/Math.sqrt(1e5*n))),s=Math.max(5,Math.min(1e3,s)),u.debug(`Estimated voxel size: ${s}m (density: ${n}, volume: ${o})`),Math.round(s)}catch(t){return u.warn("Initial voxel size estimation failed:",t),20}}(this._bounds,t.length),n=x.createGrid(this._bounds,o),s=function(t,e){const i={valid:!0,warning:!1,error:null,recommendedSize:null};return t>l?(i.valid=!1,i.error="ボクセル数が上限を超えています",i.recommendedSize=Math.ceil(e*Math.pow(t/l,1/3))):t>3e4&&(i.warning=!0,i.error="推定メモリ使用量が警告値を超えています"),i}(n.totalVoxels,o);!s.valid&&s.recommendedSize?(e=s.recommendedSize,i={enabled:!0,originalSize:o,finalSize:e,adjusted:!0,reason:`Performance limit exceeded: ${n.totalVoxels} > 50000`},u.info(`Auto-adjusted voxelSize: ${o}m → ${e}m (${n.totalVoxels} voxels)`)):(e=o,i={enabled:!0,originalSize:o,finalSize:e,adjusted:!1,reason:null},u.info(`Auto-determined voxelSize: ${e}m`))}catch(t){u.warn("Auto voxel size adjustment failed, using default:",t),e=a.voxelSize,i={enabled:!0,adjusted:!1,reason:"Estimation failed, using default size",originalSize:null,finalSize:e}}u.debug("Step 2: グリッド生成 (サイズ:",e,"m)"),this._grid=x.createGrid(this._bounds,e),u.debug("グリッド生成完了:",this._grid),u.debug("Step 3: エンティティ分類"),this._voxelData=g.classifyEntitiesIntoVoxels(t,this._bounds,this._grid),u.debug("エンティティ分類完了:",this._voxelData.size,"個のボクセル"),u.debug("Step 4: 統計計算"),this._statistics=g.calculateStatistics(this._voxelData,this._grid),u.debug("統計情報:",this._statistics),i&&(this._statistics.autoAdjusted=i.adjusted,this._statistics.originalVoxelSize=i.originalSize,this._statistics.finalVoxelSize=i.finalSize,this._statistics.adjustmentReason=i.reason),u.debug("Step 5: 描画");const o=this.renderer.render(this._voxelData,this._bounds,this._grid,this._statistics);this._statistics.renderedVoxels=o,u.info("描画完了 - 実際の描画数:",o),u.debug("Heatbox.setData - 処理完了")}catch(t){throw u.error("ヒートマップ作成エラー:",t),this.clear(),t}else this.clear()}async createFromEntities(t){if(!d(t))throw new Error(r);return this.setData(t),this.getStatistics()}setVisible(t){this.renderer.setVisible(t)}clear(){this.renderer.clear(),this._bounds=null,this._grid=null,this._voxelData=null,this._statistics=null}destroy(){this.clear(),this._eventHandler&&!this._eventHandler.isDestroyed()&&this._eventHandler.destroy(),this._eventHandler=null}getOptions(){return{...this.options}}updateOptions(t){if(this.options=c({...this.options,...t}),this.renderer.options=this.options,this._voxelData){const t=this.renderer.render(this._voxelData,this._bounds,this._grid,this._statistics);this._statistics.renderedVoxels=t}}_initializeEventListeners(){this._eventHandler=new s.ScreenSpaceEventHandler(this.viewer.scene.canvas),this._eventHandler.setInputAction(t=>{const e=this.viewer.scene.pick(t.position);if(s.defined(e)&&e.id&&e.id.properties&&"voxel"===e.id.properties.type){const t=e.id.properties.key,i={x:e.id.properties.x,y:e.id.properties.y,z:e.id.properties.z,count:e.id.properties.count},o=new s.Entity({id:`voxel-${t}`,description:this.renderer.createVoxelDescription(i,t)});this.viewer.selectedEntity=o}},s.ScreenSpaceEventType.LEFT_CLICK)}getStatistics(){return this._statistics}getBounds(){return this._bounds}getDebugInfo(){const t={options:{...this.options},bounds:this._bounds,grid:this._grid,statistics:this._statistics};return this.options.autoVoxelSize&&(t.autoVoxelSizeInfo={enabled:this.options.autoVoxelSize,originalSize:this._statistics?.originalVoxelSize,finalSize:this._statistics?.finalVoxelSize,adjusted:this._statistics?.autoAdjusted||!1,reason:this._statistics?.adjustmentReason,dataRange:this._bounds?p(this._bounds):null,estimatedDensity:this._bounds&&this._statistics?this._statistics.totalEntities/(p(this._bounds).x*p(this._bounds).y*p(this._bounds).z):null}),t}static filterEntities(t,e){return Array.isArray(t)&&"function"==typeof e?t.filter(e):[]}};return u.info("CesiumJS Heatbox v0.1.7 loaded"),n.default})());
//# sourceMappingURL=cesium-heatbox.umd.min.js.map