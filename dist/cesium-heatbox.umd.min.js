!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("cesium")):"function"==typeof define&&define.amd?define(["cesium"],t):"object"==typeof exports?exports.CesiumHeatbox=t(require("cesium")):e.CesiumHeatbox=t(e.Cesium)}(this,e=>(()=>{"use strict";var t={50:t=>{t.exports=e}},i={};function n(e){var o=i[e];if(void 0!==o)return o.exports;var a=i[e]={exports:{}};return t[e](a,a.exports,n),a.exports}n.d=(e,t)=>{for(var i in t)n.o(t,i)&&!n.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var o={};n.d(o,{default:()=>I});var a=n(50);const r={voxelSize:20,opacity:.8,emptyOpacity:.03,showOutline:!0,showEmptyVoxels:!1,minColor:[0,32,255],maxColor:[255,64,0],maxRenderVoxels:5e4,batchMode:"auto",debug:!1,autoVoxelSize:!1,colorMap:"custom",diverging:!1,divergingPivot:0,highlightTopN:null,highlightStyle:{outlineWidth:4,boostOpacity:.2},voxelGap:0,outlineOpacity:1,outlineInset:0,outlineInsetMode:"all",enableThickFrames:!1,outlineRenderMode:"standard",adaptiveOutlines:!1,outlineWidthPreset:"uniform",adaptiveParams:{neighborhoodRadius:50,densityThreshold:5,cameraDistanceFactor:1,overlapRiskFactor:.3},renderLimitStrategy:"density",minCoverageRatio:.2,coverageBinsXY:"auto",autoVoxelSizeMode:"basic",autoVoxelTargetFill:.6,renderBudgetMode:"manual",autoView:!1,fitViewOptions:{paddingPercent:.1,pitchDegrees:-30,headingDegrees:0,altitudeStrategy:"auto"}},s=5e4,l=1e3,d=(Math.PI,"対象エンティティがありません");let c="undefined"!=typeof process&&process.env&&"true"===process.env.DEBUG?3:"undefined"!=typeof process&&process.env?1:3;const u={error(...e){c>=0&&console.error("[Heatbox ERROR]",...e)},warn(...e){c>=1&&console.warn("[Heatbox WARN]",...e)},info(...e){c>=2&&console.log("[Heatbox INFO]",...e)},debug(...e){c>=3&&console.log("[Heatbox DEBUG]",...e)},setLogLevel:e=>(e&&void 0!==e.debug&&("boolean"==typeof e.debug?c=e.debug?3:1:"object"==typeof e.debug&&null!==e.debug&&(c=3)),c)};u.debug,u.warn,u.error,u.info;class h{static estimate(e,t,i="basic",n={}){try{const o=void 0!==n.entityCount?n.entityCount:e?e.length:0;return"occupancy"===i?h.estimateByOccupancy(t,o,n):h.estimateBasic(t,o)}catch(e){return u.warn("Voxel size estimation failed:",e),20}}static estimateBasic(e,t){const i=h.calculateDataRange(e),n=i.x*i.y*Math.max(i.z,10),o=t/n;let a;return a=o>.001?Math.max(10,Math.min(20,20/Math.sqrt(1e3*o))):o>1e-4?Math.max(20,Math.min(50,50/Math.sqrt(1e4*o))):Math.max(50,Math.min(100,100/Math.sqrt(1e5*o))),a=Math.max(5,Math.min(l,a)),u.debug(`Basic voxel size estimated: ${a}m (density: ${o}, volume: ${n})`),Math.round(a)}static estimateByOccupancy(e,t,i){const n=h.calculateDataRange(e),o=i.maxRenderVoxels||5e4,a=i.autoVoxelTargetFill||.6;let r=h.estimateBasic(e,t);u.debug(`Starting occupancy-based estimation: N=${t}, target=${a}, maxVoxels=${o}`);for(let e=0;e<10;e++){const i=Math.ceil(n.x/r)*Math.ceil(n.y/r)*Math.ceil(n.z/r),s=i*(1-Math.exp(-t/i)),d=Math.min(s/o,1);if(u.debug(`Iteration ${e}: size=${r.toFixed(1)}m, totalVoxels=${i}, expectedOccupied=${s.toFixed(0)}, fill=${d.toFixed(3)}`),Math.abs(d-a)<.05){u.debug(`Converged at iteration ${e}: size=${r.toFixed(1)}m, fill=${d.toFixed(3)}`);break}r*=Math.pow(d/a,.3),r=Math.max(5,Math.min(l,r))}const s=Math.round(r);return u.info(`Occupancy-based voxel size: ${s}m (target fill: ${a})`),s}static calculateDataRange(e){const t=180*e.west/Math.PI,i=180*e.east/Math.PI,n=180*e.south/Math.PI,o=180*e.north/Math.PI,a=e.minimumHeight||0,r=e.maximumHeight||100,s=(n+o)/2,l=111e3*(i-t)*Math.cos(s*Math.PI/180),d=111e3*(o-n),c=Math.abs(r-a);return{x:Math.abs(l),y:Math.abs(d),z:Math.abs(c)}}static getEstimationMetadata(e,t,i){const n=h.calculateDataRange(e),o=n.x*n.y*Math.max(n.z,10),a=t/o;return{mode:i,entityCount:t,dataRange:n,volume:o,density:a,densityCategory:a>.001?"high":a>1e-4?"medium":"low"}}}function m(e){return!!Array.isArray(e)&&0!==e.length&&(e.length>5e3&&u.warn(`エンティティ数が推奨値(5000)を超えています: ${e.length}`),!0)}function g(e={}){const t={...e};if(t.batchMode&&t.debug&&u.warn("batchMode option is deprecated and will be removed in v1.0.0. It is currently ignored."),void 0!==t.voxelSize&&("number"!=typeof(i=t.voxelSize)||isNaN(i)||i<5||i>l))throw new Error(`ボクセルサイズが無効です: ${t.voxelSize}`);var i;if(void 0!==t.opacity&&(t.opacity=Math.max(0,Math.min(1,t.opacity))),void 0!==t.emptyOpacity&&(t.emptyOpacity=Math.max(0,Math.min(1,t.emptyOpacity))),t.minColor&&Array.isArray(t.minColor)&&3===t.minColor.length&&(t.minColor=t.minColor.map(e=>Math.max(0,Math.min(255,Math.floor(e))))),t.maxColor&&Array.isArray(t.maxColor)&&3===t.maxColor.length&&(t.maxColor=t.maxColor.map(e=>Math.max(0,Math.min(255,Math.floor(e))))),void 0!==t.colorMap&&(["custom","viridis","inferno"].includes(t.colorMap)||(u.warn(`Invalid colorMap: ${t.colorMap}. Using 'custom'.`),t.colorMap="custom")),void 0!==t.highlightTopN&&null!==t.highlightTopN&&("number"!=typeof t.highlightTopN||t.highlightTopN<=0)&&(u.warn(`Invalid highlightTopN: ${t.highlightTopN}. Must be a positive number.`),t.highlightTopN=null),void 0!==t.voxelGap&&(t.voxelGap=Math.max(0,Math.min(100,parseFloat(t.voxelGap)||0))),void 0!==t.outlineOpacity&&(t.outlineOpacity=Math.max(0,Math.min(1,parseFloat(t.outlineOpacity)||1))),void 0!==t.outlineInset){const e=parseFloat(t.outlineInset);t.outlineInset=isNaN(e)||e<0?0:e}if(void 0!==t.outlineInsetMode&&(["all","topn"].includes(t.outlineInsetMode)||(u.warn(`Invalid outlineInsetMode: ${t.outlineInsetMode}. Using 'all'.`),t.outlineInsetMode="all")),void 0!==t.outlineInset){const e=parseFloat(t.outlineInset);t.outlineInset=Math.max(0,Math.min(100,isNaN(e)?0:e))}if(void 0!==t.outlineInsetMode&&(["all","topn"].includes(t.outlineInsetMode)||(u.warn(`Invalid outlineInsetMode: ${t.outlineInsetMode}. Using 'all'.`),t.outlineInsetMode="all")),void 0!==t.enableThickFrames&&(t.enableThickFrames=Boolean(t.enableThickFrames)),void 0!==t.renderLimitStrategy&&(["density","coverage","hybrid"].includes(t.renderLimitStrategy)||(u.warn(`Invalid renderLimitStrategy: ${t.renderLimitStrategy}. Using 'density'.`),t.renderLimitStrategy="density")),void 0!==t.minCoverageRatio){const e=parseFloat(t.minCoverageRatio);t.minCoverageRatio=isNaN(e)?.2:Math.max(0,Math.min(1,e))}if(void 0!==t.coverageBinsXY){const e=t.coverageBinsXY;if("auto"!==e){const i=parseInt(e,10);!Number.isFinite(i)||i<=0?(u.warn(`Invalid coverageBinsXY: ${e}. Using 'auto'.`),t.coverageBinsXY="auto"):t.coverageBinsXY=i}}if(void 0!==t.autoVoxelSizeMode&&(["basic","occupancy"].includes(t.autoVoxelSizeMode)||(u.warn(`Invalid autoVoxelSizeMode: ${t.autoVoxelSizeMode}. Using 'basic'.`),t.autoVoxelSizeMode="basic")),void 0!==t.autoVoxelTargetFill){const e=parseFloat(t.autoVoxelTargetFill);t.autoVoxelTargetFill=isNaN(e)?.6:Math.max(0,Math.min(1,e))}if(void 0!==t.renderBudgetMode&&(["manual","auto"].includes(t.renderBudgetMode)||(u.warn(`Invalid renderBudgetMode: ${t.renderBudgetMode}. Using 'manual'.`),t.renderBudgetMode="manual")),void 0!==t.fitViewOptions){const e=t.fitViewOptions||{},i=parseFloat(e.paddingPercent),n=parseFloat(e.pitchDegrees??e.pitch),o=parseFloat(e.headingDegrees??e.heading),a=e.altitudeStrategy;void 0===e.pitch&&void 0===e.heading||u.warn("fitViewOptions.pitch/heading は非推奨です。pitchDegrees/headingDegreesを使用してください。"),t.fitViewOptions={paddingPercent:Number.isFinite(i)?Math.max(0,Math.min(1,i)):.1,pitchDegrees:Number.isFinite(n)?Math.max(-90,Math.min(0,n)):-30,headingDegrees:Number.isFinite(o)?o:0,altitudeStrategy:"manual"===a?"manual":"auto"}}return t}function p(e){return h.calculateDataRange(e)}const x={low:{min:8e3,max:12e3},mid:{min:2e4,max:35e3},high:{min:4e4,max:5e4}};class y{static detect(){try{const e=y._getWebGLInfo(),t=y._getDeviceInfo();let i="mid",n="fallback";if(null!==t.deviceMemory)i=t.deviceMemory<=4?"low":t.deviceMemory<=8?"mid":"high",n="deviceMemory";else if(null!==t.hardwareConcurrency){const e=t.hardwareConcurrency*Math.min(t.screenPixels/2073600,2);i=e<=4?"low":e<=8?"mid":"high",n="hardwareConcurrency+resolution"}"fallback"!==n&&e.maxTextureSize>0&&(e.maxTextureSize<4096||!e.webgl2)&&(i="high"===i?"mid":"low",n+="+webglLimits");const o=x[i],a=Math.min(Math.floor((o.min+o.max)/2),s);return u.debug(`Device tier detected: ${i} (${n}), maxRenderVoxels: ${a}`),{tier:i,maxRenderVoxels:a,metadata:{detectionMethod:n,deviceInfo:t,webglInfo:e,tierRange:o}}}catch(e){return u.warn("Device tier detection failed, using default mid tier:",e),{tier:"mid",maxRenderVoxels:Math.min(25e3,s),metadata:{detectionMethod:"error-fallback",deviceInfo:null,webglInfo:null,error:e.message}}}}static applyAutoRenderBudget(e){if("auto"!==e.renderBudgetMode&&"auto"!==e.maxRenderVoxels)return e;const t=y.detect(),i={...e,maxRenderVoxels:t.maxRenderVoxels,_autoRenderBudget:{tier:t.tier,detectionMethod:t.metadata.detectionMethod,autoMaxRenderVoxels:t.maxRenderVoxels}};return u.info(`Auto Render Budget applied: ${t.tier} tier, maxRenderVoxels: ${t.maxRenderVoxels}`),i}static _getWebGLInfo(){try{if("undefined"==typeof document||"function"!=typeof document.createElement)return{webgl2:!1,maxTextureSize:0,maxRenderbufferSize:0};const e=document.createElement("canvas");if(!e||"function"!=typeof e.getContext)return{webgl2:!1,maxTextureSize:0,maxRenderbufferSize:0};const t=e.getContext("webgl2")||e.getContext("webgl");if(!t)return{webgl2:!1,maxTextureSize:0,maxRenderbufferSize:0};const i={webgl2:!!e.getContext&&!!e.getContext("webgl2"),maxTextureSize:t.getParameter(t.MAX_TEXTURE_SIZE),maxRenderbufferSize:t.getParameter(t.MAX_RENDERBUFFER_SIZE)};return e.remove(),i}catch(e){return u.warn("WebGL info detection failed:",e),{webgl2:!1,maxTextureSize:0,maxRenderbufferSize:0}}}static _getDeviceInfo(){if("undefined"==typeof navigator)throw new Error("navigator is undefined");const e="undefined"!=typeof window&&"number"==typeof window.devicePixelRatio?window.devicePixelRatio:1,t="undefined"!=typeof screen&&"number"==typeof screen.width?screen.width:1920,i="undefined"!=typeof screen&&"number"==typeof screen.height?screen.height:1080,n=navigator;return{deviceMemory:n&&void 0!==n.deviceMemory?n.deviceMemory:null,hardwareConcurrency:n&&void 0!==n.hardwareConcurrency?n.hardwareConcurrency:null,devicePixelRatio:e,screenPixels:t*i*Math.pow(e,2),userAgent:n&&n.userAgent?n.userAgent:""}}}class f{static calculateBounds(e){if(!Array.isArray(e)||0===e.length)throw new Error("エンティティが提供されていません");let t=1/0,i=-1/0,n=1/0,o=-1/0,r=1/0,s=-1/0,l=0;const d=a.JulianDate.now();if(e.forEach((e,c)=>{try{let c;if(e.position&&(c="function"==typeof e.position.getValue?e.position.getValue(d):e.position),!c)return;const u=a.Cartographic.fromCartesian(c);if(!u)return;const h=a.Math.toDegrees(u.longitude),m=a.Math.toDegrees(u.latitude),g=u.height;t=Math.min(t,h),i=Math.max(i,h),n=Math.min(n,m),o=Math.max(o,m),r=Math.min(r,g),s=Math.max(s,g),l++}catch(e){u.warn(`エンティティ ${c} の処理に失敗:`,e)}}),0===l)throw new Error("有効な位置情報を持つエンティティが見つかりません");return u.debug("座標範囲計算完了:",{validCount:l,bounds:{minLon:t,maxLon:i,minLat:n,maxLat:o,minAlt:r,maxAlt:s}}),{minLon:t,maxLon:i,minLat:n,maxLat:o,minAlt:r,maxAlt:s,centerLon:(t+i)/2,centerLat:(n+o)/2,centerAlt:(r+s)/2}}static voxelIndexToCoordinate(e,t,i,n,o){const{minLon:a,maxLon:r,minLat:s,maxLat:l,minAlt:d,maxAlt:c}=n,{numVoxelsX:u,numVoxelsY:h,numVoxelsZ:m}=o;return{lon:a+(e+.5)/u*(r-a),lat:s+(t+.5)/h*(l-s),alt:d+(i+.5)/m*(c-d)}}static coordinateToCartesian3(e,t,i){return a.Cartesian3.fromDegrees(e,t,i)}}class v{static createGrid(e,t){const i=(e.minLat+e.maxLat)/2,n=111e3*(e.maxLon-e.minLon)*Math.cos(i*Math.PI/180),o=111e3*(e.maxLat-e.minLat),a=e.maxAlt-e.minAlt,r=Math.max(1,Math.ceil(n/t)),s=Math.max(1,Math.ceil(o/t)),l=Math.max(1,Math.ceil(a/t)),d=r>0?n/r:t,c=s>0?o/s:t,h=l>0?Math.max(a/l,1):Math.max(t,1),m=r*s*l;return u.debug("VoxelGrid created:",{numVoxelsX:r,numVoxelsY:s,numVoxelsZ:l,totalVoxels:m,voxelSizeMeters:t,cellSizeX:d,cellSizeY:c,cellSizeZ:h,lonRangeMeters:n,latRangeMeters:o,altRangeMeters:a}),{numVoxelsX:r,numVoxelsY:s,numVoxelsZ:l,totalVoxels:m,voxelSizeMeters:t,cellSizeX:d,cellSizeY:c,cellSizeZ:h,lonRangeMeters:n,latRangeMeters:o,altRangeMeters:a}}static getVoxelKey(e,t,i){return`${e},${t},${i}`}static parseVoxelKey(e){const[t,i,n]=e.split(",").map(Number);return{x:t,y:i,z:n}}static iterateAllVoxels(e,t){const{numVoxelsX:i,numVoxelsY:n,numVoxelsZ:o}=e;for(let e=0;e<i;e++)for(let i=0;i<n;i++)for(let n=0;n<o;n++)t(e,i,n,this.getVoxelKey(e,i,n))}}class b{static classifyEntitiesIntoVoxels(e,t,i){const n=new Map;let o=0,r=0;u.debug(`Processing ${e.length} entities for classification`);const s=a.JulianDate.now();return e.forEach((e,l)=>{try{let l;if(e.position&&(l="function"==typeof e.position.getValue?e.position.getValue(s):e.position),!l)return void r++;const d=a.Cartographic.fromCartesian(l);if(!d)return void r++;const c=a.Math.toDegrees(d.longitude),u=a.Math.toDegrees(d.latitude),h=d.height;if(c<t.minLon-.001||c>t.maxLon+.001||u<t.minLat-.001||u>t.maxLat+.001||h<t.minAlt-1||h>t.maxAlt+1)return void r++;const m=t.maxLon-t.minLon,g=t.maxLat-t.minLat,p=t.maxAlt-t.minAlt,x=0===m?0:Math.floor((c-t.minLon)/m*i.numVoxelsX),y=0===g?0:Math.floor((u-t.minLat)/g*i.numVoxelsY),f=0===p?0:Math.floor((h-t.minAlt)/p*i.numVoxelsZ);if(x>=0&&x<i.numVoxelsX&&y>=0&&y<i.numVoxelsY&&f>=0&&f<i.numVoxelsZ){const t=v.getVoxelKey(x,y,f);n.has(t)||n.set(t,{x,y,z:f,entities:[],count:0});const i=n.get(t);i.entities.push(e),i.count++,o++}else r++}catch(e){u.warn(`エンティティ ${l} の処理に失敗:`,e),r++}}),u.info(`${o}個のエンティティを${n.size}個のボクセルに分類（${r}個はスキップ）`),n}static calculateStatistics(e,t){if(0===e.size)return{totalVoxels:t.totalVoxels,renderedVoxels:0,nonEmptyVoxels:0,emptyVoxels:t.totalVoxels,totalEntities:0,minCount:0,maxCount:0,averageCount:0,autoAdjusted:!1,originalVoxelSize:null,finalVoxelSize:null,adjustmentReason:null};const i=Array.from(e.values()).map(e=>e.count),n=i.reduce((e,t)=>e+t,0),o={totalVoxels:t.totalVoxels,renderedVoxels:0,nonEmptyVoxels:e.size,emptyVoxels:t.totalVoxels-e.size,totalEntities:n,minCount:Math.min(...i),maxCount:Math.max(...i),averageCount:n/e.size,autoAdjusted:!1,originalVoxelSize:null,finalVoxelSize:null,adjustmentReason:null};return u.debug("統計情報計算完了:",o),o}static getTopNVoxels(e,t){if(0===e.size||t<=0)return[];const i=Array.from(e.values()).sort((e,t)=>t.count-e.count);return i.slice(0,Math.min(t,i.length))}}class M{select(e,t,i,n=new Set,o={}){throw new Error("SelectionStrategyInterface.select() must be implemented by subclass")}getStrategyName(){throw new Error("SelectionStrategyInterface.getStrategyName() must be implemented by subclass")}validateOptions(e){return!0}}class w extends M{select(e,t,i,n=new Set,o={}){if(!Array.isArray(e))throw new Error("allVoxels must be an array");if("number"!=typeof t||t<0)throw new Error("maxCount must be a non-negative number");if(!(n instanceof Set))throw new Error("forceInclude must be a Set");const a=[...e].sort((e,t)=>t.info.count-e.info.count),r=[],s=new Set;a.forEach(e=>{n.has(e.key)&&r.length<t&&(r.push(e),s.add(e.key))}),a.forEach(e=>{!s.has(e.key)&&r.length<t&&(r.push(e),s.add(e.key))});const l=e.length,d=r.length,c=l-d,u={strategy:this.getStrategyName(),totalVoxels:l,selectedCount:d,clippedCount:c,forceIncludedCount:Math.min(n.size,d),densityRange:r.length>0?{max:r[0]?.info?.count||0,min:r[r.length-1]?.info?.count||0}:{max:0,min:0}};return{selected:r,metadata:u}}getStrategyName(){return"density"}validateOptions(e){return!0}}class V extends M{select(e,t,i,n=new Set,o={}){u.debug(`Coverage selection: ${e.length} candidates, max ${t}`);const a=[],r=new Set;if(this._addForceIncludedVoxels(e,a,r,n,t),a.length>=t)return this._createResult(a,o);const s=e.filter(e=>!r.has(e.key)),l=this._calculateOptimalBinCount(t-a.length,o),d=this._createSpatialBins(s,i,l);return this._selectFromBins(d,a,r,t,o),u.debug(`Coverage selection completed: ${a.length} voxels selected`),this._createResult(a,o,{binsXY:l,totalBins:d.size})}_addForceIncludedVoxels(e,t,i,n,o){for(const a of e)n.has(a.key)&&t.length<o&&(t.push(a),i.add(a.key))}_calculateOptimalBinCount(e,t){if(t.coverageBinsXY&&"auto"!==t.coverageBinsXY)return Math.max(1,parseInt(t.coverageBinsXY));const i=Math.ceil(Math.sqrt(e/4));return Math.max(2,Math.min(20,i))}_createSpatialBins(e,t,i){const n=new Map,o=Math.max(1,t.numVoxelsX),a=Math.max(1,t.numVoxelsY);for(const t of e){const e=`${Math.max(0,Math.min(i-1,Math.floor(t.info.x/o*i)))},${Math.max(0,Math.min(i-1,Math.floor(t.info.y/a*i)))}`;n.has(e)||n.set(e,[]),n.get(e).push(t)}return n}_selectFromBins(e,t,i,n,o){const a=Array.from(e.keys());let r=0;const s=10*a.length;for(;t.length<n&&r<s&&e.size>0;){const n=a[r%a.length],s=e.get(n);if(s&&s.length>0){const r=this._selectBestVoxelFromBin(s,o);r&&!i.has(r.key)&&(t.push(r),i.add(r.key));const l=s.indexOf(r);if(l>=0&&s.splice(l,1),0===s.length){e.delete(n);const t=a.indexOf(n);t>=0&&a.splice(t,1)}}r++}}_selectBestVoxelFromBin(e,t){if(0===e.length)return null;if(1===e.length)return e[0];const i=[...e].sort((e,t)=>t.info.count-e.info.count);switch(t.binSelectionMode||"highest"){case"median":return i[Math.floor(i.length/2)];case"random":return i[Math.floor(Math.random()*i.length)];default:return i[0]}}_createResult(e,t,i={}){return{selected:e,metadata:{strategy:"coverage",totalSelected:e.length,selectionRatio:e.length>0?1:0,...i}}}}class C extends M{constructor(){super(),this.densityStrategy=new w,this.coverageStrategy=new V}select(e,t,i,n=new Set,o={}){u.debug(`Hybrid selection: ${e.length} candidates, max ${t}`);const a=[],r=new Set;if(this._addForceIncludedVoxels(e,a,r,n,t),a.length>=t)return this._createResult(a,o,0,0);const s=this._determineCoverageRatio(o),l=t-a.length,d=Math.floor(l*s),c=l-d;u.debug(`Hybrid split: ${d} coverage, ${c} density`);let h=0;d>0&&(h=this._executeCoverageSelection(e,d,i,r,a,t,o));let m=0;return c>0&&a.length<t&&(m=this._executeDensitySelection(e,c,i,r,a,t,o)),u.debug(`Hybrid selection completed: ${a.length} total (${h} coverage, ${m} density)`),this._createResult(a,o,h,m)}_addForceIncludedVoxels(e,t,i,n,o){for(const a of e)n.has(a.key)&&t.length<o&&(t.push(a),i.add(a.key))}_determineCoverageRatio(e){return void 0!==e.minCoverageRatio?Math.max(0,Math.min(1,e.minCoverageRatio)):void 0!==e.coverageRatio?Math.max(0,Math.min(1,e.coverageRatio)):.3}_executeCoverageSelection(e,t,i,n,o,a,r){const s=e.filter(e=>!n.has(e.key));if(0===s.length||t<=0)return 0;const l={...r,binSelectionMode:r.hybridCoverageMode||"highest"},d=this.coverageStrategy.select(s,t,i,new Set,l);let c=0;for(const e of d.selected)o.length<a&&!n.has(e.key)&&(o.push(e),n.add(e.key),c++);return c}_executeDensitySelection(e,t,i,n,o,a,r){const s=e.filter(e=>!n.has(e.key));if(0===s.length||t<=0)return 0;const l={...r,selectionMode:r.hybridDensityMode||"highest"},d=this.densityStrategy.select(s,t,i,new Set,l);let c=0;for(const e of d.selected)o.length<a&&!n.has(e.key)&&(o.push(e),n.add(e.key),c++);return c}_createResult(e,t,i,n){const o=e.length;return{selected:e,metadata:{strategy:"hybrid",totalSelected:o,coverageSelected:i,densitySelected:n,coverageRatio:o>0?i/o:0,targetCoverageRatio:this._determineCoverageRatio(t),selectionRatio:o>0?1:0}}}}const S={viridis:[[68,1,84],[71,44,122],[59,81,139],[44,113,142],[33,144,141],[39,173,129],[92,200,99],[170,220,50],[253,231,37],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255]],inferno:[[0,0,4],[31,12,72],[85,15,109],[136,34,106],[186,54,85],[227,89,51],[249,142,8],[252,187,17],[245,219,76],[252,255,164],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255],[255,255,255]],diverging:[[0,0,255],[32,64,255],[64,128,255],[96,160,255],[128,192,255],[160,224,255],[192,240,255],[224,248,255],[255,255,255],[255,248,224],[255,240,192],[255,224,160],[255,192,128],[255,160,96],[255,128,64],[255,64,32],[255,0,0]]};class R{static interpolateColor(e,t=null,i={}){if(i.diverging&&null!==t&&("number"==typeof i.divergingPivot?i.divergingPivot:0)>0)return R._interpolateDivergingColor(t,i);if(i.colorMap&&"custom"!==i.colorMap)return R._interpolateFromColorMap(e,i.colorMap);const n=i.minColor||[0,0,255],o=i.maxColor||[255,0,0],[r,s,l]=n,[d,c,u]=o,h=Math.round(r+(d-r)*e),m=Math.round(s+(c-s)*e),g=Math.round(l+(u-l)*e);return a.Color.fromBytes(h,m,g)}static _interpolateFromColorMap(e,t){const i=S[t];if(!i)return u.warn(`Unknown color map: ${t}. Falling back to custom.`),R.interpolateColor(e);const n=e*(i.length-1),o=Math.floor(n),r=Math.min(o+1,i.length-1),s=n-o,[l,d,c]=i[o],[h,m,g]=i[r],p=Math.round(l+(h-l)*s),x=Math.round(d+(m-d)*s),y=Math.round(c+(g-c)*s);return a.Color.fromBytes(p,x,y)}static _interpolateDivergingColor(e,t){const i=t.divergingPivot||0;let n;return e<=i?(n=e/i*.5,n=Math.max(0,Math.min(.5,n))):(n=.5+(e-i)/i*.5,n=Math.max(.5,Math.min(1,n))),R._interpolateFromColorMap(n,"diverging")}static getAvailableColorMaps(){return Object.keys(S)}static hasColorMap(e){return Object.prototype.hasOwnProperty.call(S,e)}}class _{static createBoxEntity(e){const{position:t,dimensions:i,color:n,opacity:o,wireframe:r=!1,outline:s={},properties:l={},description:d=""}=e,c={position:t,box:{dimensions:i,outline:s.show||!1,outlineColor:s.color||a.Color.WHITE,outlineWidth:Math.max(s.width||1,0)},properties:{type:"voxel",...l},description:d};return r?(c.box.material=a.Color.TRANSPARENT,c.box.fill=!1):(c.box.material=n.withAlpha(o),c.box.fill=!0),c}static createPolylineEntity(e){const{positions:t,color:i,width:n=1,properties:o={}}=e;return{polyline:{positions:t,width:n,material:i,arcType:a.ArcType.NONE},properties:{type:"outline",...o}}}static createBoxEdgePolylines(e,t,i,n,o,r){try{const s=t/2,l=i/2,d=n/2,c=a.Transforms.eastNorthUpToFixedFrame(e),u=(e,t,i)=>{const n=new a.Cartesian3(e,t,i);return a.Matrix4.multiplyByPoint(c,n,new a.Cartesian3)},h=[u(-s,-l,-d),u(s,-l,-d),u(s,l,-d),u(-s,l,-d),u(-s,-l,d),u(s,-l,d),u(s,l,d),u(-s,l,d)];return[[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]].map(([e,t])=>_.createPolylineEntity({positions:[h[e],h[t]],color:o,width:r,properties:{edgeType:"thick-outline-emulation"}}))}catch(e){return u.warn("Edge polyline creation failed:",e),[]}}static createDebugBoundingBox(e){if(!e)return null;try{const t=(e.minLon+e.maxLon)/2,i=(e.minLat+e.maxLat)/2,n=(e.minAlt+e.maxAlt)/2,o=111e3*(e.maxLon-e.minLon)*Math.cos(i*Math.PI/180),r=111e3*(e.maxLat-e.minLat),s=e.maxAlt-e.minAlt;return{position:a.Cartesian3.fromDegrees(t,i,n),box:{dimensions:new a.Cartesian3(o,r,s),material:a.Color.YELLOW.withAlpha(.1),outline:!0,outlineColor:a.Color.YELLOW.withAlpha(.3),outlineWidth:2},properties:{type:"debug-bounds"},description:`バウンディングボックス<br>サイズ: ${o.toFixed(1)} x ${r.toFixed(1)} x ${s.toFixed(1)} m`}}catch(e){return u.warn("Failed to create debug bounding box:",e),null}}static createInsetOutlinePolylines(e,t,i,n,o,r,s,l,d){try{const c=a.Cartesian3.fromDegrees(e,t,i),u=Math.max(n-2*d,.1*n),h=Math.max(o-2*d,.1*o),m=Math.max(r-2*d,.1*r);return _.createBoxEdgePolylines(c,u,h,m,s,l).map(e=>({...e,properties:{...e.properties,edgeType:"inset-outline"}}))}catch(e){return u.warn("Failed to create inset outline:",e),[]}}}class z{constructor(e){this.viewer=e,this.debugEntities=[]}shouldShowBounds(e){return!!e&&("boolean"==typeof e?e:"object"==typeof e&&null!==e&&!0===e.showBounds)}renderBoundingBox(e,t){if(!this.shouldShowBounds(t))return!1;try{const t=_.createDebugBoundingBox(e);if(!t)return u.warn("Failed to create debug bounding box configuration"),!1;const i=this.viewer.entities.add(t);return this.debugEntities.push(i),u.debug("Debug bounding box added:",{center:{lon:(e.minLon+e.maxLon)/2,lat:(e.minLat+e.maxLat)/2,alt:(e.minAlt+e.maxAlt)/2},size:{width:111e3*(e.maxLon-e.minLon)*Math.cos((e.minLat+e.maxLat)/2*Math.PI/180),depth:111e3*(e.maxLat-e.minLat),height:e.maxAlt-e.minAlt}}),!0}catch(e){return u.warn("Failed to render debug bounding box:",e),!1}}renderGridLines(e,t,i){if(!i||!i.showGrid)return 0;try{let i=0;for(let n=0;n<=t.numVoxelsX;n++){const o=e.minLon+n*(e.maxLon-e.minLon)/t.numVoxelsX,r=this.viewer.entities.add({polyline:{positions:[a.Cartesian3.fromDegrees(o,e.minLat,e.minAlt),a.Cartesian3.fromDegrees(o,e.maxLat,e.minAlt),a.Cartesian3.fromDegrees(o,e.maxLat,e.maxAlt),a.Cartesian3.fromDegrees(o,e.minLat,e.maxAlt),a.Cartesian3.fromDegrees(o,e.minLat,e.minAlt)],width:1,material:a.Color.CYAN.withAlpha(.3),arcType:a.ArcType.NONE},properties:{type:"debug-grid",direction:"x",index:n}});this.debugEntities.push(r),i++}for(let n=0;n<=t.numVoxelsY;n++){const o=e.minLat+n*(e.maxLat-e.minLat)/t.numVoxelsY,r=this.viewer.entities.add({polyline:{positions:[a.Cartesian3.fromDegrees(e.minLon,o,e.minAlt),a.Cartesian3.fromDegrees(e.maxLon,o,e.minAlt),a.Cartesian3.fromDegrees(e.maxLon,o,e.maxAlt),a.Cartesian3.fromDegrees(e.minLon,o,e.maxAlt),a.Cartesian3.fromDegrees(e.minLon,o,e.minAlt)],width:1,material:a.Color.MAGENTA.withAlpha(.3),arcType:a.ArcType.NONE},properties:{type:"debug-grid",direction:"y",index:n}});this.debugEntities.push(r),i++}return u.debug(`Debug grid rendered: ${i} lines`),i}catch(e){return u.warn("Failed to render debug grid:",e),0}}renderStatsOverlay(e,t){if(!t||!t.showStats)return!1;try{return e.totalVoxels,e.renderedVoxels,e.renderTime,e.memoryUsage,u.debug("Debug stats overlay would be rendered:",e),!0}catch(e){return u.warn("Failed to render debug stats overlay:",e),!1}}clear(){u.debug("DebugRenderer.clear - Removing",this.debugEntities.length,"debug entities"),this.debugEntities.forEach(e=>{try{const t="function"==typeof e.isDestroyed&&e.isDestroyed();e&&!t&&this.viewer.entities.remove(e)}catch(e){u.warn("Debug entity removal error:",e)}}),this.debugEntities=[]}getEntityCount(){return this.debugEntities.length}logDebugInfo(e,t){u.debug(`[${e}]`,t)}}class D{constructor(e={}){this.options={neighborhoodRadius:50,densityThreshold:5,cameraDistanceFactor:1,overlapRiskFactor:.3,...e}}calculateAdaptiveParams(e,t,i,n,o,a){if(!a.adaptiveOutlines)return{outlineWidth:null,boxOpacity:null,outlineOpacity:null,shouldUseEmulation:!1};const{x:r,y:s,z:l,count:d}=e,c=n.maxCount>n.minCount?(d-n.minCount)/(n.maxCount-n.minCount):0,h=this._calculateNeighborhoodDensity(r,s,l,i),m=this._calculateCameraDistanceFactor(e,o),g=this._calculateOverlapRisk(e,i,o),p=this._calculateOutlineWidth(c,h,m,a.outlineWidthPreset,a.outlineWidth,t),x=this._calculateBoxOpacity(c,t,a.opacity),y=this._calculateOutlineOpacity(c,h,m),f=this._shouldUseEmulation(g,h,a.outlineRenderMode);return u.debug("Calculated adaptive params for voxel:",{voxel:{x:r,y:s,z:l,count:d},normalizedDensity:c,neighborDensity:h,cameraFactor:m,overlapRisk:g,result:{outlineWidth:p,boxOpacity:x,outlineOpacity:y,shouldUseEmulation:f}}),{outlineWidth:p,boxOpacity:x,outlineOpacity:y,shouldUseEmulation:f}}_calculateNeighborhoodDensity(e,t,i,n){const o=Math.floor(this.options.neighborhoodRadius/100);let a=0,r=0;for(let s=-o;s<=o;s++)for(let l=-o;l<=o;l++)for(let d=-o;d<=o;d++){const o=`${e+s},${t+l},${i+d}`,c=n.get(o);c&&(a+=c.count,r++)}return r>0?a/r:0}_calculateCameraDistanceFactor(e,t){if(!(t&&t.camera&&e&&e.position))return 1;const i=t.camera,n=e.position,o=i.position||new a.Cartesian3(0,0,1e3),r=a.Cartesian3.distance(o,n);return 1-Math.min(r/1e4,1)*this.options.cameraDistanceFactor}_calculateOverlapRisk(e,t,i){const{x:n,y:o,z:a}=e;let r=0;const s=[[n+1,o,a],[n-1,o,a],[n,o+1,a],[n,o-1,a],[n,o,a+1],[n,o,a-1]];for(const[e,i,n]of s){const o=`${e},${i},${n}`;t.has(o)&&r++}return r/6*this.options.overlapRiskFactor}_calculateOutlineWidth(e,t,i,n,o,a=!1){switch(n){case"adaptive-density":return t>this.options.densityThreshold?Math.max(.5,o*(.5+.5*e)):o;case"topn-focus":return a?o*(1.5+.5*e):Math.max(.5,.7*o);case"density-based":return o*(.5+1.5*e);case"distance-adaptive":return o*(.8+.4*i);case"neighborhood-aware":return o*(t>this.options.densityThreshold?.7:1.2);default:return o}}_calculateBoxOpacity(e,t,i){return t?Math.min(1.2*i,1):i*(.6+.4*e)}_calculateOutlineOpacity(e,t,i){const n=.7+.3*e,o=t>this.options.densityThreshold?.9:1,a=.8+.2*i;return Math.min(n*o*a,1)}_shouldUseEmulation(e,t,i){return"emulation-only"===i||"standard"!==i&&e>.5&&t>this.options.densityThreshold}updateOptions(e){this.options={...this.options,...e},u.debug("AdaptiveOutlineController options updated:",this.options)}}class L{constructor(e){this.viewer=e}renderOutline(e,t,i={}){const{outlineRenderMode:n}=t;switch(u.debug("Rendering outline for voxel:",{voxel:e,mode:n,adaptive:i}),n){case"standard":{const n=[];return(t.outlineInset||0)>0&&this._shouldApplyInsetOutline(e,t)&&n.push(...this._renderInsetOutline(e,t,i)),n}case"inset":return this._renderInsetOutline(e,t,i);case"emulation-only":return this._renderEmulationOutline(e,t,i);default:return u.warn("Unknown outline render mode:",n),this._renderStandardOutline(e,t,i)}}_shouldApplyInsetOutline(e,t){return"topn"!==(t.outlineInsetMode||"all")||!!e.isTopN}_renderStandardOutline(e,t,i){const n=i.outlineWidth||t.outlineWidth,o=i.outlineOpacity||1,r=a.Color.fromBytes(255,255,255,Math.round(255*o)),s=e.position,l=e.width,d=e.depth,c=e.height;return _.createBoxEdgePolylines(s,l,d,c,r,n)}_renderInsetOutline(e,t,i){const{outlineInset:n}=t;if(n<=0)return this._renderStandardOutline(e,t,i);if(i.shouldUseEmulation)return this._renderEmulationOutline(e,t,i);const o=i.outlineWidth||t.outlineWidth,r=i.outlineOpacity||1,s=e.position,l=.2*e.width,d=.2*e.depth,c=.2*e.height,h=Math.min(n,l),m=Math.min(n,d),g=Math.min(n,c),p=Math.max(e.width-2*h,.1*e.width),x=Math.max(e.depth-2*m,.1*e.depth),y=Math.max(e.height-2*g,.1*e.height),f=a.Color.fromBytes(255,255,255,Math.round(255*r)),v={position:s,box:{dimensions:new a.Cartesian3(p,x,y),material:a.Color.TRANSPARENT,outline:!0,outlineColor:f,outlineWidth:Math.max(o||1,1),fill:!1},properties:{type:"voxel-inset-outline",parentKey:e.key,insetSize:{x:p,y:x,z:y}}};return u.debug("Created inset outline with offset:",n),[v]}_renderEmulationOutline(e,t,i){const n=i.outlineWidth||t.outlineWidth,o=i.outlineOpacity||1,r=a.Color.fromBytes(51,51,51,Math.round(255*o)),s=1.5*n,l=e.position,d=e.width,c=e.depth,h=e.height,m=_.createBoxEdgePolylines(l,d,c,h,r,s);return u.debug("Created emulation outline with enhanced width:",s),m}_createInsetVoxelInfo(e,t,i){const n={...e};switch(i){case"all":n.width=Math.max(.1,e.width-2*t),n.height=Math.max(.1,e.height-2*t),n.depth=Math.max(.1,e.depth-2*t);break;case"horizontal":n.width=Math.max(.1,e.width-2*t),n.depth=Math.max(.1,e.depth-2*t);break;case"vertical":n.height=Math.max(.1,e.height-2*t);break;default:u.warn("Unknown inset mode:",i),n.width=Math.max(.1,e.width-2*t),n.height=Math.max(.1,e.height-2*t),n.depth=Math.max(.1,e.depth-2*t)}return u.debug("Created inset voxel info:",{original:{width:e.width,height:e.height,depth:e.depth},inset:{width:n.width,height:n.height,depth:n.depth},mode:i,offset:t}),n}shouldRenderOutline(e,t){return!!t.showOutline&&e.count>0}getOutlineColor(e,t,i=!1){return i?a.Color.fromBytes(255,255,0,255):"emulation-only"===t.outlineRenderMode?a.Color.fromBytes(51,51,51,255):a.Color.fromBytes(255,255,255,255)}}class E{constructor(e={}){this.options={fontFamily:e.fontFamily||"Arial, sans-serif",containerPadding:e.containerPadding||"10px",headerMargin:e.headerMargin||"0",tableWidth:e.tableWidth||"100%",...e}}createVoxelDescription(e,t){return`\n      <div style="padding: ${this.options.containerPadding}; font-family: ${this.options.fontFamily};">\n        <h3 style="margin-top: ${this.options.headerMargin};">ボクセル [${e.x}, ${e.y}, ${e.z}]</h3>\n        <table style="width: ${this.options.tableWidth};">\n          <tr><td><b>エンティティ数:</b></td><td>${e.count}</td></tr>\n          <tr><td><b>ID:</b></td><td>${t}</td></tr>\n        </table>\n      </div>\n    `}createExtendedVoxelDescription(e,t,i=null){let n=this.createVoxelDescription(e,t);if(i){const e=`\n        <hr style="margin: 10px 0;">\n        <h4 style="margin: 5px 0;">統計情報</h4>\n        <table style="width: ${this.options.tableWidth};">\n          ${void 0!==i.percentile?`<tr><td><b>パーセンタイル:</b></td><td>${i.percentile.toFixed(1)}%</td></tr>`:""}\n          ${void 0!==i.rank&&void 0!==i.total?`<tr><td><b>ランク:</b></td><td>${i.rank}/${i.total}</td></tr>`:""}\n        </table>\n      `;n=n.replace("</div>",e+"</div>")}return n}createCustomVoxelDescription(e,t,i=[]){const n=i.map(e=>`<tr><td><b>${e.label}:</b></td><td>${e.value}</td></tr>`).join("");return`\n      <div style="padding: ${this.options.containerPadding}; font-family: ${this.options.fontFamily};">\n        <h3 style="margin-top: ${this.options.headerMargin};">ボクセル [${e.x}, ${e.y}, ${e.z}]</h3>\n        <table style="width: ${this.options.tableWidth};">\n          <tr><td><b>エンティティ数:</b></td><td>${e.count}</td></tr>\n          <tr><td><b>ID:</b></td><td>${t}</td></tr>\n          ${n}\n        </table>\n      </div>\n    `}}class O{static calculateVoxelCenter(e,t,i,n,o){return{longitude:n.minLon+(e+.5)*(n.maxLon-n.minLon)/o.numVoxelsX,latitude:n.minLat+(t+.5)*(n.maxLat-n.minLat)/o.numVoxelsY,altitude:n.minAlt+(i+.5)*(n.maxAlt-n.minAlt)/o.numVoxelsZ}}static calculateVoxelPosition(e,t,i,n,o){const r=O.calculateVoxelCenter(e,t,i,n,o);return a.Cartesian3.fromDegrees(r.longitude,r.latitude,r.altitude)}static calculateVoxelSizes(e,t={}){let i=e.cellSizeX||(e.lonRangeMeters?e.lonRangeMeters/e.numVoxelsX:e.voxelSizeMeters),n=e.cellSizeY||(e.latRangeMeters?e.latRangeMeters/e.numVoxelsY:e.voxelSizeMeters),o=e.cellSizeZ||(e.altRangeMeters?Math.max(e.altRangeMeters/Math.max(e.numVoxelsZ,1),1):Math.max(e.voxelSizeMeters,1));return t.voxelGap>0&&(i=Math.max(i-t.voxelGap,.1*i),n=Math.max(n-t.voxelGap,.1*n),o=Math.max(o-t.voxelGap,.1*o)),{sizeX:i,sizeY:n,sizeZ:o}}static calculateAdjustedHeight(e,t,i=!1){return i?e*(.1+.9*t):e}static calculateVoxelDimensions(e,t,i={}){const n=O.calculateVoxelSizes(e,i),o=O.calculateAdjustedHeight(n.sizeZ,t,i.heightBased);return new a.Cartesian3(n.sizeX,n.sizeY,o)}static calculateBoundsCenter(e){return{longitude:(e.minLon+e.maxLon)/2,latitude:(e.minLat+e.maxLat)/2,altitude:(e.minAlt+e.maxAlt)/2}}static calculateBoundsCenterPosition(e){const t=O.calculateBoundsCenter(e);return a.Cartesian3.fromDegrees(t.longitude,t.latitude,t.altitude)}}class A{constructor(e){this.viewer=e,this.entityFactory=new _,this.colorMap=new R}renderVoxels(e,t,i,n,o,r,s,l,d){const c=[];return u.debug(`Rendering ${e.length} voxels`),e.forEach(({key:e,info:d})=>{try{const{x:h,y:m,z:g}=d,p=O.calculateVoxelCenter(h,m,g,i,n),x=p.longitude,y=p.latitude,f=p.altitude,v=t.has(e),b=a.Cartesian3.fromDegrees(x,y,f),M=s({...d,position:b},v,null,o);let w,V;const C=o.maxCount>o.minCount?(d.count-o.minCount)/(o.maxCount-o.minCount):0;if(0===d.count)w=a.Color.LIGHTGRAY,V=r.emptyOpacity;else{if(w=R.interpolateColor(C,d.count,r),r.boxOpacityResolver&&"function"==typeof r.boxOpacityResolver){const e={voxel:{x:h,y:m,z:g,count:d.count},isTopN:v,normalizedDensity:C,statistics:o,adaptiveParams:M};try{const t=r.boxOpacityResolver(e);V=isNaN(t)?r.opacity:Math.max(0,Math.min(1,t))}catch(e){u.warn("boxOpacityResolver error, using fallback:",e),V=M.boxOpacity||r.opacity}}else V=M.boxOpacity||r.opacity;!r.highlightTopN||v||r.boxOpacityResolver||(V*=.3)}const S=O.calculateVoxelDimensions(n,C,r),z=S.x,D=S.y,L=S.z;let E=f,A=r.outlineWidth,$=r.showOutline?a.Color.fromBytes(255,255,255,255):void 0;if(r.outlineWidthResolver&&"function"==typeof r.outlineWidthResolver){const e={voxel:{x:h,y:m,z:g,count:d.count},isTopN:v,density:d.count,normalizedDensity:o.maxCount>o.minCount?(d.count-o.minCount)/(o.maxCount-o.minCount):0,statistics:o,adaptiveParams:M};try{const t=r.outlineWidthResolver(e);A=isNaN(t)?r.outlineWidth:Math.max(0,t)}catch(e){u.warn("outlineWidthResolver error, using fallback:",e),A=M.outlineWidth||r.outlineWidth}}else r.adaptiveOutlines&&null!==M.outlineWidth&&(A=M.outlineWidth);v&&r.highlightTopN&&(A=r.highlightStyle&&r.highlightStyle.outlineWidth||A);const F=null!=M.outlineOpacity?M.outlineOpacity:null!=r.outlineOpacity?r.outlineOpacity:1;r.showOutline&&($=a.Color.fromBytes(255,255,255,255).withAlpha(F));const B=_.createBoxEntity({position:a.Cartesian3.fromDegrees(x,y,E),dimensions:new a.Cartesian3(z,D,L),color:w,opacity:V,wireframe:r.wireframeOnly,outline:{show:!0===r.showOutline,color:$,width:A||1},properties:{key:e,count:d.count,x:d.x,y:d.y,z:d.z,isTopN:v,normalizedDensity:C}}),I=new a.Entity({id:`voxel-${e}`,...B});I.description=r.createVoxelDescription?r.createVoxelDescription(d,C,o):`Count: ${d.count}`,this.viewer.entities.add(I),c.push(I);const N={outlineRenderMode:r.outlineRenderMode,outlineInset:r.outlineInset,outlineInsetMode:r.outlineInsetMode,showOutline:r.showOutline,outlineColor:$,outlineWidth:A,enableThickFrames:r.enableThickFrames},T={...d,key:e,position:a.Cartesian3.fromDegrees(x,y,E),width:z,height:L,depth:D,isTopN:v};l.renderOutline(T,N,M).forEach(e=>{this.viewer.entities.add(e),c.push(e)})}catch(t){u.error("Error rendering voxel:",t,{key:e,info:d})}}),u.info(`Successfully rendered ${c.length} voxels`),c}processDisplayVoxels(e,t,i,n,o){let a=[];const r=new Set,s=1e6;if(n.showEmptyVoxels)for(let t=0;t<i.numVoxelsX;t++){for(let n=0;n<i.numVoxelsY;n++){for(let o=0;o<i.numVoxelsZ;o++){const i=`${t},${n},${o}`,r=e.get(i)||{x:t,y:n,z:o,count:0,entities:[]};if(a.push({key:i,info:r}),a.length>=s){u.debug("Reached maximum voxel limit of 1000000");break}}if(a.length>=s)break}if(a.length>=s)break}else if(a=Array.from(e.entries()).map(([e,t])=>({key:e,info:t})),n.maxRenderVoxels&&a.length>n.maxRenderVoxels){const e=o(a,n.maxRenderVoxels,t,i);a=e.selectedVoxels,u.debug(`Applied ${e.strategy} strategy: ${a.length} voxels selected, ${e.clippedNonEmpty} clipped`)}return n.highlightTopN&&n.highlightTopN>0&&([...a].sort((e,t)=>t.info.count-e.info.count).slice(0,n.highlightTopN).forEach(e=>r.add(e.key)),u.debug(`TopN highlight enabled: ${r.size} voxels will be highlighted`)),{displayVoxels:a,topNVoxels:r}}}class ${constructor(e){this.viewer=e,this.entityFactory=new _,this.voxelEntities=[]}addEntity(e){return this.voxelEntities.push(e),e}clear(){u.debug("VoxelEntityManager.clear - Removing",this.voxelEntities.length,"entities"),this.voxelEntities.forEach(e=>{try{const t="function"==typeof e.isDestroyed&&e.isDestroyed();e&&!t&&this.viewer.entities.remove(e)}catch(e){u.warn("Entity removal error:",e)}}),this.voxelEntities=[]}setVisible(e){u.debug("VoxelEntityManager.setVisible:",e,"for",this.voxelEntities.length,"entities"),this.voxelEntities.forEach(t=>{try{const i="function"==typeof t.isDestroyed&&t.isDestroyed();t&&!i&&(t.show=e)}catch(e){u.warn("Entity visibility error:",e)}})}createInsetOutline(e,t,i,n,o,r,s,l,d,c=null){const u=c||1,h=Math.max(.1*n,n-2*u),m=Math.max(.1*o,o-2*u),g=Math.max(.1*r,r-2*u),p=.4*n,x=.4*o,y=.4*r,f=Math.max(h,n-p),v=Math.max(m,o-x),b=Math.max(g,r-y),M=new a.Cartesian3(f,v,b),w=this.entityFactory.createBoxEntity({id:`voxel-inset-${d}`,position:a.Cartesian3.fromDegrees(e,t,i),dimensions:M,color:a.Color.TRANSPARENT,opacity:0,outlineColor:s,outlineWidth:l,wireframeOnly:!0,key:`inset-${d}`});return this.viewer.entities.add(w),this.addEntity(w),w}createThickOutlineFrames(e,t,i,n,o,r,s,l,d,c,u){const h=[],m=Math.max((n-s)/2,.5);return[{position:[e,t,i+(r-m)/2],size:[n,o,m]},{position:[e,t,i-(r-m)/2],size:[n,o,m]},{position:[e,t+(o-m)/2,i],size:[n,m,d]},{position:[e,t-(o-m)/2,i],size:[n,m,d]},{position:[e+(n-m)/2,t,i],size:[m,l,d]},{position:[e-(n-m)/2,t,i],size:[m,l,d]},{position:[e+s/2,t+l/2,i],size:[m,m,r]},{position:[e-s/2,t+l/2,i],size:[m,m,r]},{position:[e+s/2,t-l/2,i],size:[m,m,r]},{position:[e-s/2,t-l/2,i],size:[m,m,r]},{position:[e,t+l/2,i+d/2],size:[s,m,m]},{position:[e,t-l/2,i+d/2],size:[s,m,m]}].forEach((e,t)=>{if(e.size[0]>.1&&e.size[1]>.1&&e.size[2]>.1){const i=this.entityFactory.createBoxEntity({id:`thick-frame-${u}-${t}`,position:a.Cartesian3.fromDegrees(e.position[0],e.position[1],e.position[2]),dimensions:{width:e.size[0],height:e.size[1],depth:e.size[2]},color:c,opacity:1,outlineColor:void 0,outlineWidth:0,wireframeOnly:!1,key:`thick-frame-${u}-${t}`});this.viewer.entities.add(i),this.addEntity(i),h.push(i)}}),h}shouldApplyInsetOutline(e,t){switch(t.outlineInsetMode||"all"){case"all":default:return!0;case"topn-only":return e;case"non-topn":return!e}}getEntityStats(){return{totalEntities:this.voxelEntities.length,activeEntities:this.voxelEntities.filter(e=>{try{return!("function"==typeof e.isDestroyed&&e.isDestroyed())}catch{return!1}}).length}}}class F{constructor(e,t={}){this.viewer=e,this.options={minColor:[0,0,255],maxColor:[255,0,0],opacity:.8,emptyOpacity:.03,showOutline:!0,showEmptyVoxels:!1,wireframeOnly:!1,heightBased:!1,outlineWidth:2,outlineInset:0,outlineInsetMode:"all",outlineRenderMode:"standard",adaptiveOutlines:!1,outlineWidthPreset:"uniform",boxOpacityResolver:null,outlineOpacityResolver:null,adaptiveParams:{neighborhoodRadius:50,densityThreshold:5,cameraDistanceFactor:1,overlapRiskFactor:.3},...t},this._initializeSelectionStrategies(),this.debugRenderer=new z(e),this.adaptiveOutlineController=new D(this.options.adaptiveParams),this.outlineRenderer=new L(e),this.descriptionBuilder=new E,this.renderingEngine=new A(e),this.entityManager=new $(e),u.debug("VoxelRenderer initialized with options:",this.options)}_initializeSelectionStrategies(){this._selectionStrategies={density:new w,coverage:new V,hybrid:new C}}_calculateAdaptiveParams(e,t,i,n){return this.adaptiveOutlineController.calculateAdaptiveParams(e,t,i,n,this.viewer,this.options)}render(e,t,i,n){this.clear(),u.debug("VoxelRenderer.render - Starting render with rendering engine",{voxelDataSize:e.size,bounds:t,grid:i,statistics:n}),this.debugRenderer.renderBoundingBox(t,this.options.debug);const{displayVoxels:o,topNVoxels:a}=this.renderingEngine.processDisplayVoxels(e,t,i,this.options,this._selectVoxelsForRendering.bind(this));this.options.maxRenderVoxels&&e.size>this.options.maxRenderVoxels&&(this._selectionStats=this._selectionStats||{strategy:"none",clippedNonEmpty:0,coverageRatio:1});const r=this.renderingEngine.renderVoxels(o,a,t,i,n,{...this.options,createVoxelDescription:this.descriptionBuilder.createVoxelDescription.bind(this.descriptionBuilder)},this._calculateAdaptiveParams.bind(this),this.outlineRenderer,this.adaptiveOutlineController);return r.forEach(e=>this.entityManager.addEntity(e)),u.info(`Successfully rendered ${r.length} voxels`),r.length}interpolateColor(e,t=null){return R.interpolateColor(e,t,this.options)}_shouldShowBounds(){return this.debugRenderer.shouldShowBounds(this.options?.debug)}clear(){this.entityManager.clear(),this.debugRenderer&&this.debugRenderer.clear()}setVisible(e){this.entityManager.setVisible(e)}_selectVoxelsForRendering(e,t,i,n){const o=this.options.voxelSelectionStrategy||"density";let a,r,s;const l=new Set;switch(this.options.highlightTopN&&this.options.highlightTopN>0&&[...e].sort((e,t)=>t.info.count-e.info.count).slice(0,this.options.highlightTopN).forEach(e=>l.add(e.key)),o){case"coverage":a=this._selectionStrategies.coverage.select(e,t,n,l,this.options).selected,r=e.length-a.length;break;case"hybrid":{const i=this._selectionStrategies.hybrid.select(e,t,n,l,this.options);a=i.selected,r=e.length-a.length,s=i.metadata?.coverageRatio;break}default:{const i=this._selectionStrategies.density.select(e,t,n,l,this.options);a=i.selected,r=i.metadata.clippedCount;break}}return{selectedVoxels:a,strategy:o,clippedNonEmpty:r,coverageRatio:s}}getSelectionStats(){return this._selectionStats||null}get voxelEntities(){return this.entityManager.voxelEntities||[]}_shouldApplyInsetOutline(e){return"topn"!==(this.options.outlineInsetMode||"all")||!!e}}class B{static async fitToBounds(e,t,i={}){try{if(!e||!t)throw new Error("Viewer and bounds are required");if(!B._isValidBounds(t))return u.warn("Invalid bounds provided to ViewFitter:",t),Promise.resolve();const n={paddingPercent:.1,pitchDegrees:-45,headingDegrees:0,duration:2,maximumHeight:5e4,minimumHeight:100,...i};u.debug("ViewFitter: fitting to bounds",t,"with options",n);const o=B._calculateDataRange(t),a=Math.max(o.x,o.y,o.z);return a<10?B._handleMinimalDataRange(e,t,n):a>1e5?B._handleLargeDataRange(e,t,n):B._executeStandardFit(e,t,n,a)}catch(e){throw u.error("ViewFitter: Failed to fit view to bounds:",e),e}}static _calculateDataRange(e){const t=(e.minLat+e.maxLat)/2,i=Math.cos(t*Math.PI/180),n=111e3*(e.maxLon-e.minLon)*i,o=111e3*(e.maxLat-e.minLat),a=Math.max(e.maxAlt-e.minAlt,1);return{x:Math.max(n,1),y:Math.max(o,1),z:a}}static _isValidBounds(e){return!!e&&"number"==typeof e.minLon&&!isNaN(e.minLon)&&"number"==typeof e.maxLon&&!isNaN(e.maxLon)&&"number"==typeof e.minLat&&!isNaN(e.minLat)&&"number"==typeof e.maxLat&&!isNaN(e.maxLat)&&"number"==typeof e.minAlt&&!isNaN(e.minAlt)&&"number"==typeof e.maxAlt&&!isNaN(e.maxAlt)&&e.minLon<=e.maxLon&&e.minLat<=e.maxLat&&e.minAlt<=e.maxAlt}static _handleMinimalDataRange(e,t,i){u.debug("ViewFitter: handling minimal data range");const n=(t.minLon+t.maxLon)/2,o=(t.minLat+t.maxLat)/2,r=Math.max(i.minimumHeight,500);return B._executeCameraMovement(e,{destination:a.Cartesian3.fromDegrees(n,o,r),orientation:{heading:a.Math.toRadians(i.headingDegrees),pitch:a.Math.toRadians(i.pitchDegrees),roll:0},duration:i.duration})}static _handleLargeDataRange(e,t,i){u.debug("ViewFitter: handling large data range");const n=a.Rectangle.fromDegrees(t.minLon,t.minLat,t.maxLon,t.maxLat),o={duration:i.duration,maximumHeight:i.maximumHeight};return new Promise((t,i)=>{try{e.camera.flyTo({destination:n,...o,complete:()=>{u.debug("ViewFitter: large data range fit completed"),t()},cancel:()=>{u.debug("ViewFitter: large data range fit cancelled"),t()}})}catch(e){u.error("ViewFitter: large data range fit failed:",e),i(e)}})}static _executeStandardFit(e,t,i,n){const o=(t.minLon+t.maxLon)/2,r=(t.minLat+t.maxLat)/2,s=Math.max(.05,Math.min(.5,i.paddingPercent))*n,l=B._calculateOptimalCameraHeight(n,s,i);return B._executeCameraMovement(e,{destination:a.Cartesian3.fromDegrees(o,r,l),orientation:{heading:a.Math.toRadians(i.headingDegrees),pitch:a.Math.toRadians(i.pitchDegrees),roll:0},duration:i.duration})}static _calculateOptimalCameraHeight(e,t,i){const n=Math.PI/3,o=Math.abs(a.Math.toRadians(i.pitchDegrees));let r=(e+2*t)/Math.cos(o)/(2*Math.tan(n/2));return r*=1.2,r=Math.max(i.minimumHeight,Math.min(i.maximumHeight,r)),r}static _executeCameraMovement(e,t){return new Promise((i,n)=>{try{const n={...t,complete:()=>{u.debug("ViewFitter: camera movement completed"),i()},cancel:()=>{u.debug("ViewFitter: camera movement cancelled"),i()}};e.camera.flyTo(n)}catch(e){u.error("ViewFitter: camera movement failed:",e),n(e)}})}static createRectangleFromBounds(e){if(!B._isValidBounds(e))throw new Error("Invalid bounds provided");return a.Rectangle.fromDegrees(e.minLon,e.minLat,e.maxLon,e.maxLat)}static calculateCameraPosition(e,t={}){if(!B._isValidBounds(e))throw new Error("Invalid bounds provided");const i={paddingPercent:.1,pitchDegrees:-45,headingDegrees:0,minimumHeight:100,maximumHeight:5e4,...t},n=(e.minLon+e.maxLon)/2,o=(e.minLat+e.maxLat)/2,r=B._calculateDataRange(e),s=Math.max(r.x,r.y,r.z),l=i.paddingPercent*s,d=B._calculateOptimalCameraHeight(s,l,i);return{position:a.Cartesian3.fromDegrees(n,o,d),orientation:{heading:a.Math.toRadians(i.headingDegrees),pitch:a.Math.toRadians(i.pitchDegrees),roll:0},metadata:{dataRange:s,cameraHeight:d,paddingMeters:l}}}}const I=class{constructor(e,t={}){if(!function(e){if(!e)return!1;if(!e.scene||!e.entities||!e.scene.canvas)return!1;const t=e.scene.canvas;return!!(t.getContext("webgl2")||t.getContext("webgl")||t.getContext("experimental-webgl"))}(e))throw new Error("CesiumJS Viewerが無効です");this.viewer=e;const i={...r,...t};this.options=g(y.applyAutoRenderBudget(i)),u.setLogLevel(this.options),this.renderer=new F(this.viewer,this.options),this.viewFitter=new B(this.viewer),this._bounds=null,this._grid=null,this._voxelData=null,this._statistics=null,this._eventHandler=null,this._initializeEventListeners()}async setData(e){if(m(e))try{if(u.debug("Heatbox.setData - 処理開始:",e.length,"個のエンティティ"),u.debug("Step 1: 境界計算"),this._bounds=f.calculateBounds(e),!this._bounds)return u.error("境界計算に失敗"),void this.clear();u.debug("境界計算完了:",this._bounds);let t=this.options.voxelSize||r.voxelSize,i=null;if(this.options.autoVoxelSize&&!this.options.voxelSize)try{u.debug("自動ボクセルサイズ調整開始");const n={autoVoxelSizeMode:this.options.autoVoxelSizeMode,autoVoxelTargetFill:this.options.autoVoxelTargetFill,maxRenderVoxels:this.options.maxRenderVoxels},o=h.estimate(e,this._bounds,this.options.autoVoxelSizeMode,n),a=v.createGrid(this._bounds,o),r=function(e,t){const i={valid:!0,warning:!1,error:null,recommendedSize:null};return e>s?(i.valid=!1,i.error="ボクセル数が上限を超えています",i.recommendedSize=Math.ceil(t*Math.pow(e/s,1/3))):e>3e4&&(i.warning=!0,i.error="推定メモリ使用量が警告値を超えています"),i}(a.totalVoxels,o);!r.valid&&r.recommendedSize?(t=r.recommendedSize,i={enabled:!0,mode:this.options.autoVoxelSizeMode,originalSize:o,finalSize:t,adjusted:!0,reason:`Performance limit exceeded: ${a.totalVoxels} > 50000`},u.info(`Auto-adjusted voxelSize: ${o}m → ${t}m (${a.totalVoxels} voxels)`)):(t=o,i={enabled:!0,mode:this.options.autoVoxelSizeMode,originalSize:o,finalSize:t,adjusted:!1,reason:null},u.info(`Auto-determined voxelSize: ${t}m`))}catch(e){u.warn("Auto voxel size adjustment failed, using default:",e),t=r.voxelSize,i={enabled:!0,adjusted:!1,reason:"Estimation failed, using default size",originalSize:null,finalSize:t}}u.debug("Step 2: グリッド生成 (サイズ:",t,"m)"),this._grid=v.createGrid(this._bounds,t),u.debug("グリッド生成完了:",this._grid),u.debug("Step 3: エンティティ分類"),this._voxelData=b.classifyEntitiesIntoVoxels(e,this._bounds,this._grid),u.debug("エンティティ分類完了:",this._voxelData.size,"個のボクセル"),u.debug("Step 4: 統計計算"),this._statistics=b.calculateStatistics(this._voxelData,this._grid),u.debug("統計情報:",this._statistics),i&&(this._statistics.autoAdjusted=i.adjusted,this._statistics.originalVoxelSize=i.originalSize,this._statistics.finalVoxelSize=i.finalSize,this._statistics.adjustmentReason=i.reason),u.debug("Step 5: 描画");const n=this.renderer.render(this._voxelData,this._bounds,this._grid,this._statistics);if(this._statistics.renderedVoxels=n,u.info("描画完了 - 実際の描画数:",n),this.options.autoView)try{u.debug("Auto view adjustment triggered"),await this.fitView(),u.debug("Auto view adjustment completed")}catch(e){u.warn("Auto view adjustment failed:",e)}u.debug("Heatbox.setData - 処理完了")}catch(e){throw u.error("ヒートマップ作成エラー:",e),this.clear(),e}else this.clear()}async createFromEntities(e){if(!m(e))throw new Error(d);return await this.setData(e),this.getStatistics()}setVisible(e){this.renderer.setVisible(e)}clear(){this.renderer.clear(),this._bounds=null,this._grid=null,this._voxelData=null,this._statistics=null}destroy(){this.clear(),this._eventHandler&&!this._eventHandler.isDestroyed()&&this._eventHandler.destroy(),this._eventHandler=null}dispose(){this.destroy()}getOptions(){return{...this.options}}updateOptions(e){if(this.options=g({...this.options,...e}),this.renderer.options=this.options,this._voxelData){const e=this.renderer.render(this._voxelData,this._bounds,this._grid,this._statistics);this._statistics.renderedVoxels=e}}_initializeEventListeners(){this._eventHandler=new a.ScreenSpaceEventHandler(this.viewer.scene.canvas),this._eventHandler.setInputAction(e=>{const t=this.viewer.scene.pick(e.position);if(a.defined(t)&&t.id&&t.id.properties&&"voxel"===t.id.properties.type){const e=t.id.properties.key,i={x:t.id.properties.x,y:t.id.properties.y,z:t.id.properties.z,count:t.id.properties.count},n=new a.Entity({id:`voxel-${e}`,description:this.renderer.createVoxelDescription(i,e)});this.viewer.selectedEntity=n}},a.ScreenSpaceEventType.LEFT_CLICK)}getStatistics(){if(!this._statistics)return null;const e={...this._statistics},t=this.renderer.getSelectionStats();return t&&(e.selectionStrategy=t.strategy,e.clippedNonEmpty=t.clippedNonEmpty,e.coverageRatio=t.coverageRatio??0),this.options._autoRenderBudget&&(e.renderBudgetTier=this.options._autoRenderBudget.tier,e.autoMaxRenderVoxels=this.options._autoRenderBudget.autoMaxRenderVoxels),"number"==typeof this.options.maxRenderVoxels&&this.options.maxRenderVoxels>0?e.occupancyRatio=Math.min(1,Math.max(0,(e.renderedVoxels||0)/this.options.maxRenderVoxels)):e.occupancyRatio=null,e}getBounds(){return this._bounds}getDebugInfo(){const e={options:{...this.options},bounds:this._bounds,grid:this._grid,statistics:this._statistics};return this.options.autoVoxelSize&&(e.autoVoxelSizeInfo={enabled:this.options.autoVoxelSize,originalSize:this._statistics?.originalVoxelSize,finalSize:this._statistics?.finalVoxelSize,adjusted:this._statistics?.autoAdjusted||!1,reason:this._statistics?.adjustmentReason,dataRange:this._bounds?p(this._bounds):null,estimatedDensity:this._bounds&&this._statistics?this._statistics.totalEntities/(p(this._bounds).x*p(this._bounds).y*p(this._bounds).z):null}),e}async fitView(e=null,t={}){try{const i=e||this._bounds;if(!i)return void u.warn("No bounds available for fitView");const n={...this.options.fitViewOptions,...t};u.debug("fitView called with bounds:",i,"options:",n);const o={paddingPercent:n.paddingPercent,pitchDegrees:n.pitch??n.pitchDegrees,headingDegrees:n.heading??n.headingDegrees,duration:n.duration,maximumHeight:n.maximumHeight,minimumHeight:n.minimumHeight};return await B.fitToBounds(this.viewer,i,o)}catch(e){throw u.error("fitView failed:",e),e}}static filterEntities(e,t){return Array.isArray(e)&&"function"==typeof t?e.filter(t):[]}};return u.info("CesiumJS Heatbox v0.1.9 loaded"),o.default})());
//# sourceMappingURL=cesium-heatbox.umd.min.js.map