{"version":3,"file":"cesium-heatbox.umd.min.js","mappings":"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","sources":["webpack://CesiumHeatbox/webpack/universalModuleDefinition","webpack://CesiumHeatbox/external umd {\"commonjs\":\"cesium\",\"commonjs2\":\"cesium\",\"amd\":\"cesium\",\"root\":\"Cesium\"}","webpack://CesiumHeatbox/webpack/bootstrap","webpack://CesiumHeatbox/webpack/runtime/define property getters","webpack://CesiumHeatbox/webpack/runtime/hasOwnProperty shorthand","webpack://CesiumHeatbox/./src/utils/constants.js","webpack://CesiumHeatbox/./src/utils/logger.js","webpack://CesiumHeatbox/./src/utils/voxelSizeEstimator.js","webpack://CesiumHeatbox/./src/utils/validation.js","webpack://CesiumHeatbox/./src/utils/deviceTierDetector.js","webpack://CesiumHeatbox/./src/core/CoordinateTransformer.js","webpack://CesiumHeatbox/./src/core/VoxelGrid.js","webpack://CesiumHeatbox/./src/core/DataProcessor.js","webpack://CesiumHeatbox/./src/core/selection/SelectionStrategyInterface.js","webpack://CesiumHeatbox/./src/core/selection/DensitySelectionStrategy.js","webpack://CesiumHeatbox/./src/core/selection/CoverageSelectionStrategy.js","webpack://CesiumHeatbox/./src/core/selection/HybridSelectionStrategy.js","webpack://CesiumHeatbox/./src/core/color/ColorMap.js","webpack://CesiumHeatbox/./src/core/voxel/VoxelEntityFactory.js","webpack://CesiumHeatbox/./src/core/voxel/DebugRenderer.js","webpack://CesiumHeatbox/./src/core/outline/AdaptiveOutlineController.js","webpack://CesiumHeatbox/./src/core/outline/OutlineRenderer.js","webpack://CesiumHeatbox/./src/core/voxel/DescriptionBuilder.js","webpack://CesiumHeatbox/./src/core/voxel/VoxelGeometry.js","webpack://CesiumHeatbox/./src/core/voxel/VoxelRenderingEngine.js","webpack://CesiumHeatbox/./src/core/voxel/VoxelEntityManager.js","webpack://CesiumHeatbox/./src/core/VoxelRenderer.js","webpack://CesiumHeatbox/./src/utils/ViewFitter.js","webpack://CesiumHeatbox/./src/index.js","webpack://CesiumHeatbox/./src/Heatbox.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"cesium\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"cesium\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CesiumHeatbox\"] = factory(require(\"cesium\"));\n\telse\n\t\troot[\"CesiumHeatbox\"] = factory(root[\"Cesium\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__50__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__50__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * Constant definitions for CesiumJS Heatbox library.\n * CesiumJS Heatbox ライブラリの定数定義。\n */\n\n/**\n * Default option values.\n * デフォルト設定値。\n */\nexport const DEFAULT_OPTIONS = {\n  voxelSize: 20,\n  opacity: 0.8,\n  emptyOpacity: 0.03,\n  showOutline: true,\n  showEmptyVoxels: false,\n  minColor: [0, 32, 255],\n  maxColor: [255, 64, 0],\n  maxRenderVoxels: 50000,\n  batchMode: 'auto',\n  debug: false, // ログ制御（false で本番モード、true で開発モード、またはオブジェクト）\n  autoVoxelSize: false, // v0.1.4: 自動ボクセルサイズ決定（既存互換性のためfalse）\n  // v0.1.5: 新機能\n  colorMap: 'custom', // 'custom', 'viridis', 'inferno'\n  diverging: false, // 二極性データ対応\n  divergingPivot: 0, // 二極性配色のピボット値\n  highlightTopN: null, // トップN強調表示（null: 無効）\n  highlightStyle: {\n    outlineWidth: 4,\n    boostOpacity: 0.2\n  },\n  // v0.1.6: 枠線重なり対策・柔軟化\n  voxelGap: 0, // ボクセル間ギャップ（メートル）\n  outlineOpacity: 1.0, // 枠線透明度（0-1）\n  // v0.1.6.1: インセット枠線（ADR-0004）\n  outlineInset: 0, // インセット枠線のオフセット距離（メートル、0で無効）\n  outlineInsetMode: 'all', // インセット枠線の適用範囲：'all'（全体） | 'topn'（TopNのみ）\n  enableThickFrames: false, // 厚い枠線表示（インセット枠線とメイン枠線の間をフレームで埋める）\n  \n  // v0.1.7: 適応的枠線制御とエミュレーション専用表示モード（ADR-0005）\n  outlineRenderMode: 'standard', // 'standard' | 'inset' | 'emulation-only' 表示モード\n  adaptiveOutlines: false, // 適応的枠線制御を有効化（オプトイン）\n  outlineWidthPreset: 'uniform', // 'adaptive-density' | 'topn-focus' | 'uniform' プリセット\n  \n  \n  // v0.1.7: 適応的制御パラメータ\n  adaptiveParams: {\n    neighborhoodRadius: 50, // 近傍密度計算の半径（メートル）\n    densityThreshold: 5, // 密度しきい値（エンティティ数/ボクセル）\n    cameraDistanceFactor: 1.0, // カメラ距離補正係数\n    overlapRiskFactor: 0.3 // 重なりリスク補正係数\n  },\n  \n  // v0.1.9: 適応的レンダリング制限とスマート視覚化支援（ADR-0006 Phase 1）\n  renderLimitStrategy: 'density', // 'density' | 'coverage' | 'hybrid' 選択戦略\n  minCoverageRatio: 0.2, // hybrid戦略での層化抽出最小比率（0-1）\n  coverageBinsXY: 'auto', // 層化抽出用格子分割数（'auto' | number）\n  \n  // 自動ボクセルサイズ決定の強化\n  autoVoxelSizeMode: 'basic', // 'basic' | 'occupancy' 自動サイズ計算方式\n  autoVoxelTargetFill: 0.6, // 目標占有率（0-1, occupancyモード用）\n  \n  // Auto Render Budget\n  renderBudgetMode: 'manual', // 'manual' | 'auto' 描画上限制御\n  \n  // 自動視点調整\n  autoView: false, // 自動視点調整有効化\n  fitViewOptions: {\n    paddingPercent: 0.1, // データ範囲の10%パディング\n    pitchDegrees: -30, // ピッチ角度（度）\n    headingDegrees: 0, // ヘディング角度（度）\n    altitudeStrategy: 'auto' // 'auto' | 'manual' 高度計算戦略\n  }\n};\n\n/**\n * Performance limits.\n * パフォーマンス制限値。\n */\nexport const PERFORMANCE_LIMITS = {\n  maxEntities: 5000,\n  maxVoxels: 50000,\n  maxEmptyVoxelsRendered: 10000,\n  minVoxelSize: 5,\n  maxVoxelSize: 1000,\n  warningThreshold: 30000\n};\n\n/**\n * Coordinate-related constants.\n * 座標変換定数。\n */\nexport const COORDINATE_CONSTANTS = {\n  EARTH_RADIUS: 6378137,\n  DEGREES_TO_METERS_LAT: 111000,\n  DEGREES_TO_RADIANS: Math.PI / 180\n};\n\n/**\n * Error message strings.\n * エラーメッセージ。\n */\nexport const ERROR_MESSAGES = {\n  NO_ENTITIES: '対象エンティティがありません',\n  NO_VIEWER: 'CesiumJS Viewerが初期化されていません',\n  INVALID_VIEWER: 'CesiumJS Viewerが無効です',\n  VOXEL_LIMIT_EXCEEDED: 'ボクセル数が上限を超えています',\n  MEMORY_WARNING: '推定メモリ使用量が警告値を超えています',\n  WEBGL_NOT_SUPPORTED: 'WebGLがサポートされていません',\n  INVALID_VOXEL_SIZE: 'ボクセルサイズが無効です'\n};\n\n/**\n * Default statistics values.\n * 統計情報のデフォルト値。\n */\nexport const DEFAULT_STATISTICS = {\n  totalVoxels: 0,\n  renderedVoxels: 0,\n  nonEmptyVoxels: 0,\n  emptyVoxels: 0,\n  totalEntities: 0,\n  minCount: 0,\n  maxCount: 0,\n  averageCount: 0\n};\n\n/**\n * Color-related constants.\n * 色分け関連定数。\n */\nexport const COLOR_CONSTANTS = {\n  MIN_HUE: 240, // 青\n  MAX_HUE: 0,   // 赤\n  SATURATION: 0.8,\n  BRIGHTNESS: 0.7,\n  SATURATION_RANGE: 0.2,\n  BRIGHTNESS_RANGE: 0.3\n};\n","/**\n * Comprehensive logging utility with configurable levels and environment-aware output.\n * 設定可能なレベルと環境対応出力を備えた包括的ログユーティリティ。\n * \n * This logging system provides intelligent log level management based on environment\n * variables (NODE_ENV, DEBUG) and runtime configuration. Supports multiple log levels\n * (ERROR, WARN, INFO, DEBUG) with automatic filtering based on production vs development\n * environments. Essential for debugging and monitoring heatbox operations.\n * \n * このログシステムは、環境変数（NODE_ENV、DEBUG）と実行時設定に基づく\n * インテリジェントなログレベル管理を提供します。複数のログレベル\n * （ERROR、WARN、INFO、DEBUG）をサポートし、本番環境vs開発環境に基づく\n * 自動フィルタリングを行います。ヒートボックス操作のデバッグと監視に必須です。\n * \n * @namespace Logger\n * @since v0.1.0\n * @version 1.2.0 - Enhanced environment detection and configuration support\n */\n\n/**\n * Log level constants.\n * ログレベル定数。\n */\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3\n};\n\n/**\n * Determine current log level.\n * 現在のログレベルを決定します。\n * NODE_ENV=production では ERROR と WARN のみ、DEBUG=true または NODE_ENV=development では全レベル出力。\n */\nfunction getLogLevel() {\n  // 明示的にDEBUG=trueが設定されている場合\n  if (typeof process !== 'undefined' && process.env && process.env.DEBUG === 'true') {\n    return LOG_LEVELS.DEBUG;\n  }\n  \n  // NODE_ENVをチェック\n  if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production') {\n    return LOG_LEVELS.WARN;\n  }\n  \n  // デフォルトは開発モード（全ログ出力）\n  return LOG_LEVELS.DEBUG;\n}\n\nlet currentLogLevel = getLogLevel();\n\n/**\n * Common logging utility.\n * ログ出力の共通ユーティリティ。\n */\nexport const Logger = {\n  /**\n   * Error log (always output).\n   * エラーログ（常に出力）。\n   * @param {...any} args - Log arguments / ログ引数\n   */\n  error(...args) {\n    if (currentLogLevel >= LOG_LEVELS.ERROR) {\n      console.error('[Heatbox ERROR]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * Warning log.\n   * 警告ログ。\n   * @param {...any} args - Log arguments / ログ引数\n   */\n  warn(...args) {\n    if (currentLogLevel >= LOG_LEVELS.WARN) {\n      console.warn('[Heatbox WARN]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * Info log.\n   * 情報ログ。\n   * @param {...any} args - Log arguments / ログ引数\n   */\n  info(...args) {\n    if (currentLogLevel >= LOG_LEVELS.INFO) {\n      console.log('[Heatbox INFO]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * Debug log.\n   * デバッグログ。\n   * @param {...any} args - Log arguments / ログ引数\n   */\n  debug(...args) {\n    if (currentLogLevel >= LOG_LEVELS.DEBUG) {\n      console.log('[Heatbox DEBUG]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * Control log level by options.\n   * オプション設定によるログレベル制御。\n   * v0.1.5: debug オプションがオブジェクトの場合に対応。\n   * @param {Object} options - Options / オプション\n   */\n  setLogLevel(options) {\n    if (options && options.debug !== undefined) {\n      if (typeof options.debug === 'boolean') {\n        // debug: true → 詳細ログ、debug: false → 重要ログのみ\n        currentLogLevel = options.debug ? LOG_LEVELS.DEBUG : LOG_LEVELS.WARN;\n      } else if (typeof options.debug === 'object' && options.debug !== null) {\n        // オブジェクトの場合はログレベルをDEBUGに設定（境界表示制御は別途処理）\n        currentLogLevel = LOG_LEVELS.DEBUG;\n      }\n    }\n    return currentLogLevel;\n  }\n};\n\n/**\n * Wrapper functions for backward compatibility.\n * 既存の console.log 置き換え用のラッパー関数群。\n */\nexport const log = Logger.debug;\nexport const warn = Logger.warn;\nexport const error = Logger.error;\nexport const info = Logger.info;\n","/**\n * Voxel Size Estimator for automatic voxel size calculation.\n * ボクセルサイズ自動計算用推定機\n */\n\nimport { Logger } from './logger.js';\nimport { PERFORMANCE_LIMITS } from './constants.js';\n\n/**\n * Voxel Size Estimator class for calculating optimal voxel sizes\n * 最適なボクセルサイズを計算するための推定機クラス\n */\nexport class VoxelSizeEstimator {\n  /**\n   * Estimate optimal voxel size\n   * 最適なボクセルサイズを推定\n   * @param {Array} data - Data points / データポイント\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {string} mode - Estimation mode: 'basic' | 'occupancy' / 推定モード\n   * @param {Object} options - Estimation options / 推定オプション\n   * @returns {number} Estimated voxel size in meters / 推定ボクセルサイズ（メートル）\n   */\n  static estimate(data, bounds, mode = 'basic', options = {}) {\n    try {\n      // Support backward compatibility with entityCount in options\n      const entityCount = options.entityCount !== undefined ? options.entityCount : (data ? data.length : 0);\n      \n      if (mode === 'occupancy') {\n        return VoxelSizeEstimator.estimateByOccupancy(bounds, entityCount, options);\n      } else {\n        return VoxelSizeEstimator.estimateBasic(bounds, entityCount);\n      }\n    } catch (error) {\n      Logger.warn('Voxel size estimation failed:', error);\n      return 20; // デフォルトサイズ\n    }\n  }\n\n  /**\n   * Basic voxel size estimation (existing algorithm)\n   * 基本的なボクセルサイズ推定（既存アルゴリズム）\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @param {number} entityCount - Number of entities / エンティティ数\n   * @returns {number} Estimated voxel size in meters / 推定ボクセルサイズ（メートル）\n   */\n  static estimateBasic(bounds, entityCount) {\n    // 1. データ範囲（X/Y/Z軸の物理的範囲）を計算\n    const dataRange = VoxelSizeEstimator.calculateDataRange(bounds);\n    \n    // 2. エンティティ密度を推定\n    const volume = dataRange.x * dataRange.y * Math.max(dataRange.z, 10); // 最小高度差10m\n    const density = entityCount / volume; // エンティティ/立方メートル\n    \n    // 3. 密度に応じて適切なボクセルサイズを推定\n    // - 高密度: 細かいサイズ（10-20m）\n    // - 中密度: 標準サイズ（20-50m）\n    // - 低密度: 粗いサイズ（50-100m）\n    let estimatedSize;\n    \n    if (density > 0.001) {\n      // 高密度：細かいサイズ\n      estimatedSize = Math.max(10, Math.min(20, 20 / Math.sqrt(density * 1000)));\n    } else if (density > 0.0001) {\n      // 中密度：標準サイズ\n      estimatedSize = Math.max(20, Math.min(50, 50 / Math.sqrt(density * 10000)));\n    } else {\n      // 低密度：粗いサイズ\n      estimatedSize = Math.max(50, Math.min(100, 100 / Math.sqrt(density * 100000)));\n    }\n    \n    // 制限値内に収める\n    estimatedSize = Math.max(PERFORMANCE_LIMITS.minVoxelSize, \n                            Math.min(PERFORMANCE_LIMITS.maxVoxelSize, estimatedSize));\n    \n    Logger.debug(`Basic voxel size estimated: ${estimatedSize}m (density: ${density}, volume: ${volume})`);\n    return Math.round(estimatedSize);\n  }\n\n  /**\n   * Occupancy-based voxel size estimation with iterative approximation\n   * 占有率ベースのボクセルサイズ推定（反復近似）\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @param {number} entityCount - Number of entities / エンティティ数\n   * @param {Object} options - Calculation options / 計算オプション\n   * @returns {number} Estimated voxel size in meters / 推定ボクセルサイズ（メートル）\n   */\n  static estimateByOccupancy(bounds, entityCount, options) {\n    const dataRange = VoxelSizeEstimator.calculateDataRange(bounds);\n    const maxRenderVoxels = options.maxRenderVoxels || 50000;\n    const targetFill = options.autoVoxelTargetFill || 0.6;\n    const maxIterations = 10;\n    const tolerance = 0.05; // 5%の許容誤差\n    \n    // 初期推定値（基本アルゴリズムから）\n    let currentSize = VoxelSizeEstimator.estimateBasic(bounds, entityCount);\n    \n    Logger.debug(`Starting occupancy-based estimation: N=${entityCount}, target=${targetFill}, maxVoxels=${maxRenderVoxels}`);\n    \n    for (let iteration = 0; iteration < maxIterations; iteration++) {\n      // 現在のサイズでの総ボクセル数を計算\n      const numVoxelsX = Math.ceil(dataRange.x / currentSize);\n      const numVoxelsY = Math.ceil(dataRange.y / currentSize);\n      const numVoxelsZ = Math.ceil(dataRange.z / currentSize);\n      const totalVoxels = numVoxelsX * numVoxelsY * numVoxelsZ;\n      \n      // 期待占有セル数の計算: E[occupied] ≈ M × (1 - exp(-N/M))\n      const expectedOccupied = totalVoxels * (1 - Math.exp(-entityCount / totalVoxels));\n      \n      // 現在の占有率\n      const currentFill = Math.min(expectedOccupied / maxRenderVoxels, 1.0);\n      \n      Logger.debug(`Iteration ${iteration}: size=${currentSize.toFixed(1)}m, totalVoxels=${totalVoxels}, expectedOccupied=${expectedOccupied.toFixed(0)}, fill=${currentFill.toFixed(3)}`);\n      \n      // 収束判定\n      const fillError = Math.abs(currentFill - targetFill);\n      if (fillError < tolerance) {\n        Logger.debug(`Converged at iteration ${iteration}: size=${currentSize.toFixed(1)}m, fill=${currentFill.toFixed(3)}`);\n        break;\n      }\n      \n      // サイズ調整（Newton法的なアプローチ）\n      if (currentFill > targetFill) {\n        // 占有率が高すぎる → サイズを大きくしてボクセル数を減らす\n        currentSize *= Math.pow(currentFill / targetFill, 0.3);\n      } else {\n        // 占有率が低すぎる → サイズを小さくしてボクセル数を増やす\n        currentSize *= Math.pow(currentFill / targetFill, 0.3);\n      }\n      \n      // 制限値内に収める\n      currentSize = Math.max(PERFORMANCE_LIMITS.minVoxelSize, \n                            Math.min(PERFORMANCE_LIMITS.maxVoxelSize, currentSize));\n    }\n    \n    const finalSize = Math.round(currentSize);\n    Logger.info(`Occupancy-based voxel size: ${finalSize}m (target fill: ${targetFill})`);\n    \n    return finalSize;\n  }\n\n  /**\n   * Calculate data range from bounds\n   * 境界からデータ範囲を計算\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @returns {Object} Data range {x, y, z} in meters / データ範囲（メートル）\n   */\n  static calculateDataRange(bounds) {\n    const minLon = bounds.west * 180 / Math.PI; // ラジアンから度に変換\n    const maxLon = bounds.east * 180 / Math.PI;\n    const minLat = bounds.south * 180 / Math.PI;\n    const maxLat = bounds.north * 180 / Math.PI;\n    const minAlt = bounds.minimumHeight || 0;\n    const maxAlt = bounds.maximumHeight || 100;\n    \n    // 経度・緯度範囲をメートルに概算変換\n    // 緯度1度 ≈ 111,000m、経度は緯度により変動するが中央緯度で近似\n    const centerLat = (minLat + maxLat) / 2;\n    const lonRangeMeters = (maxLon - minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);\n    const latRangeMeters = (maxLat - minLat) * 111000;\n    const altRangeMeters = Math.abs(maxAlt - minAlt);\n    \n    return {\n      x: Math.abs(lonRangeMeters),\n      y: Math.abs(latRangeMeters),\n      z: Math.abs(altRangeMeters)\n    };\n  }\n\n  /**\n   * Get estimation metadata\n   * 推定メタデータを取得\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @param {number} entityCount - Number of entities / エンティティ数\n   * @param {string} mode - Estimation mode / 推定モード\n   * @returns {Object} Estimation metadata / 推定メタデータ\n   */\n  static getEstimationMetadata(bounds, entityCount, mode) {\n    const dataRange = VoxelSizeEstimator.calculateDataRange(bounds);\n    const volume = dataRange.x * dataRange.y * Math.max(dataRange.z, 10);\n    const density = entityCount / volume;\n    \n    return {\n      mode,\n      entityCount,\n      dataRange,\n      volume,\n      density,\n      densityCategory: density > 0.001 ? 'high' : density > 0.0001 ? 'medium' : 'low'\n    };\n  }\n}\n","/**\n * Validation utility functions.\n * バリデーション関連のユーティリティ関数。\n */\n\nimport * as Cesium from 'cesium';\nimport { PERFORMANCE_LIMITS, ERROR_MESSAGES } from './constants.js';\nimport { Logger } from './logger.js';\nimport { VoxelSizeEstimator } from './voxelSizeEstimator.js';\n\n/**\n * Check whether a CesiumJS Viewer is valid.\n * CesiumJS Viewerが有効かチェックします。\n * @param {Object} viewer - CesiumJS Viewer\n * @returns {boolean} true if valid / 有効な場合は true\n */\nexport function isValidViewer(viewer) {\n  if (!viewer) {\n    return false;\n  }\n  \n  // 必要なプロパティが存在するかチェック\n  if (!viewer.scene || !viewer.entities || !viewer.scene.canvas) {\n    return false;\n  }\n  \n  // WebGL対応チェック（WebGL2 も許容）\n  const canvas = viewer.scene.canvas;\n  const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  if (!gl) {\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Check whether the entity array is valid.\n * エンティティ配列が有効かチェックします。\n * @param {Array} entities - Entity array / エンティティ配列\n * @returns {boolean} true if valid / 有効な場合は true\n */\nexport function isValidEntities(entities) {\n  if (!Array.isArray(entities)) {\n    return false;\n  }\n  \n  if (entities.length === 0) {\n    return false;\n  }\n  \n  if (entities.length > PERFORMANCE_LIMITS.maxEntities) {\n    Logger.warn(`エンティティ数が推奨値(${PERFORMANCE_LIMITS.maxEntities})を超えています: ${entities.length}`);\n  }\n  \n  return true;\n}\n\n/**\n * Check whether the voxel size is valid.\n * ボクセルサイズが有効かチェックします。\n * @param {number} voxelSize - Voxel size / ボクセルサイズ\n * @returns {boolean} true if valid / 有効な場合は true\n */\nexport function isValidVoxelSize(voxelSize) {\n  if (typeof voxelSize !== 'number' || isNaN(voxelSize)) {\n    return false;\n  }\n  \n  if (voxelSize < PERFORMANCE_LIMITS.minVoxelSize || voxelSize > PERFORMANCE_LIMITS.maxVoxelSize) {\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Check whether an entity has a valid position.\n * エンティティが有効な位置情報を持つかチェックします。\n * @param {Object} entity - Cesium Entity\n * @returns {boolean} true if valid / 有効な場合は true\n */\nexport function hasValidPosition(entity) {\n  if (!entity || !entity.position) {\n    return false;\n  }\n  \n  // Propertyベースの位置情報の場合\n  if (typeof entity.position.getValue === 'function') {\n    const position = entity.position.getValue(Cesium.JulianDate.now());\n    return position && !isNaN(position.x) && !isNaN(position.y) && !isNaN(position.z);\n  }\n  \n  // 直接Cartesian3の場合\n  if (entity.position.x !== undefined) {\n    return !isNaN(entity.position.x) && !isNaN(entity.position.y) && !isNaN(entity.position.z);\n  }\n  \n  return false;\n}\n\n/**\n * Validate that total voxel count is within limits.\n * 処理するボクセル数が制限内かチェックします。\n * @param {number} totalVoxels - Total voxels / 総ボクセル数\n * @param {number} voxelSize - Voxel size / ボクセルサイズ\n * @returns {Object} Validation result / チェック結果\n */\nexport function validateVoxelCount(totalVoxels, voxelSize) {\n  const result = {\n    valid: true,\n    warning: false,\n    error: null,\n    recommendedSize: null\n  };\n  \n  if (totalVoxels > PERFORMANCE_LIMITS.maxVoxels) {\n    result.valid = false;\n    result.error = ERROR_MESSAGES.VOXEL_LIMIT_EXCEEDED;\n    result.recommendedSize = Math.ceil(voxelSize * Math.pow(totalVoxels / PERFORMANCE_LIMITS.maxVoxels, 1/3));\n  } else if (totalVoxels > PERFORMANCE_LIMITS.warningThreshold) {\n    result.warning = true;\n    result.error = ERROR_MESSAGES.MEMORY_WARNING;\n  }\n  \n  return result;\n}\n\n/**\n * Validate and normalize options.\n * オプションを検証して正規化します。\n * v0.1.5: batchMode 非推奨化と新機能バリデーションを追加。\n * @param {Object} options - User-specified options / ユーザー指定のオプション\n * @returns {Object} Normalized options / 正規化されたオプション\n */\nexport function validateAndNormalizeOptions(options = {}) {\n  const normalized = { ...options };\n  \n  // v0.1.5: batchMode非推奨化警告（debug時のみ）\n  if (normalized.batchMode && normalized.debug) {\n    Logger.warn('batchMode option is deprecated and will be removed in v1.0.0. It is currently ignored.');\n  }\n  \n  // ボクセルサイズのバリデーション\n  if (normalized.voxelSize !== undefined && !isValidVoxelSize(normalized.voxelSize)) {\n    throw new Error(`${ERROR_MESSAGES.INVALID_VOXEL_SIZE}: ${normalized.voxelSize}`);\n  }\n  \n  // 透明度のバリデーション\n  if (normalized.opacity !== undefined) {\n    normalized.opacity = Math.max(0, Math.min(1, normalized.opacity));\n  }\n  \n  if (normalized.emptyOpacity !== undefined) {\n    normalized.emptyOpacity = Math.max(0, Math.min(1, normalized.emptyOpacity));\n  }\n  \n  // 色のバリデーション\n  if (normalized.minColor && Array.isArray(normalized.minColor) && normalized.minColor.length === 3) {\n    normalized.minColor = normalized.minColor.map(c => Math.max(0, Math.min(255, Math.floor(c))));\n  }\n  \n  if (normalized.maxColor && Array.isArray(normalized.maxColor) && normalized.maxColor.length === 3) {\n    normalized.maxColor = normalized.maxColor.map(c => Math.max(0, Math.min(255, Math.floor(c))));\n  }\n  \n  // v0.1.5: 新機能のバリデーション\n  if (normalized.colorMap !== undefined) {\n    const validColorMaps = ['custom', 'viridis', 'inferno'];\n    if (!validColorMaps.includes(normalized.colorMap)) {\n      Logger.warn(`Invalid colorMap: ${normalized.colorMap}. Using 'custom'.`);\n      normalized.colorMap = 'custom';\n    }\n  }\n  \n  if (normalized.highlightTopN !== undefined && normalized.highlightTopN !== null) {\n    if (typeof normalized.highlightTopN !== 'number' || normalized.highlightTopN <= 0) {\n      Logger.warn(`Invalid highlightTopN: ${normalized.highlightTopN}. Must be a positive number.`);\n      normalized.highlightTopN = null;\n    }\n  }\n  \n  // v0.1.6: 枠線重なり対策のバリデーション\n  if (normalized.voxelGap !== undefined) {\n    normalized.voxelGap = Math.max(0, Math.min(100, parseFloat(normalized.voxelGap) || 0));\n  }\n  \n  if (normalized.outlineOpacity !== undefined) {\n    normalized.outlineOpacity = Math.max(0, Math.min(1, parseFloat(normalized.outlineOpacity) || 1));\n  }\n  \n\n  // v0.1.6.1 (ADR-0004): インセット枠線\n  if (normalized.outlineInset !== undefined) {\n    const v = parseFloat(normalized.outlineInset);\n    normalized.outlineInset = isNaN(v) || v < 0 ? 0 : v;\n  }\n  if (normalized.outlineInsetMode !== undefined) {\n    const validModes = ['all', 'topn'];\n    if (!validModes.includes(normalized.outlineInsetMode)) {\n      Logger.warn(`Invalid outlineInsetMode: ${normalized.outlineInsetMode}. Using 'all'.`);\n      normalized.outlineInsetMode = 'all';\n    }\n  }\n\n  // v0.1.6.1: インセット枠線（ADR-0004）\n  if (normalized.outlineInset !== undefined) {\n    // 0〜100mの範囲にクランプ（安全上限）\n    const inset = parseFloat(normalized.outlineInset);\n    normalized.outlineInset = Math.max(0, Math.min(100, isNaN(inset) ? 0 : inset));\n  }\n  \n  if (normalized.outlineInsetMode !== undefined) {\n    const validInsetModes = ['all', 'topn'];\n    if (!validInsetModes.includes(normalized.outlineInsetMode)) {\n      Logger.warn(`Invalid outlineInsetMode: ${normalized.outlineInsetMode}. Using 'all'.`);\n      normalized.outlineInsetMode = 'all';\n    }\n  }\n  \n  // 厚い枠線表示\n  if (normalized.enableThickFrames !== undefined) {\n    normalized.enableThickFrames = Boolean(normalized.enableThickFrames);\n  }\n  \n  // v0.1.9: 適応的レンダリング制限のバリデーション\n  if (normalized.renderLimitStrategy !== undefined) {\n    const validStrategies = ['density', 'coverage', 'hybrid'];\n    if (!validStrategies.includes(normalized.renderLimitStrategy)) {\n      Logger.warn(`Invalid renderLimitStrategy: ${normalized.renderLimitStrategy}. Using 'density'.`);\n      normalized.renderLimitStrategy = 'density';\n    }\n  }\n  if (normalized.minCoverageRatio !== undefined) {\n    const v = parseFloat(normalized.minCoverageRatio);\n    normalized.minCoverageRatio = isNaN(v) ? 0.2 : Math.max(0, Math.min(1, v));\n  }\n  if (normalized.coverageBinsXY !== undefined) {\n    const v = normalized.coverageBinsXY;\n    if (v !== 'auto') {\n      const n = parseInt(v, 10);\n      if (!Number.isFinite(n) || n <= 0) {\n        Logger.warn(`Invalid coverageBinsXY: ${v}. Using 'auto'.`);\n        normalized.coverageBinsXY = 'auto';\n      } else {\n        normalized.coverageBinsXY = n;\n      }\n    }\n  }\n  \n  // v0.1.9: 自動ボクセルサイズ決定の強化\n  if (normalized.autoVoxelSizeMode !== undefined) {\n    const validModes = ['basic', 'occupancy'];\n    if (!validModes.includes(normalized.autoVoxelSizeMode)) {\n      Logger.warn(`Invalid autoVoxelSizeMode: ${normalized.autoVoxelSizeMode}. Using 'basic'.`);\n      normalized.autoVoxelSizeMode = 'basic';\n    }\n  }\n  if (normalized.autoVoxelTargetFill !== undefined) {\n    const v = parseFloat(normalized.autoVoxelTargetFill);\n    normalized.autoVoxelTargetFill = isNaN(v) ? 0.6 : Math.max(0, Math.min(1, v));\n  }\n  \n  // v0.1.9: Auto Render Budget\n  if (normalized.renderBudgetMode !== undefined) {\n    const validModes = ['manual', 'auto'];\n    if (!validModes.includes(normalized.renderBudgetMode)) {\n      Logger.warn(`Invalid renderBudgetMode: ${normalized.renderBudgetMode}. Using 'manual'.`);\n      normalized.renderBudgetMode = 'manual';\n    }\n  }\n  \n  // v0.1.10: fitViewOptions API統一 (ADR-0008 Phase 4)\n  if (normalized.fitViewOptions !== undefined) {\n    const f = normalized.fitViewOptions || {};\n    const padding = parseFloat(f.paddingPercent);\n    // 後方互換性: pitch/heading → pitchDegrees/headingDegrees\n    const pitch = parseFloat(f.pitchDegrees ?? f.pitch);\n    const heading = parseFloat(f.headingDegrees ?? f.heading);\n    const altitudeStrategy = f.altitudeStrategy;\n    \n    // 旧API使用時の移行警告\n    if (f.pitch !== undefined || f.heading !== undefined) {\n      Logger.warn('fitViewOptions.pitch/heading は非推奨です。pitchDegrees/headingDegreesを使用してください。');\n    }\n    \n    normalized.fitViewOptions = {\n      paddingPercent: Number.isFinite(padding) ? Math.max(0, Math.min(1, padding)) : 0.1,\n      pitchDegrees: Number.isFinite(pitch) ? Math.max(-90, Math.min(0, pitch)) : -30,\n      headingDegrees: Number.isFinite(heading) ? heading : 0,\n      altitudeStrategy: altitudeStrategy === 'manual' ? 'manual' : 'auto'\n    };\n  }\n  \n  return normalized;\n}\n\n/**\n * Estimate initial voxel size based on data bounds and entity count.\n * データ範囲とエンティティ数に基づいて初期ボクセルサイズを推定します。\n * @param {Object} bounds - Bounds info / 境界情報\n * @param {number} entityCount - Number of entities / エンティティ数\n * @param {Object} options - Calculation options / 計算オプション\n * @returns {number} Estimated voxel size in meters / 推定ボクセルサイズ（メートル）\n * @deprecated Use VoxelSizeEstimator.estimate() instead\n */\nexport function estimateInitialVoxelSize(bounds, entityCount, options = {}) {\n  const mode = options.autoVoxelSizeMode || 'basic';\n  return VoxelSizeEstimator.estimate(null, bounds, mode, { ...options, entityCount });\n}\n\n/**\n * Calculate data range from bounds\n * 境界からデータ範囲を計算\n * @param {Object} bounds - Bounds info / 境界情報\n * @returns {Object} Data range {x, y, z} in meters / データ範囲（メートル）\n * @deprecated Use VoxelSizeEstimator.calculateDataRange() instead\n */\nexport function calculateDataRange(bounds) {\n  return VoxelSizeEstimator.calculateDataRange(bounds);\n}\n\n// Note: Occupancy-based voxel size estimation was moved to VoxelSizeEstimator.\n// This module intentionally avoids duplicating estimation logic.\n","/**\n * Device tier detection for Auto Render Budget.\n * 端末ティア検出（Auto Render Budget用）\n */\n\nimport { Logger } from './logger.js';\nimport { PERFORMANCE_LIMITS } from './constants.js';\n\n/**\n * Device tier constants\n * 端末ティア定数\n */\nconst DEVICE_TIER_RANGES = {\n  low: { min: 8000, max: 12000 },\n  mid: { min: 20000, max: 35000 },\n  high: { min: 40000, max: 50000 }\n};\n\n/**\n * Device Tier Detector class for performance tier detection\n * 性能ティア検出用のデバイスティア検出器クラス\n */\nexport class DeviceTierDetector {\n  /**\n   * Detect device performance tier\n   * デバイス性能ティアを検出\n   * @returns {Object} { tier: string, maxRenderVoxels: number, metadata: Object }\n   */\n  static detect() {\n    try {\n      const webglInfo = DeviceTierDetector._getWebGLInfo();\n      const deviceInfo = DeviceTierDetector._getDeviceInfo();\n      \n      // ティア判定ロジック\n      let tier = 'mid'; // デフォルトは中ティア\n      let detectionMethod = 'fallback';\n      \n      // Primary: deviceMemory利用可能時（Chrome系のみ）\n      if (deviceInfo.deviceMemory !== null) {\n        if (deviceInfo.deviceMemory <= 4) {\n          tier = 'low';\n        } else if (deviceInfo.deviceMemory <= 8) {\n          tier = 'mid';\n        } else {\n          tier = 'high';\n        }\n        detectionMethod = 'deviceMemory';\n      } \n      // Fallback: hardwareConcurrency + 画面解像度\n      else if (deviceInfo.hardwareConcurrency !== null) {\n        const baseScore = deviceInfo.hardwareConcurrency;\n        const resolutionFactor = Math.min(deviceInfo.screenPixels / 2073600, 2.0); // 1920x1080 = 2073600を基準\n        const adjustedScore = baseScore * resolutionFactor;\n        \n        if (adjustedScore <= 4) {\n          tier = 'low';\n        } else if (adjustedScore <= 8) {\n          tier = 'mid';\n        } else {\n          tier = 'high';\n        }\n        detectionMethod = 'hardwareConcurrency+resolution';\n      }\n      \n      // WebGL制限による追加調整\n      // 純粋なフォールバック（環境情報が一切取れない）ケースではダウングレードしない\n      if (\n        detectionMethod !== 'fallback' &&\n        webglInfo.maxTextureSize > 0 &&\n        (webglInfo.maxTextureSize < 4096 || !webglInfo.webgl2)\n      ) {\n        tier = tier === 'high' ? 'mid' : 'low';\n        detectionMethod += '+webglLimits';\n      }\n      \n      // ティアに応じた上限値を計算\n      const range = DEVICE_TIER_RANGES[tier];\n      const maxRenderVoxels = Math.min(\n        Math.floor((range.min + range.max) / 2),\n        PERFORMANCE_LIMITS.maxVoxels\n      );\n      \n      Logger.debug(`Device tier detected: ${tier} (${detectionMethod}), maxRenderVoxels: ${maxRenderVoxels}`);\n      \n      return {\n        tier,\n        maxRenderVoxels,\n        metadata: {\n          detectionMethod,\n          deviceInfo,\n          webglInfo,\n          tierRange: range\n        }\n      };\n      \n    } catch (error) {\n      Logger.warn('Device tier detection failed, using default mid tier:', error);\n      return {\n        tier: 'mid',\n        maxRenderVoxels: Math.min(25000, PERFORMANCE_LIMITS.maxVoxels),\n        metadata: {\n          detectionMethod: 'error-fallback',\n          deviceInfo: null,\n          webglInfo: null,\n          error: error.message\n        }\n      };\n    }\n  }\n\n  /**\n   * Apply auto render budget to options\n   * Auto Render Budgetをオプションに適用\n   * @param {Object} options - 設定オプション\n   * @returns {Object} 更新された設定オプション\n   */\n  static applyAutoRenderBudget(options) {\n    if (options.renderBudgetMode !== 'auto' && options.maxRenderVoxels !== 'auto') {\n      return options; // 手動モードの場合は変更なし\n    }\n    \n    const detection = DeviceTierDetector.detect();\n    \n    const updatedOptions = {\n      ...options,\n      maxRenderVoxels: detection.maxRenderVoxels,\n      // 統計情報用\n      _autoRenderBudget: {\n        tier: detection.tier,\n        detectionMethod: detection.metadata.detectionMethod,\n        autoMaxRenderVoxels: detection.maxRenderVoxels\n      }\n    };\n    \n    Logger.info(`Auto Render Budget applied: ${detection.tier} tier, maxRenderVoxels: ${detection.maxRenderVoxels}`);\n    \n    return updatedOptions;\n  }\n\n  /**\n   * Get WebGL capability information\n   * WebGL能力情報を取得\n   * @returns {Object} WebGL情報オブジェクト\n   * @private\n   */\n  static _getWebGLInfo() {\n    try {\n      // Avoid triggering jsdom's unimplemented getContext error by probing first\n      if (typeof document === 'undefined' || typeof document.createElement !== 'function') {\n        return {\n          webgl2: false,\n          maxTextureSize: 0,\n          maxRenderbufferSize: 0\n        };\n      }\n\n      const canvas = document.createElement('canvas');\n      const canGetContext = canvas && typeof canvas.getContext === 'function';\n      if (!canGetContext) {\n        return {\n          webgl2: false,\n          maxTextureSize: 0,\n          maxRenderbufferSize: 0\n        };\n      }\n\n      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');\n      \n      if (!gl) {\n        return {\n          webgl2: false,\n          maxTextureSize: 0,\n          maxRenderbufferSize: 0\n        };\n      }\n      \n      const info = {\n        webgl2: !!canvas.getContext && !!canvas.getContext('webgl2'),\n        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),\n        maxRenderbufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)\n      };\n      \n      // クリーンアップ\n      canvas.remove();\n      \n      return info;\n    } catch (error) {\n      Logger.warn('WebGL info detection failed:', error);\n      return {\n        webgl2: false,\n        maxTextureSize: 0,\n        maxRenderbufferSize: 0\n      };\n    }\n  }\n\n  /**\n   * Get device information\n   * 端末情報を取得\n   * @returns {Object} 端末情報オブジェクト\n   * @private\n   */\n  static _getDeviceInfo() {\n    // ここでは例外を握りつぶさず、detect() 側で捕捉して error-fallback にする\n    if (typeof navigator === 'undefined') {\n      throw new Error('navigator is undefined');\n    }\n    const dpr = (typeof window !== 'undefined' && typeof window.devicePixelRatio === 'number') ? window.devicePixelRatio : 1;\n    const width = (typeof screen !== 'undefined' && typeof screen.width === 'number') ? screen.width : 1920;\n    const height = (typeof screen !== 'undefined' && typeof screen.height === 'number') ? screen.height : 1080;\n    const nav = navigator;\n\n    return {\n      deviceMemory: (nav && typeof nav.deviceMemory !== 'undefined') ? nav.deviceMemory : null,\n      hardwareConcurrency: (nav && typeof nav.hardwareConcurrency !== 'undefined') ? nav.hardwareConcurrency : null,\n      devicePixelRatio: dpr,\n      screenPixels: width * height * Math.pow(dpr, 2),\n      userAgent: (nav && nav.userAgent) ? nav.userAgent : ''\n    };\n  }\n}\n\n// 後方互換性のためのエイリアス\nexport function detectDeviceTier() {\n  const result = DeviceTierDetector.detect();\n  return {\n    tier: result.tier,\n    maxRenderVoxels: result.maxRenderVoxels,\n    detectionMethod: result.metadata.detectionMethod,\n    deviceInfo: result.metadata.deviceInfo,\n    webglInfo: result.metadata.webglInfo\n  };\n}\n\nexport function applyAutoRenderBudget(options) {\n  return DeviceTierDetector.applyAutoRenderBudget(options);\n}\n","/**\n * Coordinate transformation utilities (simple implementation).\n * 座標変換を担当するクラス（シンプル実装）。\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../utils/logger.js';\n\n/**\n * Comprehensive coordinate transformation utilities for geospatial data processing.\n * 地理空間データ処理用の包括的座標変換ユーティリティ。\n * \n * This utility class provides essential coordinate transformation and bounds calculation\n * functions for processing geospatial entity data in CesiumJS environments. Handles\n * conversions between different coordinate systems, calculates 3D spatial bounds,\n * and provides robust error handling for invalid coordinate data.\n * \n * このユーティリティクラスは、CesiumJS環境で地理空間エンティティデータを処理するための\n * 重要な座標変換と境界計算機能を提供します。異なる座標系間の変換を処理し、3D空間境界を\n * 計算し、無効な座標データに対する堅牢なエラーハンドリングを提供します。\n * \n * @since v0.1.0\n * @version 1.0.0 - Stable coordinate transformation utilities\n */\nexport class CoordinateTransformer {\n  /**\n   * Calculate comprehensive 3D spatial bounds from Cesium entity array.\n   * Cesiumエンティティ配列から包括的な3D空間境界を計算します。\n   * \n   * This method analyzes all provided entities to determine the minimum and maximum\n   * longitude, latitude, and altitude values, creating a bounding box that encompasses\n   * the entire dataset. Handles various entity position formats and provides robust\n   * error handling for invalid or missing position data.\n   * \n   * このメソッドは提供された全エンティティを分析して最小・最大の経度、緯度、高度値を\n   * 決定し、データセット全体を包含するバウンディングボックスを作成します。様々な\n   * エンティティ位置形式を処理し、無効または欠落している位置データに対する\n   * 堅牢なエラーハンドリングを提供します。\n   * \n   * @param {Cesium.Entity[]} entities - Array of Cesium entities with position information / 位置情報を持つCesiumエンティティの配列\n   * @returns {Object} Comprehensive bounds information / 包括的な境界情報\n   * @returns {number} returns.minLon - Minimum longitude in degrees / 最小経度（度）\n   * @returns {number} returns.maxLon - Maximum longitude in degrees / 最大経度（度）\n   * @returns {number} returns.minLat - Minimum latitude in degrees / 最小緯度（度）\n   * @returns {number} returns.maxLat - Maximum latitude in degrees / 最大緯度（度）\n   * @returns {number} returns.minAlt - Minimum altitude in meters / 最小高度（メートル）\n   * @returns {number} returns.maxAlt - Maximum altitude in meters / 最大高度（メートル）\n   * @returns {number} returns.validEntityCount - Number of entities with valid positions / 有効な位置を持つエンティティ数\n   * @throws {Error} Throws error if entity array is empty or invalid / エンティティ配列が空または無効な場合はエラーを投げます\n   * \n   * @example\n   * // Calculate bounds for visualization / 可視化用境界計算\n   * const entities = getAllEntities(viewer);\n   * const bounds = CoordinateTransformer.calculateBounds(entities);\n   * console.log(`Data spans ${bounds.maxLon - bounds.minLon}° longitude`);\n   * \n   * @example  \n   * // Error handling for invalid data / 無効データのエラーハンドリング\n   * try {\n   *   const bounds = CoordinateTransformer.calculateBounds(entities);\n   *   if (bounds.validEntityCount === 0) {\n   *     console.warn('No entities with valid positions found');\n   *   }\n   * } catch (error) {\n   *   console.error('Failed to calculate bounds:', error);\n   * }\n   * \n   * @since v0.1.0\n   * @static\n   */\n  static calculateBounds(entities) {\n    if (!Array.isArray(entities) || entities.length === 0) {\n      throw new Error('エンティティが提供されていません');\n    }\n    \n    let minLon = Infinity;\n    let maxLon = -Infinity;\n    let minLat = Infinity;\n    let maxLat = -Infinity;\n    let minAlt = Infinity;\n    let maxAlt = -Infinity;\n    \n    let validCount = 0;\n    const currentTime = Cesium.JulianDate.now();\n    \n    entities.forEach((entity, index) => {\n      try {\n        // エンティティの位置を取得\n        let position;\n        if (entity.position) {\n          if (typeof entity.position.getValue === 'function') {\n            position = entity.position.getValue(currentTime);\n          } else {\n            position = entity.position;\n          }\n        }\n        \n        if (!position) {\n          return; // 位置情報がない場合はスキップ\n        }\n        \n        // Cartesian3からCartographic（経度、緯度、高度）に変換\n        const cartographic = Cesium.Cartographic.fromCartesian(position);\n        if (!cartographic) return;\n        \n        const lon = Cesium.Math.toDegrees(cartographic.longitude);\n        const lat = Cesium.Math.toDegrees(cartographic.latitude);\n        const alt = cartographic.height;\n        \n        minLon = Math.min(minLon, lon);\n        maxLon = Math.max(maxLon, lon);\n        minLat = Math.min(minLat, lat);\n        maxLat = Math.max(maxLat, lat);\n        minAlt = Math.min(minAlt, alt);\n        maxAlt = Math.max(maxAlt, alt);\n        \n        validCount++;\n      } catch (error) {\n        Logger.warn(`エンティティ ${index} の処理に失敗:`, error);\n      }\n    });\n    \n    if (validCount === 0) {\n      throw new Error('有効な位置情報を持つエンティティが見つかりません');\n    }\n    \n    // デバッグ出力\n    Logger.debug('座標範囲計算完了:', {\n      validCount,\n      bounds: {\n        minLon, maxLon, \n        minLat, maxLat, \n        minAlt, maxAlt\n      }\n    });\n    \n    return {\n      minLon,\n      maxLon,\n      minLat,\n      maxLat,\n      minAlt,\n      maxAlt,\n      centerLon: (minLon + maxLon) / 2,\n      centerLat: (minLat + maxLat) / 2,\n      centerAlt: (minAlt + maxAlt) / 2\n    };\n  }\n  \n  /**\n   * Convert voxel indices to geographic coordinates (cell center).\n   * ボクセルインデックスを地理座標（中心位置）に変換します。\n   * @param {number} x - X-axis voxel index / X軸ボクセルインデックス\n   * @param {number} y - Y-axis voxel index / Y軸ボクセルインデックス\n   * @param {number} z - Z-axis voxel index / Z軸ボクセルインデックス\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @param {Object} grid - Grid info / グリッド情報\n   * @returns {Object} Geographic coordinate {lon, lat, alt} / 地理座標 {lon, lat, alt}\n   */\n  static voxelIndexToCoordinate(x, y, z, bounds, grid) {\n    const { minLon, maxLon, minLat, maxLat, minAlt, maxAlt } = bounds;\n    const { numVoxelsX, numVoxelsY, numVoxelsZ } = grid;\n    \n    // ボクセルの中心位置を計算（シンプルな線形補間）\n    const normalizedLon = (x + 0.5) / numVoxelsX;\n    const normalizedLat = (y + 0.5) / numVoxelsY;\n    const normalizedAlt = (z + 0.5) / numVoxelsZ;\n    \n    return {\n      lon: minLon + normalizedLon * (maxLon - minLon),\n      lat: minLat + normalizedLat * (maxLat - minLat),\n      alt: minAlt + normalizedAlt * (maxAlt - minAlt)\n    };\n  }\n  \n  /**\n   * Convert geographic coordinates to Cesium Cartesian3.\n   * 地理座標を Cesium Cartesian3 に変換します。\n   * @param {number} lon - Longitude / 経度\n   * @param {number} lat - Latitude / 緯度\n   * @param {number} alt - Altitude / 高度\n   * @returns {Cesium.Cartesian3} Cesium Cartesian3\n   */\n  static coordinateToCartesian3(lon, lat, alt) {\n    return Cesium.Cartesian3.fromDegrees(lon, lat, alt);\n  }\n}\n","/**\n * ボクセルグリッドを管理するクラス（シンプル実装）\n */\nimport { Logger } from '../utils/logger.js';\n\n/**\n * Class for managing 3D voxel grids.\n * 3Dボクセルグリッドを管理するクラス。\n */\nexport class VoxelGrid {\n  /**\n   * Create a grid from bounds and voxel size (simple version).\n   * 境界情報とボクセルサイズからグリッドを作成（シンプル版）。\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @param {number} voxelSizeMeters - Target voxel size in meters (actual cell size is range/divisions per axis) / 目標ボクセルサイズ（メートル）。実セルサイズは各軸で範囲/分割数。\n   * @returns {Object} Grid info { numVoxelsX, numVoxelsY, numVoxelsZ, totalVoxels, voxelSizeMeters, cellSizeX, cellSizeY, cellSizeZ, lonRangeMeters, latRangeMeters, altRangeMeters }\n   */\n  static createGrid(bounds, voxelSizeMeters) {\n    // 緯度・経度をメートルに概算変換（シンプルな公式）\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    const lonRangeMeters = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);\n    const latRangeMeters = (bounds.maxLat - bounds.minLat) * 111000;\n    const altRangeMeters = bounds.maxAlt - bounds.minAlt;\n    \n    // 各軸のボクセル数を計算\n    const numVoxelsX = Math.max(1, Math.ceil(lonRangeMeters / voxelSizeMeters));\n    const numVoxelsY = Math.max(1, Math.ceil(latRangeMeters / voxelSizeMeters));\n    const numVoxelsZ = Math.max(1, Math.ceil(altRangeMeters / voxelSizeMeters));\n\n    // 実際の各軸セルサイズ（メートル）\n    // ceil により分割数が増える場合があるため、実セルサイズは指定サイズ以下になる。\n    const cellSizeX = numVoxelsX > 0 ? (lonRangeMeters / numVoxelsX) : voxelSizeMeters;\n    const cellSizeY = numVoxelsY > 0 ? (latRangeMeters / numVoxelsY) : voxelSizeMeters;\n    // 高度差が極小の場合に0にならないよう最低1mを確保\n    const cellSizeZ = numVoxelsZ > 0 ? Math.max(altRangeMeters / numVoxelsZ, 1) : Math.max(voxelSizeMeters, 1);\n    \n    const totalVoxels = numVoxelsX * numVoxelsY * numVoxelsZ;\n    \n    Logger.debug('VoxelGrid created:', {\n      numVoxelsX,\n      numVoxelsY,\n      numVoxelsZ,\n      totalVoxels,\n      voxelSizeMeters,\n      cellSizeX,\n      cellSizeY,\n      cellSizeZ,\n      lonRangeMeters,\n      latRangeMeters,\n      altRangeMeters\n    });\n    \n    return {\n      numVoxelsX,\n      numVoxelsY,\n      numVoxelsZ,\n      totalVoxels,\n      voxelSizeMeters,\n      cellSizeX,\n      cellSizeY,\n      cellSizeZ,\n      lonRangeMeters,\n      latRangeMeters,\n      altRangeMeters\n    };\n  }\n  \n  /**\n   * Generate a key from voxel indices.\n   * ボクセルインデックスからキーを生成します。\n   * @param {number} x - X index / X軸インデックス\n   * @param {number} y - Y index / Y軸インデックス\n   * @param {number} z - Z index / Z軸インデックス\n   * @returns {string} Voxel key / ボクセルキー\n   */\n  static getVoxelKey(x, y, z) {\n    return `${x},${y},${z}`;\n  }\n  \n  /**\n   * Parse voxel key into indices.\n   * ボクセルキーからインデックスを解析します。\n   * @param {string} key - Voxel key / ボクセルキー\n   * @returns {Object} Indices {x, y, z} / インデックス {x, y, z}\n   */\n  static parseVoxelKey(key) {\n    const [x, y, z] = key.split(',').map(Number);\n    return { x, y, z };\n  }\n  \n  /**\n   * Iterate all voxels and invoke callback per cell.\n   * グリッド内の全ボクセルを反復処理します。\n   * @param {Object} grid - Grid info / グリッド情報\n   * @param {Function} callback - Callback per voxel / 各ボクセルに対するコールバック関数\n   */\n  static iterateAllVoxels(grid, callback) {\n    const { numVoxelsX, numVoxelsY, numVoxelsZ } = grid;\n    \n    for (let x = 0; x < numVoxelsX; x++) {\n      for (let y = 0; y < numVoxelsY; y++) {\n        for (let z = 0; z < numVoxelsZ; z++) {\n          const key = this.getVoxelKey(x, y, z);\n          callback(x, y, z, key);\n        }\n      }\n    }\n  }\n}\n","/**\n * データ処理を担当するクラス（シンプル実装）\n */\nimport * as Cesium from 'cesium';\nimport { VoxelGrid } from './VoxelGrid.js';\nimport { Logger } from '../utils/logger.js';\n\n/**\n * Class responsible for processing entity data.\n * エンティティデータの処理を担当するクラス。\n */\nexport class DataProcessor {\n  /**\n   * Classify entities into voxels (simple implementation).\n   * エンティティをボクセルに分類（シンプル実装）。\n   * @param {Array} entities - Entity array / エンティティ配列\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @param {Object} grid - Grid info / グリッド情報\n   * @returns {Map} Voxel data Map (key: voxel key, value: info) / ボクセルデータ（キー: ボクセルキー, 値: ボクセル情報）\n   */\n  static classifyEntitiesIntoVoxels(entities, bounds, grid) {\n    const voxelData = new Map();\n    let processedCount = 0;\n    let skippedCount = 0;\n    \n    Logger.debug(`Processing ${entities.length} entities for classification`);\n    \n    const currentTime = Cesium.JulianDate.now();\n    \n    entities.forEach((entity, index) => {\n      try {\n        // エンティティの位置を取得（シンプルなアプローチ）\n        let position;\n        if (entity.position) {\n          if (typeof entity.position.getValue === 'function') {\n            position = entity.position.getValue(currentTime);\n          } else {\n            position = entity.position;\n          }\n        }\n        \n        if (!position) {\n          skippedCount++;\n          return; // 位置がない場合はスキップ\n        }\n        \n        // Cartesian3からCartographicに変換\n        const cartographic = Cesium.Cartographic.fromCartesian(position);\n        if (!cartographic) {\n          skippedCount++;\n          return;\n        }\n        \n        // 地理座標に変換\n        const lon = Cesium.Math.toDegrees(cartographic.longitude);\n        const lat = Cesium.Math.toDegrees(cartographic.latitude);\n        const alt = cartographic.height;\n        \n        // 範囲外チェック（少しマージンを持たせる）\n        if (lon < bounds.minLon - 0.001 || lon > bounds.maxLon + 0.001 ||\n            lat < bounds.minLat - 0.001 || lat > bounds.maxLat + 0.001 ||\n            alt < bounds.minAlt - 1 || alt > bounds.maxAlt + 1) {\n          skippedCount++;\n          return;\n        }\n        \n        // ボクセルインデックスを計算（範囲0の安全対策）\n        const lonDen = (bounds.maxLon - bounds.minLon);\n        const latDen = (bounds.maxLat - bounds.minLat);\n        const altDen = (bounds.maxAlt - bounds.minAlt);\n\n        const voxelX = lonDen === 0 ? 0 : Math.floor(\n          (lon - bounds.minLon) / lonDen * grid.numVoxelsX\n        );\n        const voxelY = latDen === 0 ? 0 : Math.floor(\n          (lat - bounds.minLat) / latDen * grid.numVoxelsY\n        );\n        const voxelZ = altDen === 0 ? 0 : Math.floor(\n          (alt - bounds.minAlt) / altDen * grid.numVoxelsZ\n        );\n        \n        // インデックスが有効範囲内かチェック\n        if (voxelX >= 0 && voxelX < grid.numVoxelsX &&\n            voxelY >= 0 && voxelY < grid.numVoxelsY &&\n            voxelZ >= 0 && voxelZ < grid.numVoxelsZ) {\n            \n          const voxelKey = VoxelGrid.getVoxelKey(voxelX, voxelY, voxelZ);\n          \n          if (!voxelData.has(voxelKey)) {\n            voxelData.set(voxelKey, {\n              x: voxelX,\n              y: voxelY,\n              z: voxelZ,\n              entities: [],\n              count: 0\n            });\n          }\n          \n          const voxelInfo = voxelData.get(voxelKey);\n          voxelInfo.entities.push(entity);\n          voxelInfo.count++;\n          \n          processedCount++;\n        } else {\n          skippedCount++;\n        }\n      } catch (error) {\n        Logger.warn(`エンティティ ${index} の処理に失敗:`, error);\n        skippedCount++;\n      }\n    });\n    \n    Logger.info(`${processedCount}個のエンティティを${voxelData.size}個のボクセルに分類（${skippedCount}個はスキップ）`);\n    return voxelData;\n  }\n  \n  /**\n   * Calculate statistics from voxel data.\n   * ボクセルデータから統計情報を計算します。\n   * @param {Map} voxelData - Voxel data / ボクセルデータ\n   * @param {Object} grid - Grid info / グリッド情報\n   * @returns {Object} Statistics / 統計情報\n   */\n  static calculateStatistics(voxelData, grid) {\n    if (voxelData.size === 0) {\n      return {\n        totalVoxels: grid.totalVoxels,\n        renderedVoxels: 0,\n        nonEmptyVoxels: 0,\n        emptyVoxels: grid.totalVoxels,\n        totalEntities: 0,\n        minCount: 0,\n        maxCount: 0,\n        averageCount: 0,\n        // v0.1.4: 自動調整情報の初期化\n        autoAdjusted: false,\n        originalVoxelSize: null,\n        finalVoxelSize: null,\n        adjustmentReason: null\n      };\n    }\n    \n    const counts = Array.from(voxelData.values()).map(voxel => voxel.count);\n    const totalEntities = counts.reduce((sum, count) => sum + count, 0);\n    \n    const stats = {\n      totalVoxels: grid.totalVoxels,\n      renderedVoxels: 0, // 実際の描画後にVoxelRendererから設定される\n      nonEmptyVoxels: voxelData.size,\n      emptyVoxels: grid.totalVoxels - voxelData.size,\n      totalEntities: totalEntities,\n      minCount: Math.min(...counts),\n      maxCount: Math.max(...counts),\n      averageCount: totalEntities / voxelData.size,\n      // v0.1.4: 自動調整情報の初期化\n      autoAdjusted: false,\n      originalVoxelSize: null,\n      finalVoxelSize: null,\n      adjustmentReason: null\n    };\n    \n    Logger.debug('統計情報計算完了:', stats);\n    return stats;\n  }\n  \n  /**\n   * Get top-N densest voxels.\n   * 上位 N 個のボクセルを取得します。\n   * @param {Map} voxelData - Voxel data / ボクセルデータ\n   * @param {number} topN - Number to get / 取得する上位の数\n   * @returns {Array} Top-N voxel info / 上位N個のボクセル情報\n   */\n  static getTopNVoxels(voxelData, topN) {\n    if (voxelData.size === 0 || topN <= 0) {\n      return [];\n    }\n    \n    // ボクセルを密度でソート\n    const sortedVoxels = Array.from(voxelData.values())\n      .sort((a, b) => b.count - a.count);\n    \n    // 上位N個を返す\n    return sortedVoxels.slice(0, Math.min(topN, sortedVoxels.length));\n  }\n}\n","/**\n * Interface for voxel selection strategies.\n * ボクセル選択戦略のインターフェース。\n * \n * All selection strategies must implement the select method.\n * すべての選択戦略はselectメソッドを実装する必要があります。\n */\n\n/**\n * Abstract base class for voxel selection strategies.\n * ボクセル選択戦略の抽象基底クラス。\n */\nexport class SelectionStrategyInterface {\n  /**\n   * Select voxels according to strategy.\n   * 戦略に従ってボクセルを選択します。\n   * \n   * @param {Array} allVoxels - All available voxels / 利用可能な全ボクセル\n   * @param {number} maxCount - Maximum selection count / 最大選択数\n   * @param {Object} grid - Grid information / グリッド情報\n   * @param {Set} _forceInclude - Voxels to force include (e.g., TopN) / 強制包含ボクセル（例：TopN）\n   * @param {Object} _options - Strategy-specific options / 戦略固有のオプション\n   * @returns {Object} Selection result with metadata / メタデータ付きの選択結果\n   * @returns {Array} returns.selected - Selected voxels / 選択されたボクセル\n   * @returns {Object} returns.metadata - Strategy metadata / 戦略メタデータ\n   * @abstract\n   */\n  select(allVoxels, maxCount, grid, _forceInclude = new Set(), _options = {}) {\n    throw new Error('SelectionStrategyInterface.select() must be implemented by subclass');\n  }\n\n  /**\n   * Get strategy name.\n   * 戦略名を取得します。\n   * \n   * @returns {string} Strategy name / 戦略名\n   * @abstract\n   */\n  getStrategyName() {\n    throw new Error('SelectionStrategyInterface.getStrategyName() must be implemented by subclass');\n  }\n\n  /**\n   * Validate strategy-specific options.\n   * 戦略固有のオプションを検証します。\n   * \n   * @param {Object} _options - Options to validate / 検証するオプション\n   * @returns {boolean} Whether options are valid / オプションが有効かどうか\n   */\n  validateOptions(_options) {\n    // Default implementation accepts any options\n    // デフォルト実装は任意のオプションを受け入れる\n    return true;\n  }\n}\n","/**\n * Density-based voxel selection strategy.\n * 密度ベースのボクセル選択戦略。\n * \n * This strategy selects voxels with the highest density values first.\n * この戦略は密度値の高いボクセルを優先して選択します。\n */\n\nimport { SelectionStrategyInterface } from './SelectionStrategyInterface.js';\n\n/**\n * Density selection strategy implementation.\n * 密度選択戦略の実装。\n */\nexport class DensitySelectionStrategy extends SelectionStrategyInterface {\n  /**\n   * Select voxels by density (highest density first).\n   * 密度による選択（密度の高い順）。\n   * \n   * @param {Array} allVoxels - All available voxels / 利用可能な全ボクセル\n   * @param {number} maxCount - Maximum selection count / 最大選択数\n   * @param {Object} grid - Grid information (not used in density strategy) / グリッド情報（密度戦略では未使用）\n   * @param {Set} forceInclude - Voxels to force include (e.g., TopN) / 強制包含ボクセル（例：TopN）\n   * @param {Object} _options - Strategy options (not used in density strategy) / 戦略オプション（密度戦略では未使用）\n   * @returns {Object} Selection result / 選択結果\n   * @returns {Array} returns.selected - Selected voxels sorted by density / 密度順でソートされた選択ボクセル\n   * @returns {Object} returns.metadata - Selection metadata / 選択メタデータ\n   */\n  select(allVoxels, maxCount, grid, forceInclude = new Set(), _options = {}) {\n    // Validate inputs / 入力検証\n    if (!Array.isArray(allVoxels)) {\n      throw new Error('allVoxels must be an array');\n    }\n    if (typeof maxCount !== 'number' || maxCount < 0) {\n      throw new Error('maxCount must be a non-negative number');\n    }\n    if (!(forceInclude instanceof Set)) {\n      throw new Error('forceInclude must be a Set');\n    }\n\n    // Sort voxels by density (highest first)\n    // 密度でソートして上位を選択\n    const sorted = [...allVoxels].sort((a, b) => b.info.count - a.info.count);\n    \n    // Initialize selection arrays\n    // 選択配列を初期化\n    const selected = [];\n    const included = new Set();\n    \n    // Add force-included voxels first (e.g., TopN highlights)\n    // 強制包含ボクセルを先に追加（例：TopN強調表示）\n    sorted.forEach(voxel => {\n      if (forceInclude.has(voxel.key) && selected.length < maxCount) {\n        selected.push(voxel);\n        included.add(voxel.key);\n      }\n    });\n    \n    // Add remaining voxels in density order\n    // 残りを密度順で追加\n    sorted.forEach(voxel => {\n      if (!included.has(voxel.key) && selected.length < maxCount) {\n        selected.push(voxel);\n        included.add(voxel.key);\n      }\n    });\n\n    // Calculate statistics\n    // 統計を計算\n    const totalVoxels = allVoxels.length;\n    const selectedCount = selected.length;\n    const clippedCount = totalVoxels - selectedCount;\n    \n    const metadata = {\n      strategy: this.getStrategyName(),\n      totalVoxels,\n      selectedCount,\n      clippedCount,\n      forceIncludedCount: Math.min(forceInclude.size, selectedCount),\n      densityRange: selected.length > 0 ? {\n        max: selected[0]?.info?.count || 0,\n        min: selected[selected.length - 1]?.info?.count || 0\n      } : { max: 0, min: 0 }\n    };\n\n    return {\n      selected,\n      metadata\n    };\n  }\n\n  /**\n   * Get strategy name.\n   * 戦略名を取得します。\n   * \n   * @returns {string} Strategy name / 戦略名\n   */\n  getStrategyName() {\n    return 'density';\n  }\n\n  /**\n   * Validate density strategy options.\n   * 密度戦略オプションを検証します。\n   * \n   * @param {Object} _options - Options to validate / 検証するオプション\n   * @returns {boolean} Whether options are valid / オプションが有効かどうか\n   */\n  validateOptions(_options) {\n    // Density strategy doesn't require specific options\n    // 密度戦略は特定のオプションを必要としません\n    return true;\n  }\n}\n","/**\n * Coverage-based selection strategy for voxels.\n * カバレッジベース選択戦略（層化抽出による空間的代表性確保）\n */\nimport { SelectionStrategyInterface } from './SelectionStrategyInterface.js';\nimport { Logger } from '../../utils/logger.js';\n\n/**\n * Implements coverage-based voxel selection using stratified sampling.\n * 層化抽出による空間的代表性を重視したボクセル選択を実装します。\n * 空間を格子状に分割し、各セクションから代表的なボクセルを選択することで、\n * 偏りの少ない可視化を実現します。\n */\nexport class CoverageSelectionStrategy extends SelectionStrategyInterface {\n  /**\n   * Select voxels based on spatial coverage using stratified sampling.\n   * 層化抽出による空間カバレッジを重視した選択を行います。\n   * \n   * @param {Array} allVoxels - All available voxels / 全ボクセル\n   * @param {number} maxCount - Maximum voxels to select / 選択する最大ボクセル数\n   * @param {Object} grid - Grid information / グリッド情報\n   * @param {Set} forceInclude - Voxels to force include / 強制包含ボクセル\n   * @param {Object} options - Selection options / 選択オプション\n   * @returns {Object} Selection result / 選択結果\n   */\n  select(allVoxels, maxCount, grid, forceInclude = new Set(), options = {}) {\n    Logger.debug(`Coverage selection: ${allVoxels.length} candidates, max ${maxCount}`);\n    \n    const selected = [];\n    const included = new Set();\n    \n    // 強制包含ボクセルを先に追加\n    this._addForceIncludedVoxels(allVoxels, selected, included, forceInclude, maxCount);\n    \n    if (selected.length >= maxCount) {\n      return this._createResult(selected, options);\n    }\n    \n    // グリッド分割による層化抽出の実行\n    const remainingVoxels = allVoxels.filter(voxel => !included.has(voxel.key));\n    const binsXY = this._calculateOptimalBinCount(maxCount - selected.length, options);\n    const bins = this._createSpatialBins(remainingVoxels, grid, binsXY);\n    \n    // 各ビンから代表ボクセルを選択\n    this._selectFromBins(bins, selected, included, maxCount, options);\n    \n    Logger.debug(`Coverage selection completed: ${selected.length} voxels selected`);\n    return this._createResult(selected, options, { binsXY, totalBins: bins.size });\n  }\n  \n  /**\n   * Add force-included voxels to selection.\n   * 強制包含ボクセルを選択に追加します。\n   * @param {Array} allVoxels - All voxels / 全ボクセル\n   * @param {Array} selected - Selected voxels array / 選択済みボクセル配列\n   * @param {Set} included - Set of included voxel keys / 包含済みボクセルキーセット\n   * @param {Set} forceInclude - Force include set / 強制包含セット\n   * @param {number} maxCount - Maximum count / 最大数\n   * @private\n   */\n  _addForceIncludedVoxels(allVoxels, selected, included, forceInclude, maxCount) {\n    for (const voxel of allVoxels) {\n      if (forceInclude.has(voxel.key) && selected.length < maxCount) {\n        selected.push(voxel);\n        included.add(voxel.key);\n      }\n    }\n  }\n  \n  /**\n   * Calculate optimal number of bins for spatial division.\n   * 空間分割の最適ビン数を計算します。\n   * @param {number} targetCount - Target selection count / 目標選択数\n   * @param {Object} options - Selection options / 選択オプション\n   * @returns {number} Optimal bin count / 最適ビン数\n   * @private\n   */\n  _calculateOptimalBinCount(targetCount, options) {\n    if (options.coverageBinsXY && options.coverageBinsXY !== 'auto') {\n      return Math.max(1, parseInt(options.coverageBinsXY));\n    }\n    \n    // 自動計算: 平均4ボクセル/ビンを目標とする\n    const targetVoxelsPerBin = 4;\n    const calculatedBins = Math.ceil(Math.sqrt(targetCount / targetVoxelsPerBin));\n    \n    // 最小2、最大20の範囲で制限\n    return Math.max(2, Math.min(20, calculatedBins));\n  }\n  \n  /**\n   * Create spatial bins for stratified sampling.\n   * 層化抽出のための空間ビンを作成します。\n   * @param {Array} voxels - Voxels to bin / ビン分けするボクセル\n   * @param {Object} grid - Grid information / グリッド情報\n   * @param {number} binsXY - Number of bins per axis / 軸あたりのビン数\n   * @returns {Map} Spatial bins / 空間ビン\n   * @private\n   */\n  _createSpatialBins(voxels, grid, binsXY) {\n    const bins = new Map();\n    const maxX = Math.max(1, grid.numVoxelsX);\n    const maxY = Math.max(1, grid.numVoxelsY);\n    \n    for (const voxel of voxels) {\n      const binX = Math.max(0, Math.min(binsXY - 1, \n        Math.floor((voxel.info.x / maxX) * binsXY)));\n      const binY = Math.max(0, Math.min(binsXY - 1, \n        Math.floor((voxel.info.y / maxY) * binsXY)));\n      const binKey = `${binX},${binY}`;\n      \n      if (!bins.has(binKey)) {\n        bins.set(binKey, []);\n      }\n      bins.get(binKey).push(voxel);\n    }\n    \n    return bins;\n  }\n  \n  /**\n   * Select representative voxels from each bin.\n   * 各ビンから代表ボクセルを選択します。\n   * @param {Map} bins - Spatial bins / 空間ビン\n   * @param {Array} selected - Selected voxels array / 選択済みボクセル配列\n   * @param {Set} included - Included voxel keys / 包含済みボクセルキー\n   * @param {number} maxCount - Maximum count / 最大数\n   * @param {Object} options - Selection options / 選択オプション\n   * @private\n   */\n  _selectFromBins(bins, selected, included, maxCount, options) {\n    const binKeys = Array.from(bins.keys());\n    let binIndex = 0;\n    const maxIterations = binKeys.length * 10; // 無限ループ防止\n    \n    while (selected.length < maxCount && binIndex < maxIterations && bins.size > 0) {\n      const binKey = binKeys[binIndex % binKeys.length];\n      const binVoxels = bins.get(binKey);\n      \n      if (binVoxels && binVoxels.length > 0) {\n        // ビン内で最高密度のボクセルを選択\n        const voxel = this._selectBestVoxelFromBin(binVoxels, options);\n        \n        if (voxel && !included.has(voxel.key)) {\n          selected.push(voxel);\n          included.add(voxel.key);\n        }\n        \n        // 選択されたボクセルをビンから除去\n        const voxelIndex = binVoxels.indexOf(voxel);\n        if (voxelIndex >= 0) {\n          binVoxels.splice(voxelIndex, 1);\n        }\n        \n        // 空になったビンを削除\n        if (binVoxels.length === 0) {\n          bins.delete(binKey);\n          const keyIndex = binKeys.indexOf(binKey);\n          if (keyIndex >= 0) {\n            binKeys.splice(keyIndex, 1);\n          }\n        }\n      }\n      \n      binIndex++;\n    }\n  }\n  \n  /**\n   * Select the best voxel from a bin based on selection criteria.\n   * 選択基準に基づいてビン内の最適なボクセルを選択します。\n   * @param {Array} binVoxels - Voxels in the bin / ビン内のボクセル\n   * @param {Object} options - Selection options / 選択オプション\n   * @returns {Object} Best voxel / 最適なボクセル\n   * @private\n   */\n  _selectBestVoxelFromBin(binVoxels, options) {\n    if (binVoxels.length === 0) return null;\n    if (binVoxels.length === 1) return binVoxels[0];\n    \n    // 密度（カウント）順でソート\n    const sortedVoxels = [...binVoxels].sort((a, b) => b.info.count - a.info.count);\n    \n    // 選択モード: 'highest'（最高密度）、'median'（中央値）、'random'（ランダム）\n    const selectionMode = options.binSelectionMode || 'highest';\n    \n    switch (selectionMode) {\n      case 'median':\n        return sortedVoxels[Math.floor(sortedVoxels.length / 2)];\n      case 'random':\n        return sortedVoxels[Math.floor(Math.random() * sortedVoxels.length)];\n      case 'highest':\n      default:\n        return sortedVoxels[0];\n    }\n  }\n  \n  /**\n   * Create selection result with metadata.\n   * メタデータ付きの選択結果を作成します。\n   * @param {Array} selected - Selected voxels / 選択されたボクセル\n   * @param {Object} options - Selection options / 選択オプション\n   * @param {Object} additionalMetadata - Additional metadata / 追加メタデータ\n   * @returns {Object} Selection result / 選択結果\n   * @private\n   */\n  _createResult(selected, options, additionalMetadata = {}) {\n    const metadata = {\n      strategy: 'coverage',\n      totalSelected: selected.length,\n      selectionRatio: selected.length > 0 ? 1.0 : 0.0,\n      ...additionalMetadata\n    };\n    \n    return { selected, metadata };\n  }\n}\n","/**\n * Hybrid selection strategy combining density and coverage approaches.\n * 密度選択とカバレッジ選択を組み合わせたハイブリッド戦略\n */\nimport { SelectionStrategyInterface } from './SelectionStrategyInterface.js';\nimport { DensitySelectionStrategy } from './DensitySelectionStrategy.js';\nimport { CoverageSelectionStrategy } from './CoverageSelectionStrategy.js';\nimport { Logger } from '../../utils/logger.js';\n\n/**\n * Implements hybrid voxel selection combining density and coverage strategies.\n * 密度選択とカバレッジ選択を組み合わせたハイブリッド選択を実装します。\n * 重要な高密度領域を確保しつつ、空間的な代表性も維持します。\n */\nexport class HybridSelectionStrategy extends SelectionStrategyInterface {\n  constructor() {\n    super();\n    this.densityStrategy = new DensitySelectionStrategy();\n    this.coverageStrategy = new CoverageSelectionStrategy();\n  }\n  \n  /**\n   * Select voxels using hybrid approach (density + coverage).\n   * ハイブリッドアプローチ（密度 + カバレッジ）による選択を行います。\n   * \n   * @param {Array} allVoxels - All available voxels / 全ボクセル\n   * @param {number} maxCount - Maximum voxels to select / 選択する最大ボクセル数\n   * @param {Object} grid - Grid information / グリッド情報\n   * @param {Set} forceInclude - Voxels to force include / 強制包含ボクセル\n   * @param {Object} options - Selection options / 選択オプション\n   * @returns {Object} Selection result / 選択結果\n   */\n  select(allVoxels, maxCount, grid, forceInclude = new Set(), options = {}) {\n    Logger.debug(`Hybrid selection: ${allVoxels.length} candidates, max ${maxCount}`);\n    \n    const selected = [];\n    const included = new Set();\n    \n    // 強制包含ボクセルを先に追加\n    this._addForceIncludedVoxels(allVoxels, selected, included, forceInclude, maxCount);\n    \n    if (selected.length >= maxCount) {\n      return this._createResult(selected, options, 0, 0);\n    }\n    \n    // カバレッジ比率の決定\n    const coverageRatio = this._determineCoverageRatio(options);\n    const remainingCount = maxCount - selected.length;\n    \n    // カバレッジとDensityの分配を計算\n    const coverageCount = Math.floor(remainingCount * coverageRatio);\n    const densityCount = remainingCount - coverageCount;\n    \n    Logger.debug(`Hybrid split: ${coverageCount} coverage, ${densityCount} density`);\n    \n    // カバレッジ選択の実行\n    let actualCoverageCount = 0;\n    if (coverageCount > 0) {\n      actualCoverageCount = this._executeCoverageSelection(\n        allVoxels, coverageCount, grid, included, selected, maxCount, options\n      );\n    }\n    \n    // 密度選択の実行（残り）\n    let actualDensityCount = 0;\n    if (densityCount > 0 && selected.length < maxCount) {\n      actualDensityCount = this._executeDensitySelection(\n        allVoxels, densityCount, grid, included, selected, maxCount, options\n      );\n    }\n    \n    Logger.debug(`Hybrid selection completed: ${selected.length} total (${actualCoverageCount} coverage, ${actualDensityCount} density)`);\n    \n    return this._createResult(selected, options, actualCoverageCount, actualDensityCount);\n  }\n  \n  /**\n   * Add force-included voxels to selection.\n   * 強制包含ボクセルを選択に追加します。\n   * @param {Array} allVoxels - All voxels / 全ボクセル\n   * @param {Array} selected - Selected voxels array / 選択済みボクセル配列\n   * @param {Set} included - Set of included voxel keys / 包含済みボクセルキーセット\n   * @param {Set} forceInclude - Force include set / 強制包含セット\n   * @param {number} maxCount - Maximum count / 最大数\n   * @private\n   */\n  _addForceIncludedVoxels(allVoxels, selected, included, forceInclude, maxCount) {\n    for (const voxel of allVoxels) {\n      if (forceInclude.has(voxel.key) && selected.length < maxCount) {\n        selected.push(voxel);\n        included.add(voxel.key);\n      }\n    }\n  }\n  \n  /**\n   * Determine the coverage ratio for hybrid selection.\n   * ハイブリッド選択のカバレッジ比率を決定します。\n   * @param {Object} options - Selection options / 選択オプション\n   * @returns {number} Coverage ratio (0.0-1.0) / カバレッジ比率\n   * @private\n   */\n  _determineCoverageRatio(options) {\n    const defaultRatio = 0.3; // デフォルト30%をカバレッジに割り当て\n    \n    if (options.minCoverageRatio !== undefined) {\n      return Math.max(0.0, Math.min(1.0, options.minCoverageRatio));\n    }\n    \n    if (options.coverageRatio !== undefined) {\n      return Math.max(0.0, Math.min(1.0, options.coverageRatio));\n    }\n    \n    return defaultRatio;\n  }\n  \n  /**\n   * Execute coverage selection phase.\n   * カバレッジ選択フェーズを実行します。\n   * @param {Array} allVoxels - All voxels / 全ボクセル\n   * @param {number} coverageCount - Target coverage count / 目標カバレッジ数\n   * @param {Object} grid - Grid information / グリッド情報\n   * @param {Set} included - Already included voxels / 既に含まれているボクセル\n   * @param {Array} selected - Selected voxels array / 選択済みボクセル配列\n   * @param {number} maxCount - Maximum total count / 最大総数\n   * @param {Object} options - Selection options / 選択オプション\n   * @returns {number} Actual coverage count added / 実際に追加されたカバレッジ数\n   * @private\n   */\n  _executeCoverageSelection(allVoxels, coverageCount, grid, included, selected, maxCount, options) {\n    const availableVoxels = allVoxels.filter(voxel => !included.has(voxel.key));\n    \n    if (availableVoxels.length === 0 || coverageCount <= 0) {\n      return 0;\n    }\n    \n    const coverageOptions = {\n      ...options,\n      // カバレッジ特有のオプションを設定\n      binSelectionMode: options.hybridCoverageMode || 'highest'\n    };\n    \n    const coverageResult = this.coverageStrategy.select(\n      availableVoxels,\n      coverageCount,\n      grid,\n      new Set(), // カバレッジ選択では新しい強制包含セットを使用\n      coverageOptions\n    );\n    \n    let addedCount = 0;\n    for (const voxel of coverageResult.selected) {\n      if (selected.length < maxCount && !included.has(voxel.key)) {\n        selected.push(voxel);\n        included.add(voxel.key);\n        addedCount++;\n      }\n    }\n    \n    return addedCount;\n  }\n  \n  /**\n   * Execute density selection phase.\n   * 密度選択フェーズを実行します。\n   * @param {Array} allVoxels - All voxels / 全ボクセル\n   * @param {number} densityCount - Target density count / 目標密度数\n   * @param {Object} grid - Grid information / グリッド情報\n   * @param {Set} included - Already included voxels / 既に含まれているボクセル\n   * @param {Array} selected - Selected voxels array / 選択済みボクセル配列\n   * @param {number} maxCount - Maximum total count / 最大総数\n   * @param {Object} options - Selection options / 選択オプション\n   * @returns {number} Actual density count added / 実際に追加された密度数\n   * @private\n   */\n  _executeDensitySelection(allVoxels, densityCount, grid, included, selected, maxCount, options) {\n    const availableVoxels = allVoxels.filter(voxel => !included.has(voxel.key));\n    \n    if (availableVoxels.length === 0 || densityCount <= 0) {\n      return 0;\n    }\n    \n    const densityOptions = {\n      ...options,\n      // 密度特有のオプションを設定\n      selectionMode: options.hybridDensityMode || 'highest'\n    };\n    \n    const densityResult = this.densityStrategy.select(\n      availableVoxels,\n      densityCount,\n      grid,\n      new Set(), // 密度選択では新しい強制包含セットを使用\n      densityOptions\n    );\n    \n    let addedCount = 0;\n    for (const voxel of densityResult.selected) {\n      if (selected.length < maxCount && !included.has(voxel.key)) {\n        selected.push(voxel);\n        included.add(voxel.key);\n        addedCount++;\n      }\n    }\n    \n    return addedCount;\n  }\n  \n  /**\n   * Create selection result with hybrid metadata.\n   * ハイブリッドメタデータ付きの選択結果を作成します。\n   * @param {Array} selected - Selected voxels / 選択されたボクセル\n   * @param {Object} options - Selection options / 選択オプション\n   * @param {number} coverageCount - Actual coverage count / 実際のカバレッジ数\n   * @param {number} densityCount - Actual density count / 実際の密度数\n   * @returns {Object} Selection result / 選択結果\n   * @private\n   */\n  _createResult(selected, options, coverageCount, densityCount) {\n    const totalSelectionCount = selected.length;\n    const actualCoverageRatio = totalSelectionCount > 0 ? \n      coverageCount / totalSelectionCount : 0;\n    \n    const metadata = {\n      strategy: 'hybrid',\n      totalSelected: totalSelectionCount,\n      coverageSelected: coverageCount,\n      densitySelected: densityCount,\n      coverageRatio: actualCoverageRatio,\n      targetCoverageRatio: this._determineCoverageRatio(options),\n      selectionRatio: totalSelectionCount > 0 ? 1.0 : 0.0\n    };\n    \n    return { selected, metadata };\n  }\n}\n","/**\n * Color mapping and interpolation utilities for voxel rendering.\n * ボクセル描画用の色マッピング・補間ユーティリティ。\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\n\n// v0.1.5: カラーマップ定義（256段階のLUTテーブル）\nconst COLOR_MAPS = {\n  // Viridisカラーマップ（簡略化した16段階）\n  viridis: [\n    [68, 1, 84], [71, 44, 122], [59, 81, 139], [44, 113, 142],\n    [33, 144, 141], [39, 173, 129], [92, 200, 99], [170, 220, 50],\n    [253, 231, 37], [255, 255, 255], [255, 255, 255], [255, 255, 255],\n    [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]\n  ],\n  // Infernoカラーマップ（簡略化した16段階）\n  inferno: [\n    [0, 0, 4], [31, 12, 72], [85, 15, 109], [136, 34, 106],\n    [186, 54, 85], [227, 89, 51], [249, 142, 8], [252, 187, 17],\n    [245, 219, 76], [252, 255, 164], [255, 255, 255], [255, 255, 255],\n    [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]\n  ],\n  // 二極性配色（blue-white-red）\n  diverging: [\n    [0, 0, 255], [32, 64, 255], [64, 128, 255], [96, 160, 255],\n    [128, 192, 255], [160, 224, 255], [192, 240, 255], [224, 248, 255],\n    [255, 255, 255], [255, 248, 224], [255, 240, 192], [255, 224, 160],\n    [255, 192, 128], [255, 160, 96], [255, 128, 64], [255, 64, 32], [255, 0, 0]\n  ]\n};\n\n/**\n * Color mapping and interpolation utility class.\n * 色マッピングと補間を担当するユーティリティクラス。\n */\nexport class ColorMap {\n  /**\n   * Main color interpolation method.\n   * メイン色補間メソッド。\n   * @param {number} normalizedDensity - Normalized density (0-1) / 正規化された密度 (0-1)\n   * @param {number} [rawValue] - Raw value for diverging scheme / 生値（二極性配色用）\n   * @param {Object} options - Color options / 色オプション\n   * @returns {Cesium.Color} Calculated color / 計算された色\n   */\n  static interpolateColor(normalizedDensity, rawValue = null, options = {}) {\n    // v0.1.5: 二極性配色対応（pivot<=0 の場合は安全にフォールバック）\n    if (options.diverging && rawValue !== null) {\n      const pivot = typeof options.divergingPivot === 'number' ? options.divergingPivot : 0;\n      if (pivot > 0) {\n        return ColorMap._interpolateDivergingColor(rawValue, options);\n      }\n      // pivot が 0 以下の場合は従来の補間にフォールバック\n    }\n    \n    // v0.1.5: カラーマップ対応\n    if (options.colorMap && options.colorMap !== 'custom') {\n      return ColorMap._interpolateFromColorMap(normalizedDensity, options.colorMap);\n    }\n    \n    // 従来のmin/max色補間（後方互換）\n    const minColor = options.minColor || [0, 0, 255];\n    const maxColor = options.maxColor || [255, 0, 0];\n    \n    const [minR, minG, minB] = minColor;\n    const [maxR, maxG, maxB] = maxColor;\n    \n    const r = Math.round(minR + (maxR - minR) * normalizedDensity);\n    const g = Math.round(minG + (maxG - minG) * normalizedDensity);\n    const b = Math.round(minB + (maxB - minB) * normalizedDensity);\n    \n    return Cesium.Color.fromBytes(r, g, b);\n  }\n\n  /**\n   * Interpolate color from a color map.\n   * カラーマップから色を補間します。\n   * @param {number} normalizedValue - Normalized value (0-1) / 正規化された値 (0-1)\n   * @param {string} colorMapName - Color map name / カラーマップ名\n   * @returns {Cesium.Color} Calculated color / 計算された色\n   * @private\n   */\n  static _interpolateFromColorMap(normalizedValue, colorMapName) {\n    const colorMap = COLOR_MAPS[colorMapName];\n    if (!colorMap) {\n      Logger.warn(`Unknown color map: ${colorMapName}. Falling back to custom.`);\n      return ColorMap.interpolateColor(normalizedValue);\n    }\n    \n    // マップインデックスを計算\n    const scaledValue = normalizedValue * (colorMap.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.min(lowerIndex + 1, colorMap.length - 1);\n    const fraction = scaledValue - lowerIndex;\n    \n    // 補間計算\n    const [lowerR, lowerG, lowerB] = colorMap[lowerIndex];\n    const [upperR, upperG, upperB] = colorMap[upperIndex];\n    \n    const r = Math.round(lowerR + (upperR - lowerR) * fraction);\n    const g = Math.round(lowerG + (upperG - lowerG) * fraction);\n    const b = Math.round(lowerB + (upperB - lowerB) * fraction);\n    \n    return Cesium.Color.fromBytes(r, g, b);\n  }\n\n  /**\n   * Interpolate color using diverging scheme.\n   * 二極性配色を使用して色を補間します。\n   * @param {number} rawValue - Raw value / 生値\n   * @param {Object} options - Color options / 色オプション\n   * @returns {Cesium.Color} Calculated color / 計算された色\n   * @private\n   */\n  static _interpolateDivergingColor(rawValue, options) {\n    const pivot = options.divergingPivot || 0;\n    \n    // ピボットからの偏差を正規化\n    let normalizedValue;\n    if (rawValue <= pivot) {\n      // 青い側 (0 to 0.5)\n      normalizedValue = 0.5 * (rawValue / pivot);\n      normalizedValue = Math.max(0, Math.min(0.5, normalizedValue));\n    } else {\n      // 赤い側 (0.5 to 1)\n      normalizedValue = 0.5 + 0.5 * ((rawValue - pivot) / pivot);\n      normalizedValue = Math.max(0.5, Math.min(1, normalizedValue));\n    }\n    \n    return ColorMap._interpolateFromColorMap(normalizedValue, 'diverging');\n  }\n\n  /**\n   * Get available color map names.\n   * 利用可能なカラーマップ名を取得します。\n   * @returns {string[]} Available color map names / 利用可能なカラーマップ名\n   */\n  static getAvailableColorMaps() {\n    return Object.keys(COLOR_MAPS);\n  }\n\n  /**\n   * Check if a color map exists.\n   * カラーマップが存在するかをチェックします。\n   * @param {string} colorMapName - Color map name / カラーマップ名\n   * @returns {boolean} True if exists / 存在する場合true\n   */\n  static hasColorMap(colorMapName) {\n    return Object.prototype.hasOwnProperty.call(COLOR_MAPS, colorMapName);\n  }\n}\n","/**\n * Voxel entity creation utilities.\n * ボクセルエンティティ作成ユーティリティ。\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\n\n/**\n * Voxel entity factory class.\n * ボクセルエンティティ作成クラス。\n */\nexport class VoxelEntityFactory {\n  /**\n   * Create a box voxel entity.\n   * ボックス形状のボクセルエンティティを作成します。\n   * @param {Object} config - Entity configuration / エンティティ設定\n   * @param {Cesium.Cartesian3} config.position - Position / 位置\n   * @param {Cesium.Cartesian3} config.dimensions - Dimensions / 寸法\n   * @param {Cesium.Color} config.color - Fill color / 塗りつぶし色\n   * @param {number} config.opacity - Opacity / 不透明度\n   * @param {boolean} config.wireframe - Wireframe mode / ワイヤーフレームモード\n   * @param {Object} config.outline - Outline settings / アウトライン設定\n   * @param {Object} config.properties - Custom properties / カスタムプロパティ\n   * @param {string} config.description - Description HTML / 説明HTML\n   * @returns {Object} Entity configuration / エンティティ設定\n   */\n  static createBoxEntity(config) {\n    const {\n      position,\n      dimensions,\n      color,\n      opacity,\n      wireframe = false,\n      outline = {},\n      properties = {},\n      description = ''\n    } = config;\n\n    const entityConfig = {\n      position: position,\n      box: {\n        dimensions: dimensions,\n        outline: outline.show || false,\n        outlineColor: outline.color || Cesium.Color.WHITE,\n        outlineWidth: Math.max(outline.width || 1, 0) // 負値防止\n      },\n      properties: {\n        type: 'voxel',\n        ...properties\n      },\n      description: description\n    };\n\n    // Wireframe mode handling / ワイヤーフレームモードの処理\n    if (wireframe) {\n      entityConfig.box.material = Cesium.Color.TRANSPARENT;\n      entityConfig.box.fill = false;\n    } else {\n      entityConfig.box.material = color.withAlpha(opacity);\n      entityConfig.box.fill = true;\n    }\n\n    return entityConfig;\n  }\n\n  /**\n   * Create a polyline entity for edge outlines.\n   * エッジアウトライン用のポリラインエンティティを作成します。\n   * @param {Object} config - Polyline configuration / ポリライン設定\n   * @param {Array<Cesium.Cartesian3>} config.positions - Line positions / 線の位置\n   * @param {Cesium.Color} config.color - Line color / 線の色\n   * @param {number} config.width - Line width / 線の幅\n   * @param {Object} config.properties - Custom properties / カスタムプロパティ\n   * @returns {Object} Entity configuration / エンティティ設定\n   */\n  static createPolylineEntity(config) {\n    const {\n      positions,\n      color,\n      width = 1,\n      properties = {}\n    } = config;\n\n    return {\n      polyline: {\n        positions: positions,\n        width: width,\n        material: color,\n        arcType: Cesium.ArcType.NONE\n      },\n      properties: {\n        type: 'outline',\n        ...properties\n      }\n    };\n  }\n\n  /**\n   * Create edge polylines for a box (thick outline emulation).\n   * ボックスのエッジポリライン作成（太線アウトラインエミュレーション）。\n   * @param {Cesium.Cartesian3} centerCart - Box center position / ボックス中心位置\n   * @param {number} sizeX - X dimension / X軸寸法\n   * @param {number} sizeY - Y dimension / Y軸寸法\n   * @param {number} sizeZ - Z dimension / Z軸寸法\n   * @param {Cesium.Color} color - Line color / 線の色\n   * @param {number} width - Line width / 線の幅\n   * @returns {Array<Object>} Array of polyline entity configurations / ポリラインエンティティ設定の配列\n   */\n  static createBoxEdgePolylines(centerCart, sizeX, sizeY, sizeZ, color, width) {\n    try {\n      const halfX = sizeX / 2;\n      const halfY = sizeY / 2;\n      const halfZ = sizeZ / 2;\n      \n      // ENU座標系の変換行列を取得\n      const enu = Cesium.Transforms.eastNorthUpToFixedFrame(centerCart);\n      \n      // ローカル座標をワールド座標に変換する関数\n      const toWorld = (dx, dy, dz) => {\n        const local = new Cesium.Cartesian3(dx, dy, dz);\n        return Cesium.Matrix4.multiplyByPoint(enu, local, new Cesium.Cartesian3());\n      };\n      \n      // ボックスの8つの角\n      const corners = [\n        toWorld(-halfX, -halfY, -halfZ), // 0: 左下後\n        toWorld( halfX, -halfY, -halfZ), // 1: 右下後\n        toWorld( halfX,  halfY, -halfZ), // 2: 右上後\n        toWorld(-halfX,  halfY, -halfZ), // 3: 左上後\n        toWorld(-halfX, -halfY,  halfZ), // 4: 左下前\n        toWorld( halfX, -halfY,  halfZ), // 5: 右下前\n        toWorld( halfX,  halfY,  halfZ), // 6: 右上前\n        toWorld(-halfX,  halfY,  halfZ)  // 7: 左上前\n      ];\n      \n      // ボックスの12本のエッジ\n      const edges = [\n        [0, 1], [1, 2], [2, 3], [3, 0], // 後面の4本\n        [4, 5], [5, 6], [6, 7], [7, 4], // 前面の4本\n        [0, 4], [1, 5], [2, 6], [3, 7]  // 前後をつなぐ4本\n      ];\n      \n      // 各エッジのポリラインエンティティ設定を作成\n      return edges.map(([i, j]) => \n        VoxelEntityFactory.createPolylineEntity({\n          positions: [corners[i], corners[j]],\n          color: color,\n          width: width,\n          properties: {\n            edgeType: 'thick-outline-emulation'\n          }\n        })\n      );\n      \n    } catch (error) {\n      Logger.warn('Edge polyline creation failed:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Create a debug bounding box entity.\n   * デバッグ用バウンディングボックスエンティティを作成します。\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} bounds.minLon - Minimum longitude / 最小経度\n   * @param {Object} bounds.maxLon - Maximum longitude / 最大経度\n   * @param {Object} bounds.minLat - Minimum latitude / 最小緯度\n   * @param {Object} bounds.maxLat - Maximum latitude / 最大緯度\n   * @param {Object} bounds.minAlt - Minimum altitude / 最小高度\n   * @param {Object} bounds.maxAlt - Maximum altitude / 最大高度\n   * @returns {Object|null} Entity configuration or null if bounds invalid / エンティティ設定または無効な場合null\n   */\n  static createDebugBoundingBox(bounds) {\n    if (!bounds) return null;\n\n    try {\n      // 中心点を計算\n      const centerLon = (bounds.minLon + bounds.maxLon) / 2;\n      const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n      const centerAlt = (bounds.minAlt + bounds.maxAlt) / 2;\n      \n      // サイズ計算（概算）\n      const widthMeters = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);\n      const depthMeters = (bounds.maxLat - bounds.minLat) * 111000;\n      const heightMeters = bounds.maxAlt - bounds.minAlt;\n      \n      return {\n        position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt),\n        box: {\n          dimensions: new Cesium.Cartesian3(widthMeters, depthMeters, heightMeters),\n          material: Cesium.Color.YELLOW.withAlpha(0.1),\n          outline: true,\n          outlineColor: Cesium.Color.YELLOW.withAlpha(0.3),\n          outlineWidth: 2\n        },\n        properties: {\n          type: 'debug-bounds'\n        },\n        description: `バウンディングボックス<br>サイズ: ${widthMeters.toFixed(1)} x ${depthMeters.toFixed(1)} x ${heightMeters.toFixed(1)} m`\n      };\n      \n    } catch (error) {\n      Logger.warn('Failed to create debug bounding box:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Create inset outline polylines.\n   * インセットアウトラインポリラインを作成します。\n   * @param {number} centerLon - Center longitude / 中心経度\n   * @param {number} centerLat - Center latitude / 中心緯度\n   * @param {number} centerAlt - Center altitude / 中心高度\n   * @param {number} sizeX - X dimension / X軸寸法\n   * @param {number} sizeY - Y dimension / Y軸寸法\n   * @param {number} sizeZ - Z dimension / Z軸寸法\n   * @param {Cesium.Color} color - Outline color / アウトライン色\n   * @param {number} width - Line width / 線の幅\n   * @param {number} insetAmount - Inset amount in meters / インセット量（メートル）\n   * @returns {Array<Object>} Array of polyline entity configurations / ポリラインエンティティ設定の配列\n   */\n  static createInsetOutlinePolylines(centerLon, centerLat, centerAlt, sizeX, sizeY, sizeZ, color, width, insetAmount) {\n    try {\n      const centerCart = Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt);\n      \n      // インセット適用後のサイズ\n      const insetSizeX = Math.max(sizeX - insetAmount * 2, sizeX * 0.1);\n      const insetSizeY = Math.max(sizeY - insetAmount * 2, sizeY * 0.1);\n      const insetSizeZ = Math.max(sizeZ - insetAmount * 2, sizeZ * 0.1);\n      \n      return VoxelEntityFactory.createBoxEdgePolylines(\n        centerCart,\n        insetSizeX,\n        insetSizeY,\n        insetSizeZ,\n        color,\n        width\n      ).map(config => ({\n        ...config,\n        properties: {\n          ...config.properties,\n          edgeType: 'inset-outline'\n        }\n      }));\n      \n    } catch (error) {\n      Logger.warn('Failed to create inset outline:', error);\n      return [];\n    }\n  }\n}\n","/**\n * Debug rendering utilities.\n * デバッグ描画ユーティリティ。\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\nimport { VoxelEntityFactory } from './VoxelEntityFactory.js';\n\n/**\n * Debug renderer class for development and troubleshooting.\n * 開発およびトラブルシューティング用のデバッグレンダラークラス。\n */\nexport class DebugRenderer {\n  /**\n   * Constructor.\n   * @param {Cesium.Viewer} viewer - Cesium viewer instance / Cesiumビューアインスタンス\n   */\n  constructor(viewer) {\n    this.viewer = viewer;\n    this.debugEntities = [];\n  }\n\n  /**\n   * Check if debug bounds should be shown.\n   * デバッグ境界を表示すべきかチェックします。\n   * @param {Object|boolean} debugOptions - Debug options / デバッグオプション\n   * @returns {boolean} True if bounds should be shown / 境界を表示する場合true\n   */\n  shouldShowBounds(debugOptions) {\n    if (!debugOptions) {\n      return false;\n    }\n    \n    if (typeof debugOptions === 'boolean') {\n      // 従来の動作：debugがtrueの場合はバウンディングボックス表示\n      return debugOptions;\n    }\n    \n    if (typeof debugOptions === 'object' && debugOptions !== null) {\n      // 新しい動作：debug.showBoundsで明示的に制御\n      return debugOptions.showBounds === true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Render debug bounding box.\n   * デバッグ用バウンディングボックスを描画します。\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} debugOptions - Debug options / デバッグオプション\n   * @returns {boolean} True if successfully rendered / 正常に描画された場合true\n   */\n  renderBoundingBox(bounds, debugOptions) {\n    if (!this.shouldShowBounds(debugOptions)) {\n      return false;\n    }\n\n    try {\n      const boundingBoxConfig = VoxelEntityFactory.createDebugBoundingBox(bounds);\n      if (!boundingBoxConfig) {\n        Logger.warn('Failed to create debug bounding box configuration');\n        return false;\n      }\n\n      const boundingBox = this.viewer.entities.add(boundingBoxConfig);\n      this.debugEntities.push(boundingBox);\n      \n      Logger.debug('Debug bounding box added:', {\n        center: { \n          lon: (bounds.minLon + bounds.maxLon) / 2, \n          lat: (bounds.minLat + bounds.maxLat) / 2, \n          alt: (bounds.minAlt + bounds.maxAlt) / 2 \n        },\n        size: { \n          width: (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(((bounds.minLat + bounds.maxLat) / 2) * Math.PI / 180), \n          depth: (bounds.maxLat - bounds.minLat) * 111000, \n          height: bounds.maxAlt - bounds.minAlt \n        }\n      });\n      \n      return true;\n      \n    } catch (error) {\n      Logger.warn('Failed to render debug bounding box:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Render debug grid lines.\n   * デバッグ用グリッド線を描画します。\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} grid - Grid information / グリッド情報\n   * @param {Object} debugOptions - Debug options / デバッグオプション\n   * @returns {number} Number of grid lines rendered / 描画されたグリッド線数\n   */\n  renderGridLines(bounds, grid, debugOptions) {\n    if (!debugOptions || !debugOptions.showGrid) {\n      return 0;\n    }\n\n    try {\n      let renderedLines = 0;\n      \n      // X軸方向のグリッド線（経度方向）\n      for (let x = 0; x <= grid.numVoxelsX; x++) {\n        const lon = bounds.minLon + x * (bounds.maxLon - bounds.minLon) / grid.numVoxelsX;\n        \n        const gridLine = this.viewer.entities.add({\n          polyline: {\n            positions: [\n              Cesium.Cartesian3.fromDegrees(lon, bounds.minLat, bounds.minAlt),\n              Cesium.Cartesian3.fromDegrees(lon, bounds.maxLat, bounds.minAlt),\n              Cesium.Cartesian3.fromDegrees(lon, bounds.maxLat, bounds.maxAlt),\n              Cesium.Cartesian3.fromDegrees(lon, bounds.minLat, bounds.maxAlt),\n              Cesium.Cartesian3.fromDegrees(lon, bounds.minLat, bounds.minAlt)\n            ],\n            width: 1,\n            material: Cesium.Color.CYAN.withAlpha(0.3),\n            arcType: Cesium.ArcType.NONE\n          },\n          properties: {\n            type: 'debug-grid',\n            direction: 'x',\n            index: x\n          }\n        });\n        \n        this.debugEntities.push(gridLine);\n        renderedLines++;\n      }\n      \n      // Y軸方向のグリッド線（緯度方向）\n      for (let y = 0; y <= grid.numVoxelsY; y++) {\n        const lat = bounds.minLat + y * (bounds.maxLat - bounds.minLat) / grid.numVoxelsY;\n        \n        const gridLine = this.viewer.entities.add({\n          polyline: {\n            positions: [\n              Cesium.Cartesian3.fromDegrees(bounds.minLon, lat, bounds.minAlt),\n              Cesium.Cartesian3.fromDegrees(bounds.maxLon, lat, bounds.minAlt),\n              Cesium.Cartesian3.fromDegrees(bounds.maxLon, lat, bounds.maxAlt),\n              Cesium.Cartesian3.fromDegrees(bounds.minLon, lat, bounds.maxAlt),\n              Cesium.Cartesian3.fromDegrees(bounds.minLon, lat, bounds.minAlt)\n            ],\n            width: 1,\n            material: Cesium.Color.MAGENTA.withAlpha(0.3),\n            arcType: Cesium.ArcType.NONE\n          },\n          properties: {\n            type: 'debug-grid',\n            direction: 'y',\n            index: y\n          }\n        });\n        \n        this.debugEntities.push(gridLine);\n        renderedLines++;\n      }\n      \n      Logger.debug(`Debug grid rendered: ${renderedLines} lines`);\n      return renderedLines;\n      \n    } catch (error) {\n      Logger.warn('Failed to render debug grid:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Render debug statistics overlay.\n   * デバッグ統計情報オーバーレイを描画します。\n   * @param {Object} stats - Rendering statistics / 描画統計情報\n   * @param {Object} debugOptions - Debug options / デバッグオプション\n   * @returns {boolean} True if successfully rendered / 正常に描画された場合true\n   */\n  renderStatsOverlay(stats, debugOptions) {\n    if (!debugOptions || !debugOptions.showStats) {\n      return false;\n    }\n\n    try {\n      // Create stats HTML overlay\n      const _statsHtml = `\n        <div style=\"\n          position: absolute;\n          top: 10px;\n          left: 10px;\n          background: rgba(0,0,0,0.8);\n          color: white;\n          padding: 10px;\n          border-radius: 5px;\n          font-family: monospace;\n          font-size: 12px;\n          z-index: 1000;\n        \">\n          <h4 style=\"margin: 0 0 10px 0;\">Debug Stats</h4>\n          <div>Total Voxels: ${stats.totalVoxels || 0}</div>\n          <div>Rendered Voxels: ${stats.renderedVoxels || 0}</div>\n          <div>Render Time: ${stats.renderTime || 0}ms</div>\n          <div>Memory Usage: ${stats.memoryUsage || 'N/A'}</div>\n        </div>\n      `;\n      \n      // Note: In a real implementation, you would need to handle DOM overlay creation\n      // This is a simplified version for demonstration\n      Logger.debug('Debug stats overlay would be rendered:', stats);\n      \n      return true;\n      \n    } catch (error) {\n      Logger.warn('Failed to render debug stats overlay:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all debug entities.\n   * 全てのデバッグエンティティをクリアします。\n   */\n  clear() {\n    Logger.debug('DebugRenderer.clear - Removing', this.debugEntities.length, 'debug entities');\n    \n    this.debugEntities.forEach(entity => {\n      try {\n        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n        \n        if (entity && !isDestroyed) {\n          this.viewer.entities.remove(entity);\n        }\n      } catch (error) {\n        Logger.warn('Debug entity removal error:', error);\n      }\n    });\n    \n    this.debugEntities = [];\n  }\n\n  /**\n   * Get debug entity count.\n   * デバッグエンティティ数を取得します。\n   * @returns {number} Number of debug entities / デバッグエンティティ数\n   */\n  getEntityCount() {\n    return this.debugEntities.length;\n  }\n\n  /**\n   * Log debug information.\n   * デバッグ情報をログ出力します。\n   * @param {string} category - Debug category / デバッグカテゴリ\n   * @param {Object} data - Debug data / デバッグデータ\n   */\n  logDebugInfo(category, data) {\n    Logger.debug(`[${category}]`, data);\n  }\n}\n","/**\n * Controller for adaptive outline parameter calculation.\n * 適応的枠線パラメータ計算のコントローラー。\n * \n * Handles dynamic outline width, opacity, and emulation decisions based on\n * voxel density, camera distance, and neighborhood analysis.\n * ボクセル密度、カメラ距離、近傍分析に基づく動的枠線幅、不透明度、\n * エミュレーション判定を処理します。\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\n\n/**\n * AdaptiveOutlineController class for dynamic outline parameter calculation.\n * 動的枠線パラメータ計算のためのAdaptiveOutlineControllerクラス。\n */\nexport class AdaptiveOutlineController {\n  /**\n   * Constructor\n   * @param {Object} options - Configuration options / 設定オプション\n   */\n  constructor(options = {}) {\n    this.options = {\n      neighborhoodRadius: 50,\n      densityThreshold: 5,\n      cameraDistanceFactor: 1.0,\n      overlapRiskFactor: 0.3,\n      ...options\n    };\n  }\n\n  /**\n   * Calculate adaptive outline parameters for a voxel.\n   * ボクセルの適応的枠線パラメータを計算します。\n   * \n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {boolean} isTopN - Whether it is TopN / TopNボクセルかどうか\n   * @param {Map} voxelData - All voxel data / 全ボクセルデータ\n   * @param {Object} statistics - Statistics / 統計情報\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesiumビューワー\n   * @param {Object} baseOptions - Base rendering options / 基本描画オプション\n   * @returns {Object} Adaptive parameters / 適応的パラメータ\n   */\n  calculateAdaptiveParams(voxelInfo, isTopN, voxelData, statistics, viewer, baseOptions) {\n    if (!baseOptions.adaptiveOutlines) {\n      return {\n        outlineWidth: null,\n        boxOpacity: null,\n        outlineOpacity: null,\n        shouldUseEmulation: false\n      };\n    }\n\n    const { x, y, z, count } = voxelInfo;\n    const normalizedDensity = statistics.maxCount > statistics.minCount ? \n      (count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;\n\n    // Calculate neighborhood density / 近傍密度を計算\n    const neighborDensity = this._calculateNeighborhoodDensity(x, y, z, voxelData);\n    \n    // Calculate camera distance factor / カメラ距離係数を計算\n    const cameraFactor = this._calculateCameraDistanceFactor(voxelInfo, viewer);\n    \n    // Calculate overlap risk / 重複リスクを計算\n    const overlapRisk = this._calculateOverlapRisk(voxelInfo, voxelData, viewer);\n\n    // Determine outline width based on preset / プリセットに基づく枠線幅を決定\n    const outlineWidth = this._calculateOutlineWidth(\n      normalizedDensity, \n      neighborDensity, \n      cameraFactor, \n      baseOptions.outlineWidthPreset,\n      baseOptions.outlineWidth,\n      isTopN\n    );\n\n    // Calculate adaptive opacities / 適応的不透明度を計算\n    const boxOpacity = this._calculateBoxOpacity(normalizedDensity, isTopN, baseOptions.opacity);\n    const outlineOpacity = this._calculateOutlineOpacity(\n      normalizedDensity, \n      neighborDensity, \n      cameraFactor\n    );\n\n    // Determine if emulation should be used / エミュレーション使用判定\n    const shouldUseEmulation = this._shouldUseEmulation(\n      overlapRisk, \n      neighborDensity, \n      baseOptions.outlineRenderMode\n    );\n\n    Logger.debug('Calculated adaptive params for voxel:', {\n      voxel: { x, y, z, count },\n      normalizedDensity,\n      neighborDensity,\n      cameraFactor,\n      overlapRisk,\n      result: { outlineWidth, boxOpacity, outlineOpacity, shouldUseEmulation }\n    });\n\n    return {\n      outlineWidth,\n      boxOpacity,\n      outlineOpacity,\n      shouldUseEmulation\n    };\n  }\n\n  /**\n   * Calculate neighborhood density around a voxel.\n   * ボクセル周辺の近傍密度を計算します。\n   * \n   * @param {number} x - X coordinate / X座標\n   * @param {number} y - Y coordinate / Y座標\n   * @param {number} z - Z coordinate / Z座標\n   * @param {Map} voxelData - All voxel data / 全ボクセルデータ\n   * @returns {number} Neighborhood density / 近傍密度\n   * @private\n   */\n  _calculateNeighborhoodDensity(x, y, z, voxelData) {\n    const radius = Math.floor(this.options.neighborhoodRadius / 100); // Convert to grid units\n    let totalCount = 0;\n    let voxelCount = 0;\n\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          const key = `${x + dx},${y + dy},${z + dz}`;\n          const neighbor = voxelData.get(key);\n          if (neighbor) {\n            totalCount += neighbor.count;\n            voxelCount++;\n          }\n        }\n      }\n    }\n\n    return voxelCount > 0 ? totalCount / voxelCount : 0;\n  }\n\n  /**\n   * Calculate camera distance factor for adaptive rendering.\n   * 適応的描画のためのカメラ距離係数を計算します。\n   * \n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesiumビューワー\n   * @returns {number} Camera distance factor / カメラ距離係数\n   * @private\n   */\n  _calculateCameraDistanceFactor(voxelInfo, viewer) {\n    // Fallback when viewer camera or position is unavailable (tests/mocks)\n    if (!viewer || !viewer.camera || !voxelInfo || !voxelInfo.position) {\n      return 1.0;\n    }\n    const camera = viewer.camera;\n    const voxelPosition = voxelInfo.position;\n    const cameraPosition = camera.position || new Cesium.Cartesian3(0, 0, 1000);\n    const distance = Cesium.Cartesian3.distance(cameraPosition, voxelPosition);\n    const normalizedDistance = Math.min(distance / 10000, 1.0); // Normalize to 0-1\n    \n    return 1.0 - (normalizedDistance * this.options.cameraDistanceFactor);\n  }\n\n  /**\n   * Calculate overlap risk between nearby voxels.\n   * 近接ボクセル間の重複リスクを計算します。\n   * \n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {Map} voxelData - All voxel data / 全ボクセルデータ\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesiumビューワー\n   * @returns {number} Overlap risk factor / 重複リスク係数\n   * @private\n   */\n_calculateOverlapRisk(voxelInfo, voxelData, _viewer) {\n    const { x, y, z } = voxelInfo;\n    let adjacentCount = 0;\n    \n    // Check immediate neighbors / 隣接ボクセルをチェック\n    const neighbors = [\n      [x+1, y, z], [x-1, y, z],\n      [x, y+1, z], [x, y-1, z],\n      [x, y, z+1], [x, y, z-1]\n    ];\n    \n    for (const [nx, ny, nz] of neighbors) {\n      const key = `${nx},${ny},${nz}`;\n      if (voxelData.has(key)) {\n        adjacentCount++;\n      }\n    }\n    \n    const adjacencyRatio = adjacentCount / 6;\n    return adjacencyRatio * this.options.overlapRiskFactor;\n  }\n\n  /**\n   * Calculate outline width based on preset and adaptive factors.\n   * プリセットと適応的要因に基づく枠線幅を計算します。\n   * \n   * @param {number} normalizedDensity - Normalized density / 正規化密度\n   * @param {number} neighborDensity - Neighborhood density / 近傍密度\n   * @param {number} cameraFactor - Camera distance factor / カメラ距離係数\n   * @param {string} preset - Width preset / 幅プリセット\n   * @param {number} baseWidth - Base outline width / 基本枠線幅\n   * @returns {number} Calculated outline width / 計算された枠線幅\n   * @private\n   */\n  _calculateOutlineWidth(normalizedDensity, neighborDensity, cameraFactor, preset, baseWidth, isTopN = false) {\n    switch (preset) {\n      case 'adaptive-density':\n        return neighborDensity > this.options.densityThreshold\n          ? Math.max(0.5, baseWidth * (0.5 + normalizedDensity * 0.5))\n          : baseWidth;\n\n      case 'topn-focus':\n        return isTopN\n          ? baseWidth * (1.5 + normalizedDensity * 0.5)\n          : Math.max(0.5, baseWidth * 0.7);\n      \n      case 'density-based':\n        return baseWidth * (0.5 + normalizedDensity * 1.5);\n      \n      case 'distance-adaptive':\n        return baseWidth * (0.8 + cameraFactor * 0.4);\n      \n      case 'neighborhood-aware': {\n        const densityFactor = neighborDensity > this.options.densityThreshold ? 0.7 : 1.2;\n        return baseWidth * densityFactor;\n      }\n      \n      case 'uniform':\n      default:\n        return baseWidth;\n    }\n  }\n\n  /**\n   * Calculate adaptive box opacity.\n   * 適応的ボックス不透明度を計算します。\n   * \n   * @param {number} normalizedDensity - Normalized density / 正規化密度\n   * @param {boolean} isTopN - Whether it is TopN / TopNボクセルかどうか\n   * @param {number} baseOpacity - Base opacity / 基本不透明度\n   * @returns {number} Calculated box opacity / 計算されたボックス不透明度\n   * @private\n   */\n  _calculateBoxOpacity(normalizedDensity, isTopN, baseOpacity) {\n    if (isTopN) {\n      return Math.min(baseOpacity * 1.2, 1.0);\n    }\n    \n    return baseOpacity * (0.6 + normalizedDensity * 0.4);\n  }\n\n  /**\n   * Calculate adaptive outline opacity.\n   * 適応的枠線不透明度を計算します。\n   * \n   * @param {number} normalizedDensity - Normalized density / 正規化密度\n   * @param {number} neighborDensity - Neighborhood density / 近傍密度\n   * @param {number} cameraFactor - Camera distance factor / カメラ距離係数\n   * @returns {number} Calculated outline opacity / 計算された枠線不透明度\n   * @private\n   */\n  _calculateOutlineOpacity(normalizedDensity, neighborDensity, cameraFactor) {\n    const densityComponent = 0.7 + normalizedDensity * 0.3;\n    const neighborComponent = neighborDensity > this.options.densityThreshold ? 0.9 : 1.0;\n    const cameraComponent = 0.8 + cameraFactor * 0.2;\n    \n    return Math.min(densityComponent * neighborComponent * cameraComponent, 1.0);\n  }\n\n  /**\n   * Determine if emulation mode should be used.\n   * エミュレーションモードを使用すべきかどうかを判定します。\n   * \n   * @param {number} overlapRisk - Overlap risk factor / 重複リスク係数\n   * @param {number} neighborDensity - Neighborhood density / 近傍密度\n   * @param {string} renderMode - Outline render mode / 枠線描画モード\n   * @returns {boolean} Whether to use emulation / エミュレーション使用フラグ\n   * @private\n   */\n  _shouldUseEmulation(overlapRisk, neighborDensity, renderMode) {\n    if (renderMode === 'emulation-only') {\n      return true;\n    }\n    \n    if (renderMode === 'standard') {\n      return false;\n    }\n    \n    // For 'inset' mode, use emulation in high-density areas / 'inset'モードでは高密度エリアでエミュレーション使用\n    return overlapRisk > 0.5 && neighborDensity > this.options.densityThreshold;\n  }\n\n  /**\n   * Update adaptive parameters configuration.\n   * 適応的パラメータ設定を更新します。\n   * \n   * @param {Object} newOptions - New options / 新しいオプション\n   */\n  updateOptions(newOptions) {\n    this.options = { ...this.options, ...newOptions };\n    Logger.debug('AdaptiveOutlineController options updated:', this.options);\n  }\n}\n","/**\n * Renderer for various outline modes.\n * 様々な枠線モードのレンダラー。\n * \n * Handles standard, inset, and emulation-only outline rendering modes.\n * 標準、インセット、エミュレーションのみの枠線描画モードを処理します。\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\nimport { VoxelEntityFactory } from '../voxel/VoxelEntityFactory.js';\n\n/**\n * OutlineRenderer class for handling different outline rendering modes.\n * 異なる枠線描画モードを処理するOutlineRendererクラス。\n */\nexport class OutlineRenderer {\n  /**\n   * Constructor\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesiumビューワー\n   */\n  constructor(viewer) {\n    this.viewer = viewer;\n  }\n\n  /**\n   * Render outline for a voxel based on the specified mode.\n   * 指定されたモードに基づいてボクセルの枠線を描画します。\n   * \n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {Object} outlineOptions - Outline options / 枠線オプション\n   * @param {Object} adaptiveParams - Adaptive parameters / 適応的パラメータ\n   * @returns {Array} Created outline entities / 作成された枠線エンティティ\n   */\n  renderOutline(voxelInfo, outlineOptions, adaptiveParams = {}) {\n    const { outlineRenderMode } = outlineOptions;\n    \n    Logger.debug('Rendering outline for voxel:', {\n      voxel: voxelInfo,\n      mode: outlineRenderMode,\n      adaptive: adaptiveParams\n    });\n\n    switch (outlineRenderMode) {\n      case 'standard': {\n        const entities = [];\n        // Standard outline is already handled on the box entity (VoxelRenderer)\n        // If inset is requested, add inset outline as an additional entity\n        if ((outlineOptions.outlineInset || 0) > 0 && this._shouldApplyInsetOutline(voxelInfo, outlineOptions)) {\n          entities.push(...this._renderInsetOutline(voxelInfo, outlineOptions, adaptiveParams));\n        }\n        return entities;\n      }\n      \n      case 'inset':\n        return this._renderInsetOutline(voxelInfo, outlineOptions, adaptiveParams);\n      \n      case 'emulation-only':\n        return this._renderEmulationOutline(voxelInfo, outlineOptions, adaptiveParams);\n      \n      default:\n        Logger.warn('Unknown outline render mode:', outlineRenderMode);\n        return this._renderStandardOutline(voxelInfo, outlineOptions, adaptiveParams);\n    }\n  }\n\n  /**\n   * Determine if inset outline should be applied based on mode and TopN.\n   * インセット枠線を適用すべきか判定します。\n   * @param {Object} voxelInfo - Voxel information (may include isTopN) / ボクセル情報\n   * @param {Object} outlineOptions - Outline options / 枠線オプション\n   * @returns {boolean}\n   * @private\n   */\n  _shouldApplyInsetOutline(voxelInfo, outlineOptions) {\n    const mode = outlineOptions.outlineInsetMode || 'all';\n    if (mode === 'topn') return !!voxelInfo.isTopN;\n    return true;\n  }\n\n  /**\n   * Render standard outline mode.\n   * 標準枠線モードを描画します。\n   * \n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {Object} outlineOptions - Outline options / 枠線オプション\n   * @param {Object} adaptiveParams - Adaptive parameters / 適応的パラメータ\n   * @returns {Array} Created outline entities / 作成された枠線エンティティ\n   * @private\n   */\n  _renderStandardOutline(voxelInfo, outlineOptions, adaptiveParams) {\n    const outlineWidth = adaptiveParams.outlineWidth || outlineOptions.outlineWidth;\n    const outlineOpacity = adaptiveParams.outlineOpacity || 1.0;\n    // Use fromBytes to avoid dependency on fromCssColorString in tests\n    const outlineColor = Cesium.Color.fromBytes(255, 255, 255, Math.round(255 * outlineOpacity));\n    \n    // Create polyline entities for box edges / ボックスエッジのポリラインエンティティを作成\n    const centerCart = voxelInfo.position;\n    const sizeX = voxelInfo.width;\n    const sizeY = voxelInfo.depth;\n    const sizeZ = voxelInfo.height;\n    const polylineEntities = VoxelEntityFactory.createBoxEdgePolylines(\n      centerCart,\n      sizeX,\n      sizeY,\n      sizeZ,\n      outlineColor,\n      outlineWidth\n    );\n\n    return polylineEntities;\n  }\n\n  /**\n   * Render inset outline mode.\n   * インセット枠線モードを描画します。\n   * \n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {Object} outlineOptions - Outline options / 枠線オプション\n   * @param {Object} adaptiveParams - Adaptive parameters / 適応的パラメータ\n   * @returns {Array} Created outline entities / 作成された枠線エンティティ\n   * @private\n   */\n  _renderInsetOutline(voxelInfo, outlineOptions, adaptiveParams) {\n    const { outlineInset } = outlineOptions;\n    \n    if (outlineInset <= 0) {\n      // No inset, fall back to standard mode / インセットなし、標準モードにフォールバック\n      return this._renderStandardOutline(voxelInfo, outlineOptions, adaptiveParams);\n    }\n\n    // Use emulation for high overlap risk areas / 高重複リスクエリアではエミュレーション使用\n    if (adaptiveParams.shouldUseEmulation) {\n      return this._renderEmulationOutline(voxelInfo, outlineOptions, adaptiveParams);\n    }\n\n    // Create inset voxel with reduced dimensions (computed inline below)\n    \n    const outlineWidth = adaptiveParams.outlineWidth || outlineOptions.outlineWidth;\n    const outlineOpacity = adaptiveParams.outlineOpacity || 1.0;\n    const centerCart = voxelInfo.position;\n    // Enforce 20% max inset per axis (ADR-0004)\n    const maxInsetX = voxelInfo.width * 0.2;\n    const maxInsetY = voxelInfo.depth * 0.2;\n    const maxInsetZ = voxelInfo.height * 0.2;\n    const effInsetX = Math.min(outlineInset, maxInsetX);\n    const effInsetY = Math.min(outlineInset, maxInsetY);\n    const effInsetZ = Math.min(outlineInset, maxInsetZ);\n    const sizeX = Math.max(voxelInfo.width - 2 * effInsetX, voxelInfo.width * 0.1);\n    const sizeY = Math.max(voxelInfo.depth - 2 * effInsetY, voxelInfo.depth * 0.1);\n    const sizeZ = Math.max(voxelInfo.height - 2 * effInsetZ, voxelInfo.height * 0.1);\n    const outlineColor = Cesium.Color.fromBytes(255, 255, 255, Math.round(255 * outlineOpacity));\n\n    // Create a box-only outline entity (no fill) to match prior behavior\n    const boxEntity = {\n      position: centerCart,\n      box: {\n        dimensions: new Cesium.Cartesian3(sizeX, sizeY, sizeZ),\n        material: Cesium.Color.TRANSPARENT,\n        outline: true,\n        outlineColor: outlineColor,\n        outlineWidth: Math.max(outlineWidth || 1, 1),\n        fill: false\n      },\n      properties: {\n        type: 'voxel-inset-outline',\n        parentKey: voxelInfo.key,\n        insetSize: { x: sizeX, y: sizeY, z: sizeZ }\n      }\n    };\n\n    Logger.debug('Created inset outline with offset:', outlineInset);\n    return [boxEntity];\n  }\n\n  /**\n   * Render emulation-only outline mode.\n   * エミュレーションのみの枠線モードを描画します。\n   * \n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {Object} outlineOptions - Outline options / 枠線オプション\n   * @param {Object} adaptiveParams - Adaptive parameters / 適応的パラメータ\n   * @returns {Array} Created outline entities / 作成された枠線エンティティ\n   * @private\n   */\n  _renderEmulationOutline(voxelInfo, outlineOptions, adaptiveParams) {\n    const outlineWidth = adaptiveParams.outlineWidth || outlineOptions.outlineWidth;\n    const outlineOpacity = adaptiveParams.outlineOpacity || 1.0;\n    // Use darker outline color for emulation mode without CSS dependency\n    const outlineColor = Cesium.Color.fromBytes(51, 51, 51, Math.round(255 * outlineOpacity));\n    \n    // Create thicker outline for emulation / エミュレーション用の太い枠線を作成\n    const emulationWidth = outlineWidth * 1.5;\n    \n    const centerCart = voxelInfo.position;\n    const sizeX = voxelInfo.width;\n    const sizeY = voxelInfo.depth;\n    const sizeZ = voxelInfo.height;\n    const polylineEntities = VoxelEntityFactory.createBoxEdgePolylines(\n      centerCart,\n      sizeX,\n      sizeY,\n      sizeZ,\n      outlineColor,\n      emulationWidth\n    );\n\n    Logger.debug('Created emulation outline with enhanced width:', emulationWidth);\n    return polylineEntities;\n  }\n\n  /**\n   * Create inset voxel information with reduced dimensions.\n   * 縮小された寸法でインセットボクセル情報を作成します。\n   * \n   * @param {Object} voxelInfo - Original voxel information / 元のボクセル情報\n   * @param {number} insetValue - Inset offset in meters / インセットオフセット（メートル）\n   * @param {string} insetMode - Inset application mode / インセット適用モード\n   * @returns {Object} Inset voxel information / インセットボクセル情報\n   * @private\n   */\n  _createInsetVoxelInfo(voxelInfo, insetValue, insetMode) {\n    const insetVoxelInfo = { ...voxelInfo };\n    \n    // Apply inset to dimensions based on mode / モードに基づいて寸法にインセットを適用\n    switch (insetMode) {\n      case 'all':\n        insetVoxelInfo.width = Math.max(0.1, voxelInfo.width - insetValue * 2);\n        insetVoxelInfo.height = Math.max(0.1, voxelInfo.height - insetValue * 2);\n        insetVoxelInfo.depth = Math.max(0.1, voxelInfo.depth - insetValue * 2);\n        break;\n      \n      case 'horizontal':\n        insetVoxelInfo.width = Math.max(0.1, voxelInfo.width - insetValue * 2);\n        insetVoxelInfo.depth = Math.max(0.1, voxelInfo.depth - insetValue * 2);\n        // height remains unchanged / 高さは変更なし\n        break;\n      \n      case 'vertical':\n        insetVoxelInfo.height = Math.max(0.1, voxelInfo.height - insetValue * 2);\n        // width and depth remain unchanged / 幅と奥行きは変更なし\n        break;\n      \n      default:\n        Logger.warn('Unknown inset mode:', insetMode);\n        // Fall back to 'all' mode / 'all'モードにフォールバック\n        insetVoxelInfo.width = Math.max(0.1, voxelInfo.width - insetValue * 2);\n        insetVoxelInfo.height = Math.max(0.1, voxelInfo.height - insetValue * 2);\n        insetVoxelInfo.depth = Math.max(0.1, voxelInfo.depth - insetValue * 2);\n        break;\n    }\n    \n    Logger.debug('Created inset voxel info:', {\n      original: {\n        width: voxelInfo.width,\n        height: voxelInfo.height,\n        depth: voxelInfo.depth\n      },\n      inset: {\n        width: insetVoxelInfo.width,\n        height: insetVoxelInfo.height,\n        depth: insetVoxelInfo.depth\n      },\n      mode: insetMode,\n      offset: insetValue\n    });\n    \n    return insetVoxelInfo;\n  }\n\n  /**\n   * Check if outline should be rendered for a voxel.\n   * ボクセルに対して枠線を描画すべきかどうかをチェックします。\n   * \n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {Object} outlineOptions - Outline options / 枠線オプション\n   * @returns {boolean} Whether outline should be rendered / 枠線を描画すべきかどうか\n   */\n  shouldRenderOutline(voxelInfo, outlineOptions) {\n    if (!outlineOptions.showOutline) {\n      return false;\n    }\n    \n    // Always render outline for non-empty voxels when outline is enabled\n    // 枠線が有効な場合、空でないボクセルには常に枠線を描画\n    return voxelInfo.count > 0;\n  }\n\n  /**\n   * Get outline color based on voxel information and options.\n   * ボクセル情報とオプションに基づいて枠線色を取得します。\n   * \n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {Object} outlineOptions - Outline options / 枠線オプション\n   * @param {boolean} isTopN - Whether it is TopN / TopNボクセルかどうか\n   * @returns {Cesium.Color} Outline color / 枠線色\n   */\n  getOutlineColor(voxelInfo, outlineOptions, isTopN = false) {\n    if (isTopN) {\n      return Cesium.Color.fromBytes(255, 255, 0, 255); // Yellow\n    }\n    if (outlineOptions.outlineRenderMode === 'emulation-only') {\n      return Cesium.Color.fromBytes(51, 51, 51, 255); // Dark\n    }\n    return Cesium.Color.fromBytes(255, 255, 255, 255); // White\n  }\n}\n","/**\n * @fileoverview InfoBox用のボクセル説明文生成モジュール\n * \n * ADR-0008 Phase 3: VoxelRendererからDescriptionBuilder機能を分離\n * \n * @author cesium-heatbox\n * @version 0.1.10\n * @since 0.1.10\n */\n\n/**\n * InfoBox用のボクセル説明文生成クラス\n * \n * VoxelRendererから説明文生成機能を分離し、単一責任の原則に従って\n * InfoBox表示用のHTML生成を専門に行います。\n * \n * @class DescriptionBuilder\n * @since 0.1.10\n */\nexport class DescriptionBuilder {\n  /**\n   * DescriptionBuilderのコンストラクタ\n   * \n   * @param {Object} [options={}] - 設定オプション\n   * @param {string} [options.fontFamily='Arial, sans-serif'] - フォントファミリー\n   * @param {string} [options.containerPadding='10px'] - コンテナパディング\n   * @param {string} [options.headerMargin='0'] - ヘッダーマージン\n   * @param {string} [options.tableWidth='100%'] - テーブル幅\n   */\n  constructor(options = {}) {\n    this.options = {\n      fontFamily: options.fontFamily || 'Arial, sans-serif',\n      containerPadding: options.containerPadding || '10px',\n      headerMargin: options.headerMargin || '0',\n      tableWidth: options.tableWidth || '100%',\n      ...options\n    };\n  }\n\n  /**\n   * ボクセル用の説明文HTMLを生成\n   * \n   * @param {Object} voxelInfo - ボクセル情報\n   * @param {number} voxelInfo.x - X軸インデックス\n   * @param {number} voxelInfo.y - Y軸インデックス\n   * @param {number} voxelInfo.z - Z軸インデックス\n   * @param {number} voxelInfo.count - エンティティ数\n   * @param {string} voxelKey - ボクセルキー\n   * @returns {string} HTML形式の説明文\n   */\n  createVoxelDescription(voxelInfo, voxelKey) {\n    return `\n      <div style=\"padding: ${this.options.containerPadding}; font-family: ${this.options.fontFamily};\">\n        <h3 style=\"margin-top: ${this.options.headerMargin};\">ボクセル [${voxelInfo.x}, ${voxelInfo.y}, ${voxelInfo.z}]</h3>\n        <table style=\"width: ${this.options.tableWidth};\">\n          <tr><td><b>エンティティ数:</b></td><td>${voxelInfo.count}</td></tr>\n          <tr><td><b>ID:</b></td><td>${voxelKey}</td></tr>\n        </table>\n      </div>\n    `;\n  }\n\n  /**\n   * 統計情報を含む拡張説明文を生成\n   * \n   * @param {Object} voxelInfo - ボクセル情報\n   * @param {string} voxelKey - ボクセルキー\n   * @param {Object} [statistics] - 統計情報（オプション）\n   * @param {number} [statistics.percentile] - パーセンタイル\n   * @param {number} [statistics.rank] - ランク\n   * @param {number} [statistics.total] - 総数\n   * @returns {string} HTML形式の拡張説明文\n   */\n  createExtendedVoxelDescription(voxelInfo, voxelKey, statistics = null) {\n    let baseDescription = this.createVoxelDescription(voxelInfo, voxelKey);\n    \n    if (statistics) {\n      const statsSection = `\n        <hr style=\"margin: 10px 0;\">\n        <h4 style=\"margin: 5px 0;\">統計情報</h4>\n        <table style=\"width: ${this.options.tableWidth};\">\n          ${statistics.percentile !== undefined ? `<tr><td><b>パーセンタイル:</b></td><td>${statistics.percentile.toFixed(1)}%</td></tr>` : ''}\n          ${statistics.rank !== undefined && statistics.total !== undefined ? `<tr><td><b>ランク:</b></td><td>${statistics.rank}/${statistics.total}</td></tr>` : ''}\n        </table>\n      `;\n      \n      // </div>を取り除いて統計情報を追加し、最後に</div>を付ける\n      baseDescription = baseDescription.replace('</div>', statsSection + '</div>');\n    }\n    \n    return baseDescription;\n  }\n\n  /**\n   * カスタムフィールドを追加できる柔軟な説明文生成\n   * \n   * @param {Object} voxelInfo - ボクセル情報\n   * @param {string} voxelKey - ボクセルキー\n   * @param {Array<Object>} [customFields=[]] - カスタムフィールド配列\n   * @param {string} customFields[].label - フィールドラベル\n   * @param {string|number} customFields[].value - フィールド値\n   * @returns {string} HTML形式のカスタム説明文\n   */\n  createCustomVoxelDescription(voxelInfo, voxelKey, customFields = []) {\n    const customRows = customFields.map(field => \n      `<tr><td><b>${field.label}:</b></td><td>${field.value}</td></tr>`\n    ).join('');\n\n    return `\n      <div style=\"padding: ${this.options.containerPadding}; font-family: ${this.options.fontFamily};\">\n        <h3 style=\"margin-top: ${this.options.headerMargin};\">ボクセル [${voxelInfo.x}, ${voxelInfo.y}, ${voxelInfo.z}]</h3>\n        <table style=\"width: ${this.options.tableWidth};\">\n          <tr><td><b>エンティティ数:</b></td><td>${voxelInfo.count}</td></tr>\n          <tr><td><b>ID:</b></td><td>${voxelKey}</td></tr>\n          ${customRows}\n        </table>\n      </div>\n    `;\n  }\n}\n","/**\n * Voxel geometry calculation utilities.\n * ボクセルの幾何計算ユーティリティ。\n */\nimport * as Cesium from 'cesium';\n\n/**\n * Voxel geometry calculation utility class.\n * ボクセルの幾何計算を担当するユーティリティクラス。\n */\nexport class VoxelGeometry {\n  /**\n   * Calculate voxel center coordinates.\n   * ボクセルの中心座標を計算します。\n   * @param {number} x - X grid index / X軸グリッドインデックス\n   * @param {number} y - Y grid index / Y軸グリッドインデックス  \n   * @param {number} z - Z grid index / Z軸グリッドインデックス\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} grid - Grid info / グリッド情報\n   * @returns {Object} Center coordinates / 中心座標\n   */\n  static calculateVoxelCenter(x, y, z, bounds, grid) {\n    const centerLon = bounds.minLon + (x + 0.5) * (bounds.maxLon - bounds.minLon) / grid.numVoxelsX;\n    const centerLat = bounds.minLat + (y + 0.5) * (bounds.maxLat - bounds.minLat) / grid.numVoxelsY;\n    const centerAlt = bounds.minAlt + (z + 0.5) * (bounds.maxAlt - bounds.minAlt) / grid.numVoxelsZ;\n    \n    return {\n      longitude: centerLon,\n      latitude: centerLat,\n      altitude: centerAlt\n    };\n  }\n\n  /**\n   * Calculate voxel center position as Cartesian3.\n   * ボクセルの中心位置をCartesian3として計算します。\n   * @param {number} x - X grid index / X軸グリッドインデックス\n   * @param {number} y - Y grid index / Y軸グリッドインデックス  \n   * @param {number} z - Z grid index / Z軸グリッドインデックス\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} grid - Grid info / グリッド情報\n   * @returns {Cesium.Cartesian3} Center position / 中心位置\n   */\n  static calculateVoxelPosition(x, y, z, bounds, grid) {\n    const center = VoxelGeometry.calculateVoxelCenter(x, y, z, bounds, grid);\n    return Cesium.Cartesian3.fromDegrees(center.longitude, center.latitude, center.altitude);\n  }\n\n  /**\n   * Calculate voxel cell sizes for each axis.\n   * 各軸のボクセルセルサイズを計算します。\n   * @param {Object} grid - Grid info / グリッド情報\n   * @param {Object} options - Rendering options / 描画オプション\n   * @returns {Object} Cell sizes / セルサイズ\n   */\n  static calculateVoxelSizes(grid, options = {}) {\n    // 各軸のセルサイズ（グリッドが持つ実セルサイズを優先、なければvoxelSizeMetersにフォールバック）\n    let cellSizeX = grid.cellSizeX || (grid.lonRangeMeters ? (grid.lonRangeMeters / grid.numVoxelsX) : grid.voxelSizeMeters);\n    let cellSizeY = grid.cellSizeY || (grid.latRangeMeters ? (grid.latRangeMeters / grid.numVoxelsY) : grid.voxelSizeMeters);\n    let baseCellSizeZ = grid.cellSizeZ || (grid.altRangeMeters ? Math.max(grid.altRangeMeters / Math.max(grid.numVoxelsZ, 1), 1) : Math.max(grid.voxelSizeMeters, 1));\n\n    // v0.1.6.1: ボクセルギャップ適用（従来のメートル単位差分適用に揃える）\n    if (options.voxelGap > 0) {\n      cellSizeX = Math.max(cellSizeX - options.voxelGap, cellSizeX * 0.1);\n      cellSizeY = Math.max(cellSizeY - options.voxelGap, cellSizeY * 0.1);\n      baseCellSizeZ = Math.max(baseCellSizeZ - options.voxelGap, baseCellSizeZ * 0.1);\n    }\n\n    return {\n      sizeX: cellSizeX,\n      sizeY: cellSizeY,\n      sizeZ: baseCellSizeZ\n    };\n  }\n\n  /**\n   * Calculate adjusted voxel height based on density.\n   * 密度に基づいて調整されたボクセル高さを計算します。\n   * @param {number} baseSizeZ - Base Z size / 基本Z軸サイズ\n   * @param {number} normalizedDensity - Normalized density (0-1) / 正規化された密度\n   * @param {boolean} heightBased - Height-based mode / 高さベースモード\n   * @returns {number} Adjusted height / 調整された高さ\n   */\n  static calculateAdjustedHeight(baseSizeZ, normalizedDensity, heightBased = false) {\n    if (!heightBased) {\n      return baseSizeZ;\n    }\n\n    // 最小高さを保証しつつ密度に比例\n    const minHeightRatio = 0.1; // 最小10%の高さは保証\n    return baseSizeZ * (minHeightRatio + (1 - minHeightRatio) * normalizedDensity);\n  }\n\n  /**\n   * Calculate voxel dimensions with all adjustments.\n   * 全ての調整を適用したボクセル寸法を計算します。\n   * @param {Object} grid - Grid info / グリッド情報\n   * @param {number} normalizedDensity - Normalized density (0-1) / 正規化された密度\n   * @param {Object} options - Rendering options / 描画オプション\n   * @returns {Cesium.Cartesian3} Voxel dimensions / ボクセル寸法\n   */\n  static calculateVoxelDimensions(grid, normalizedDensity, options = {}) {\n    const sizes = VoxelGeometry.calculateVoxelSizes(grid, options);\n    const adjustedHeight = VoxelGeometry.calculateAdjustedHeight(\n      sizes.sizeZ, \n      normalizedDensity, \n      options.heightBased\n    );\n\n    return new Cesium.Cartesian3(sizes.sizeX, sizes.sizeY, adjustedHeight);\n  }\n\n  /**\n   * Calculate data bounds center.\n   * データ境界の中心を計算します。\n   * @param {Object} bounds - Data bounds / データ境界\n   * @returns {Object} Center coordinates / 中心座標\n   */\n  static calculateBoundsCenter(bounds) {\n    return {\n      longitude: (bounds.minLon + bounds.maxLon) / 2,\n      latitude: (bounds.minLat + bounds.maxLat) / 2,\n      altitude: (bounds.minAlt + bounds.maxAlt) / 2\n    };\n  }\n\n  /**\n   * Calculate data bounds center as Cartesian3.\n   * データ境界の中心をCartesian3として計算します。\n   * @param {Object} bounds - Data bounds / データ境界\n   * @returns {Cesium.Cartesian3} Center position / 中心位置\n   */\n  static calculateBoundsCenterPosition(bounds) {\n    const center = VoxelGeometry.calculateBoundsCenter(bounds);\n    return Cesium.Cartesian3.fromDegrees(center.longitude, center.latitude, center.altitude);\n  }\n}\n","/**\n * ADR-0008 Phase 3: VoxelRenderer からレンダリングエンジンを分離\n * Main rendering engine for 3D voxels.\n * 3Dボクセル用メインレンダリングエンジン\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\nimport { ColorMap } from '../color/ColorMap.js';\nimport { VoxelGeometry } from './VoxelGeometry.js';\nimport { VoxelEntityFactory } from './VoxelEntityFactory.js';\n\n/**\n * VoxelRenderingEngine handles the main rendering loop and voxel creation.\n * VoxelRenderingEngineはメインの描画ループとボクセル作成を処理します。\n */\n/**\n * Advanced 3D voxel rendering engine with comprehensive visualization features.\n * 包括的な可視化機能を備えた高度な3Dボクセルレンダリングエンジン。\n * \n * This specialized rendering engine handles the core voxel rendering pipeline,\n * including density calculations, color mapping, adaptive outline control,\n * TopN highlighting, and advanced rendering modes. Separated from VoxelRenderer\n * as part of ADR-0008 modular architecture for better maintainability.\n * \n * この専門レンダリングエンジンは、密度計算、カラーマッピング、適応的アウトライン制御、\n * TopN強調、高度なレンダリングモードを含むコアボクセルレンダリングパイプラインを処理します。\n * 保守性向上のためADR-0008モジュラーアーキテクチャの一部としてVoxelRendererから分離されました。\n * \n * @since v0.1.10\n * @version 1.0.0 - Initial modular implementation\n */\nexport class VoxelRenderingEngine {\n  /**\n   * Initialize rendering engine with comprehensive component integration.\n   * 包括的なコンポーネント統合でレンダリングエンジンを初期化します。\n   * \n   * Creates the core rendering engine that orchestrates voxel visualization\n   * by coordinating entity management, debug rendering, outline control,\n   * and description building components.\n   * \n   * エンティティ管理、デバッグレンダリング、アウトライン制御、\n   * 説明文構築コンポーネントを調整してボクセル可視化を統括する\n   * コアレンダリングエンジンを作成します。\n   * \n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer instance / CesiumJSビューアーインスタンス\n   * @param {VoxelEntityManager} entityManager - Entity lifecycle manager / エンティティライフサイクル管理\n   * @param {DebugRenderer} debugRenderer - Debug visualization component / デバッグ可視化コンポーネント\n   * @param {AdaptiveOutlineController} adaptiveOutlineController - Adaptive outline control / 適応的アウトライン制御\n   * @param {OutlineRenderer} outlineRenderer - Specialized outline rendering / 専門アウトラインレンダリング\n   * @param {DescriptionBuilder} descriptionBuilder - InfoBox description generator / InfoBox説明文ジェネレーター\n   * \n   * @since v0.1.10\n   */\n  constructor(viewer) {\n    this.viewer = viewer;\n    this.entityFactory = new VoxelEntityFactory();\n    this.colorMap = new ColorMap();\n  }\n\n  /**\n   * Render voxel data (main rendering loop).\n   * ボクセルデータを描画（メイン描画ループ）\n   * @param {Array} displayVoxels - Voxels to display / 表示するボクセル\n   * @param {Set} topNVoxels - TopN highlighted voxels / TopN強調表示ボクセル\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @param {Object} grid - Grid info / グリッド情報  \n   * @param {Object} statistics - Statistics / 統計情報\n   * @param {Object} options - Rendering options / 描画オプション\n   * @param {Function} calculateAdaptiveParams - Adaptive parameter calculation / 適応パラメータ計算\n   * @param {Object} outlineRenderer - Outline renderer / 枠線レンダラー\n   * @param {Object} adaptiveOutlineController - Adaptive outline controller / 適応枠線コントローラー\n   * @returns {Array} Created entities / 作成されたエンティティ\n   */\n  renderVoxels(displayVoxels, topNVoxels, bounds, grid, statistics, options, calculateAdaptiveParams, outlineRenderer, _adaptiveOutlineController) {\n    const entities = [];\n    \n    Logger.debug(`Rendering ${displayVoxels.length} voxels`);\n    \n    // 実際にボクセルを描画\n    displayVoxels.forEach(({ key, info }) => {\n      try {\n        const { x, y, z } = info;\n        \n        // ADR-0008 Phase 1: ボクセル中心座標をVoxelGeometryで計算\n        const center = VoxelGeometry.calculateVoxelCenter(x, y, z, bounds, grid);\n        const centerLon = center.longitude;\n        const centerLat = center.latitude;\n        const centerAlt = center.altitude;\n        \n        const isTopN = topNVoxels.has(key); // v0.1.5: TopNハイライト判定\n        \n        // 位置を先に計算して適応パラメータに渡す\n        const position = Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt);\n        // v0.1.7: 適応的パラメータの計算（位置情報を含めて渡す）\n        const adaptiveParams = calculateAdaptiveParams({ ...info, position }, isTopN, null, statistics);\n        \n        // 密度に応じた色を計算\n        let color, opacity;\n        \n        // 正規化密度を計算\n        const normalizedDensity = statistics.maxCount > statistics.minCount ? \n          (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;\n        \n        if (info.count === 0) {\n          // 空ボクセルの場合\n          color = Cesium.Color.LIGHTGRAY;\n          opacity = options.emptyOpacity;\n        } else {\n          // データありボクセルの場合\n          color = ColorMap.interpolateColor(normalizedDensity, info.count, options);\n          \n          // v0.1.7: 透明度resolverの適用（優先順位：resolver > 適応的 > 固定値）\n          if (options.boxOpacityResolver && typeof options.boxOpacityResolver === 'function') {\n            const resolverCtx = {\n              voxel: { x, y, z, count: info.count },\n              isTopN,\n              normalizedDensity,\n              statistics,\n              adaptiveParams\n            };\n            try {\n              const resolverOpacity = options.boxOpacityResolver(resolverCtx);\n              opacity = isNaN(resolverOpacity) ? options.opacity : Math.max(0, Math.min(1, resolverOpacity));\n            } catch (e) {\n              Logger.warn('boxOpacityResolver error, using fallback:', e);\n              opacity = adaptiveParams.boxOpacity || options.opacity;\n            }\n          } else {\n            opacity = adaptiveParams.boxOpacity || options.opacity;\n          }\n          \n          // v0.1.5: TopN強調表示での淡色化処理\n          if (options.highlightTopN && !isTopN && !options.boxOpacityResolver) {\n            opacity *= 0.3; // TopN以外を薄くする\n          }\n        }\n\n        // ADR-0008 Phase 1: ボクセル寸法計算をVoxelGeometryで実行（voxelGap/heightBased対応）\n        const dims = VoxelGeometry.calculateVoxelDimensions(grid, normalizedDensity, options);\n        const sizeX = dims.x;\n        const sizeY = dims.y;\n        const sizeZ = dims.z;\n        let adjustedAlt = centerAlt;\n\n        // 枠線の設定\n        let outlineWidth = options.outlineWidth;\n        let outlineColor = options.showOutline ? Cesium.Color.fromBytes(255, 255, 255, 255) : undefined;\n        \n        // v0.1.6: 動的枠線制御の適用（優先順位：resolver > 適応的 > 固定値）\n        if (options.outlineWidthResolver && typeof options.outlineWidthResolver === 'function') {\n          const resolverCtx = {\n            voxel: { x, y, z, count: info.count },\n            isTopN,\n            density: info.count,\n            normalizedDensity: statistics.maxCount > statistics.minCount ? \n              (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0,\n            statistics,\n            adaptiveParams\n          };\n          try {\n            const resolverWidth = options.outlineWidthResolver(resolverCtx);\n            outlineWidth = isNaN(resolverWidth) ? options.outlineWidth : Math.max(0, resolverWidth);\n          } catch (e) {\n            Logger.warn('outlineWidthResolver error, using fallback:', e);\n            outlineWidth = adaptiveParams.outlineWidth || options.outlineWidth;\n          }\n        } else {\n          // v0.1.7: 適応的枠線制御のサポート\n          if (options.adaptiveOutlines && adaptiveParams.outlineWidth !== null) {\n            outlineWidth = adaptiveParams.outlineWidth;\n          }\n        }\n        // v0.1.5: TopN強調時の枠線幅上書き（resolver適用後）\n        if (isTopN && options.highlightTopN) {\n          outlineWidth = (options.highlightStyle && options.highlightStyle.outlineWidth) || outlineWidth;\n        }\n        \n        // ADR-0008 Phase 4: 適応的制御による枠線不透明度の処理\n        const outlineOpacity = (adaptiveParams.outlineOpacity != null)\n          ? adaptiveParams.outlineOpacity\n          : (options.outlineOpacity != null ? options.outlineOpacity : 1.0);\n        // 枠線の色に透明度を適用（デフォルト白）\n        if (options.showOutline) {\n          outlineColor = Cesium.Color.fromBytes(255, 255, 255, 255).withAlpha(outlineOpacity);\n        }\n\n        // ADR-0008 Phase 1: VoxelEntityFactoryでエンティティ作成\n        const entityConfig = VoxelEntityFactory.createBoxEntity({\n          position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, adjustedAlt),\n          dimensions: new Cesium.Cartesian3(sizeX, sizeY, sizeZ),\n          color: color,\n          opacity: opacity,\n          wireframe: options.wireframeOnly,\n          outline: {\n            show: options.showOutline === true,\n            color: outlineColor,\n            width: outlineWidth || 1\n          },\n          properties: {\n            key: key,\n            count: info.count,\n            x: info.x,\n            y: info.y,\n            z: info.z,\n            isTopN: isTopN,\n            normalizedDensity: normalizedDensity\n          }\n        });\n\n        // Cesiumエンティティを直接作成\n        const boxEntity = new Cesium.Entity({\n          id: `voxel-${key}`,\n          ...entityConfig\n        });\n        \n        // 拡張情報を設定\n        boxEntity.description = options.createVoxelDescription ? \n          options.createVoxelDescription(info, normalizedDensity, statistics) : `Count: ${info.count}`;\n        \n        this.viewer.entities.add(boxEntity);\n        entities.push(boxEntity);\n\n        // ADR-0008 Phase 2: Render outline using OutlineRenderer (after box added)\n        const outlineOptions = {\n          outlineRenderMode: options.outlineRenderMode,\n          outlineInset: options.outlineInset,\n          outlineInsetMode: options.outlineInsetMode,\n          showOutline: options.showOutline,\n          outlineColor: outlineColor,\n          outlineWidth: outlineWidth,\n          enableThickFrames: options.enableThickFrames\n        };\n        \n        const voxelInfoWithPosition = {\n          ...info,\n          key: key,\n          position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, adjustedAlt),\n          width: sizeX,\n          height: sizeZ,\n          depth: sizeY,\n          isTopN: isTopN\n        };\n\n        const outlineEntities = outlineRenderer.renderOutline(voxelInfoWithPosition, outlineOptions, adaptiveParams);\n        outlineEntities.forEach(entity => {\n          this.viewer.entities.add(entity);\n          entities.push(entity);\n        });\n\n      } catch (error) {\n        Logger.error('Error rendering voxel:', error, { key, info });\n      }\n    });\n\n    Logger.info(`Successfully rendered ${entities.length} voxels`);\n    return entities;\n  }\n\n  /**\n   * Process display voxels from voxel data.\n   * ボクセルデータから表示用ボクセルを処理\n   * @param {Map} voxelData - Raw voxel data / 生ボクセルデータ\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @param {Object} grid - Grid info / グリッド情報\n   * @param {Object} options - Options / オプション\n   * @param {Function} selectVoxelsForRendering - Voxel selection function / ボクセル選択関数\n   * @returns {Object} Processing result / 処理結果\n   */\n  processDisplayVoxels(voxelData, bounds, grid, options, selectVoxelsForRendering) {\n    let displayVoxels = [];\n    const topNVoxels = new Set();\n    const maxVoxels = 1000000;\n\n    // 空ボクセルのフィルタリング\n    if (options.showEmptyVoxels) {\n      // すべてのボクセルを表示\n      for (let x = 0; x < grid.numVoxelsX; x++) {\n        for (let y = 0; y < grid.numVoxelsY; y++) {\n          for (let z = 0; z < grid.numVoxelsZ; z++) {\n            const voxelKey = `${x},${y},${z}`;\n            const voxelInfo = voxelData.get(voxelKey) || { x, y, z, count: 0, entities: [] };\n            \n            displayVoxels.push({\n              key: voxelKey,\n              info: voxelInfo\n            });\n            \n            if (displayVoxels.length >= maxVoxels) {\n              Logger.debug(`Reached maximum voxel limit of ${maxVoxels}`);\n              break;\n            }\n          }\n          if (displayVoxels.length >= maxVoxels) break;\n        }\n        if (displayVoxels.length >= maxVoxels) break;\n      }\n    } else {\n      // データがあるボクセルのみ表示\n      displayVoxels = Array.from(voxelData.entries()).map(([key, info]) => {\n        return { key, info };\n      });\n      \n      // v0.1.9: 適応的レンダリング制限の適用\n      if (options.maxRenderVoxels && displayVoxels.length > options.maxRenderVoxels) {\n        const selectionResult = selectVoxelsForRendering(displayVoxels, options.maxRenderVoxels, bounds, grid);\n        displayVoxels = selectionResult.selectedVoxels;\n        \n        Logger.debug(`Applied ${selectionResult.strategy} strategy: ${displayVoxels.length} voxels selected, ${selectionResult.clippedNonEmpty} clipped`);\n      }\n    }\n\n    // v0.1.5: TopN強調表示の前処理\n    if (options.highlightTopN && options.highlightTopN > 0) {\n      const sortedForTopN = [...displayVoxels].sort((a, b) => b.info.count - a.info.count);\n      const topN = sortedForTopN.slice(0, options.highlightTopN);\n      topN.forEach(voxel => topNVoxels.add(voxel.key));\n      Logger.debug(`TopN highlight enabled: ${topNVoxels.size} voxels will be highlighted`);\n    }\n\n    return { displayVoxels, topNVoxels };\n  }\n}\n","/**\n * ADR-0008 Phase 3: VoxelRenderer からエンティティ管理機能を分離\n * Entity management for 3D voxels.\n * 3Dボクセル用エンティティ管理\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\nimport { VoxelEntityFactory } from './VoxelEntityFactory.js';\n\n/**\n * VoxelEntityManager handles entity creation, management, and cleanup.\n * VoxelEntityManagerはエンティティの作成、管理、クリーンアップを処理します。\n */\n/**\n * Specialized manager for Cesium entity lifecycle in voxel rendering.\n * ボクセルレンダリングにおけるCesiumエンティティライフサイクルの専門マネージャー。\n * \n * This class handles all aspects of voxel entity management including creation,\n * addition to scene, visibility control, and cleanup. Extracted from VoxelRenderer\n * as part of ADR-0008 modular refactoring to improve separation of concerns\n * and maintainability.\n * \n * このクラスは、作成、シーンへの追加、表示制御、クリーンアップを含む\n * ボクセルエンティティ管理のすべての側面を処理します。懸念の分離と\n * 保守性向上のためADR-0008モジュラーリファクタリングの一部として\n * VoxelRendererから抽出されました。\n * \n * @since v0.1.10\n * @version 1.0.0 - Initial modular implementation (ADR-0008 Phase 3)\n */\nexport class VoxelEntityManager {\n  /**\n   * Constructor\n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer / CesiumJS Viewer\n   */\n  constructor(viewer) {\n    this.viewer = viewer;\n    this.entityFactory = new VoxelEntityFactory();\n    this.voxelEntities = [];\n  }\n\n  /**\n   * Add entity to managed entities list.\n   * エンティティを管理対象リストに追加\n   * @param {Cesium.Entity} entity - Entity to add / 追加するエンティティ\n   */\n  addEntity(entity) {\n    this.voxelEntities.push(entity);\n    return entity;\n  }\n\n  /**\n   * Clear all managed entities.\n   * すべての管理対象エンティティをクリア\n   */\n  clear() {\n    Logger.debug('VoxelEntityManager.clear - Removing', this.voxelEntities.length, 'entities');\n    \n    this.voxelEntities.forEach(entity => {\n      try {\n        // isDestroyedのチェックを安全に行う\n        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n        \n        if (entity && !isDestroyed) {\n          this.viewer.entities.remove(entity);\n        }\n      } catch (error) {\n        Logger.warn('Entity removal error:', error);\n      }\n    });\n    \n    this.voxelEntities = [];\n  }\n\n  /**\n   * Set visibility of all managed entities.\n   * 管理対象エンティティの表示/非表示を設定\n   * @param {boolean} show - Visibility state / 表示状態\n   */\n  setVisible(show) {\n    Logger.debug('VoxelEntityManager.setVisible:', show, 'for', this.voxelEntities.length, 'entities');\n    \n    this.voxelEntities.forEach(entity => {\n      try {\n        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n        \n        if (entity && !isDestroyed) {\n          entity.show = show;\n        }\n      } catch (error) {\n        Logger.warn('Entity visibility error:', error);\n      }\n    });\n  }\n\n  /**\n   * Create and add an inset outline entity.\n   * インセット枠線エンティティを作成・追加\n   * @param {number} centerLon - Center longitude / 中心経度\n   * @param {number} centerLat - Center latitude / 中心緯度\n   * @param {number} centerAlt - Center altitude / 中心高度\n   * @param {number} baseSizeX - Base X size / ベースXサイズ\n   * @param {number} baseSizeY - Base Y size / ベースYサイズ  \n   * @param {number} baseSizeZ - Base Z size / ベースZサイズ\n   * @param {Cesium.Color} outlineColor - Outline color / 枠線色\n   * @param {number} outlineWidth - Outline width / 枠線幅\n   * @param {string} voxelKey - Voxel key / ボクセルキー\n   * @param {number} insetAmount - Inset amount / インセット量\n   * @returns {Cesium.Entity} Created entity / 作成されたエンティティ\n   */\n  createInsetOutline(centerLon, centerLat, centerAlt, baseSizeX, baseSizeY, baseSizeZ, outlineColor, outlineWidth, voxelKey, insetAmount = null) {\n    // ADR-0004のインセット枠線実装\n    const actualInset = insetAmount || 1.0; // デフォルト1m\n    \n    // インセット寸法の計算\n    const insetX = Math.max(baseSizeX * 0.1, baseSizeX - 2 * actualInset);\n    const insetY = Math.max(baseSizeY * 0.1, baseSizeY - 2 * actualInset);\n    const insetZ = Math.max(baseSizeZ * 0.1, baseSizeZ - 2 * actualInset);\n\n    // Enforce 20% max inset per axis (ADR-0004)\n    const maxInsetX = baseSizeX * 0.4; // 両側で最大40%\n    const maxInsetY = baseSizeY * 0.4;\n    const maxInsetZ = baseSizeZ * 0.4;\n    \n    const finalInsetX = Math.max(insetX, baseSizeX - maxInsetX);\n    const finalInsetY = Math.max(insetY, baseSizeY - maxInsetY);  \n    const finalInsetZ = Math.max(insetZ, baseSizeZ - maxInsetZ);\n\n    const insetDimensions = new Cesium.Cartesian3(finalInsetX, finalInsetY, finalInsetZ);\n    \n    const insetEntity = this.entityFactory.createBoxEntity({\n      id: `voxel-inset-${voxelKey}`,\n      position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt),\n      dimensions: insetDimensions,\n      color: Cesium.Color.TRANSPARENT, // 透明ボックス\n      opacity: 0.0,\n      outlineColor: outlineColor,\n      outlineWidth: outlineWidth,\n      wireframeOnly: true,\n      key: `inset-${voxelKey}`\n    });\n\n    this.viewer.entities.add(insetEntity);\n    this.addEntity(insetEntity);\n    \n    return insetEntity;\n  }\n\n  /**\n   * Create thick outline frames using multiple frame boxes.\n   * 複数のフレームボックスを使用して厚い枠線を作成\n   * @param {number} centerLon - Center longitude / 中心経度\n   * @param {number} centerLat - Center latitude / 中心緯度  \n   * @param {number} centerAlt - Center altitude / 中心高度\n   * @param {number} outerX - Outer X size / 外側Xサイズ\n   * @param {number} outerY - Outer Y size / 外側Yサイズ\n   * @param {number} outerZ - Outer Z size / 外側Zサイズ\n   * @param {number} innerX - Inner X size / 内側Xサイズ\n   * @param {number} innerY - Inner Y size / 内側Yサイズ\n   * @param {number} innerZ - Inner Z size / 内側Zサイズ\n   * @param {Cesium.Color} frameColor - Frame color / フレーム色\n   * @param {string} voxelKey - Voxel key / ボクセルキー\n   * @returns {Array} Created frame entities / 作成されたフレームエンティティ\n   */\n  createThickOutlineFrames(centerLon, centerLat, centerAlt, outerX, outerY, outerZ, innerX, innerY, innerZ, frameColor, voxelKey) {\n    const frameEntities = [];\n    const frameThickness = Math.max((outerX - innerX) / 2, 0.5); // minimum 0.5m thickness\n    \n    const frames = [\n      // 6 faces: top/bottom, front/back, left/right\n      \n      // Top frame\n      {\n        position: [centerLon, centerLat, centerAlt + (outerZ - frameThickness) / 2],\n        size: [outerX, outerY, frameThickness]\n      },\n      // Bottom frame  \n      {\n        position: [centerLon, centerLat, centerAlt - (outerZ - frameThickness) / 2],\n        size: [outerX, outerY, frameThickness]\n      },\n      \n      // Front frame (Y+)\n      {\n        position: [centerLon, centerLat + (outerY - frameThickness) / 2, centerAlt],\n        size: [outerX, frameThickness, innerZ]\n      },\n      // Back frame (Y-)\n      {\n        position: [centerLon, centerLat - (outerY - frameThickness) / 2, centerAlt], \n        size: [outerX, frameThickness, innerZ]\n      },\n      \n      // Right frame (X+)\n      {\n        position: [centerLon + (outerX - frameThickness) / 2, centerLat, centerAlt],\n        size: [frameThickness, innerY, innerZ]\n      },\n      // Left frame (X-)\n      {\n        position: [centerLon - (outerX - frameThickness) / 2, centerLat, centerAlt],\n        size: [frameThickness, innerY, innerZ]\n      },\n      \n      // Edge frames (12 edges)\n      // 4 vertical edges\n      {\n        position: [centerLon + (innerX) / 2, centerLat + (innerY) / 2, centerAlt],\n        size: [frameThickness, frameThickness, outerZ]\n      },\n      {\n        position: [centerLon - (innerX) / 2, centerLat + (innerY) / 2, centerAlt],\n        size: [frameThickness, frameThickness, outerZ]\n      },\n      {\n        position: [centerLon + (innerX) / 2, centerLat - (innerY) / 2, centerAlt],\n        size: [frameThickness, frameThickness, outerZ] \n      },\n      {\n        position: [centerLon - (innerX) / 2, centerLat - (innerY) / 2, centerAlt],\n        size: [frameThickness, frameThickness, outerZ]\n      },\n      \n      // 4 horizontal edges (top)\n      {\n        position: [centerLon, centerLat + (innerY) / 2, centerAlt + (innerZ) / 2],\n        size: [innerX, frameThickness, frameThickness]\n      },\n      {\n        position: [centerLon, centerLat - (innerY) / 2, centerAlt + (innerZ) / 2],\n        size: [innerX, frameThickness, frameThickness]\n      }\n    ];\n\n    frames.forEach((frame, index) => {\n      // Skip frames that are too small\n      if (frame.size[0] > 0.1 && frame.size[1] > 0.1 && frame.size[2] > 0.1) {\n        const frameEntity = this.entityFactory.createBoxEntity({\n          id: `thick-frame-${voxelKey}-${index}`,\n          position: Cesium.Cartesian3.fromDegrees(frame.position[0], frame.position[1], frame.position[2]),\n          dimensions: {\n            width: frame.size[0],\n            height: frame.size[1], \n            depth: frame.size[2]\n          },\n          color: frameColor,\n          opacity: 1.0,\n          outlineColor: undefined,\n          outlineWidth: 0,\n          wireframeOnly: false,\n          key: `thick-frame-${voxelKey}-${index}`\n        });\n\n        this.viewer.entities.add(frameEntity);\n        this.addEntity(frameEntity);\n        frameEntities.push(frameEntity);\n      }\n    });\n\n    return frameEntities;\n  }\n\n  /**\n   * Check if inset outline should be applied.\n   * インセット枠線を適用すべきかどうかを判定\n   * @param {boolean} isTopN - Is TopN voxel / TopNボクセルか\n   * @param {Object} options - Options / オプション\n   * @returns {boolean} Whether to apply inset outline / インセット枠線を適用するかどうか\n   */\n  shouldApplyInsetOutline(isTopN, options) {\n    const mode = options.outlineInsetMode || 'all';\n    \n    switch (mode) {\n      case 'all':\n        return true;\n      case 'topn-only':\n        return isTopN;\n      case 'non-topn':\n        return !isTopN;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Get statistics about managed entities.\n   * 管理対象エンティティの統計を取得\n   * @returns {Object} Entity statistics / エンティティ統計\n   */\n  getEntityStats() {\n    return {\n      totalEntities: this.voxelEntities.length,\n      activeEntities: this.voxelEntities.filter(entity => {\n        try {\n          const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n          return !isDestroyed;\n        } catch {\n          return false;\n        }\n      }).length\n    };\n  }\n}\n","/**\n * Class responsible for rendering 3D voxels.\n * 3Dボクセルの描画を担当するクラス。\n * ADR-0008 Phase 3: Refactored with modular architecture\n */\nimport { Logger } from '../utils/logger.js';\nimport { DensitySelectionStrategy } from './selection/DensitySelectionStrategy.js';\nimport { CoverageSelectionStrategy } from './selection/CoverageSelectionStrategy.js';\nimport { HybridSelectionStrategy } from './selection/HybridSelectionStrategy.js';\nimport { ColorMap } from './color/ColorMap.js';\nimport { DebugRenderer } from './voxel/DebugRenderer.js';\nimport { AdaptiveOutlineController } from './outline/AdaptiveOutlineController.js';\nimport { OutlineRenderer } from './outline/OutlineRenderer.js';\nimport { DescriptionBuilder } from './voxel/DescriptionBuilder.js';\nimport { VoxelRenderingEngine } from './voxel/VoxelRenderingEngine.js';\nimport { VoxelEntityManager } from './voxel/VoxelEntityManager.js';\n\n/**\n * Core class responsible for 3D voxel rendering and visualization management.\n * 3Dボクセルのレンダリングと可視化管理を担当するコアクラス。\n * \n * This class orchestrates the rendering of 3D voxel-based heatmaps by coordinating\n * multiple specialized components: rendering engine, entity manager, outline controllers,\n * and description builders. It provides the main interface for voxel visualization\n * with support for advanced features like adaptive outlines, TopN highlighting,\n * and customizable rendering modes.\n * \n * このクラスは、レンダリングエンジン、エンティティマネージャー、アウトラインコントローラー、\n * および説明文ビルダーなどの複数の専門コンポーネントを調整して、3Dボクセルベースの\n * ヒートマップのレンダリングを統括します。適応的アウトライン、TopN強調、\n * カスタマイズ可能なレンダリングモードなどの高度な機能をサポートする、\n * ボクセル可視化のメインインターフェースを提供します。\n * \n * @since v0.1.0\n * @version v0.1.10 - Refactored with modular architecture (ADR-0008)\n */\nexport class VoxelRenderer {\n  /**\n   * Initialize VoxelRenderer with comprehensive rendering capabilities.\n   * 包括的なレンダリング機能を持つVoxelRendererを初期化します。\n   * \n   * Creates a fully-featured voxel renderer with modular architecture including\n   * dedicated components for entity management, outline rendering, adaptive\n   * control systems, and description generation. Supports extensive customization\n   * through the options parameter.\n   * \n   * エンティティ管理、アウトラインレンダリング、適応制御システム、\n   * 説明文生成の専用コンポーネントを含むモジュラーアーキテクチャを持つ、\n   * フル機能のボクセルレンダラーを作成します。optionsパラメーターを通じて\n   * 広範囲なカスタマイズをサポートします。\n   * \n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer instance for rendering / レンダリング用CesiumJSビューアーインスタンス\n   * @param {Object} [options={}] - Comprehensive rendering configuration / 包括的なレンダリング設定\n   * @param {number[]} [options.minColor=[0,0,255]] - RGB color for minimum density / 最小密度のRGB色\n   * @default [0, 0, 255]\n   * @param {number[]} [options.maxColor=[255,0,0]] - RGB color for maximum density / 最大密度のRGB色  \n   * @default [255, 0, 0]\n   * @param {number} [options.opacity=0.8] - Base opacity for voxels (0-1) / ボクセルの基本不透明度（0-1）\n   * @default 0.8\n   * @param {boolean} [options.showOutline=true] - Whether to show voxel outlines / ボクセルアウトラインの表示\n   * @default true\n   * @param {boolean} [options.adaptiveOutlines=false] - Enable adaptive outline control / 適応的アウトライン制御を有効化\n   * @default false\n   * @param {string} [options.outlineWidthPreset='uniform'] - Outline width preset ('uniform', 'adaptive-density', 'topn-focus') / アウトライン幅プリセット\n   * @default 'uniform'\n   * @param {string} [options.outlineRenderMode='standard'] - Rendering mode ('standard', 'inset', 'emulation-only') / レンダリングモード\n   * @default 'standard'\n   * @param {Object} [options.adaptiveParams] - Parameters for adaptive algorithms / 適応アルゴリズム用パラメーター\n   * \n   * @throws {Error} Throws if viewer is invalid or required dependencies fail to initialize / ビューアーが無効または必要な依存関係の初期化に失敗した場合はエラーを投げます\n   * \n   * @example\n   * // Basic renderer setup / 基本レンダラーセットアップ\n   * const renderer = new VoxelRenderer(viewer, {\n   *   opacity: 0.9,\n   *   showOutline: true,\n   *   minColor: [0, 0, 255],\n   *   maxColor: [255, 0, 0]\n   * });\n   * \n   * @example\n   * // Advanced setup with adaptive features / 適応機能付き高度セットアップ\n   * const renderer = new VoxelRenderer(viewer, {\n   *   adaptiveOutlines: true,\n   *   outlineWidthPreset: 'adaptive-density',\n   *   outlineRenderMode: 'inset',\n   *   adaptiveParams: {\n   *     neighborhoodRadius: 75,\n   *     densityThreshold: 10\n   *   }\n   * });\n   * \n   * @example\n   * // OutlineRenderMode patterns / アウトラインレンダリングモードパターン\n   * \n   * // Pattern 1: Standard mode (default) / 標準モード（デフォルト）\n   * const standardRenderer = new VoxelRenderer(viewer, {\n   *   outlineRenderMode: 'standard',\n   *   showOutline: true,\n   *   outlineWidth: 2\n   * });\n   * \n   * // Pattern 2: Inset mode (cleaner overlaps) / インセットモード（重なり軽減）\n   * const insetRenderer = new VoxelRenderer(viewer, {\n   *   outlineRenderMode: 'inset',\n   *   outlineInset: 0.1,          // 10% inset\n   *   outlineInsetMode: 'adaptive' // または 'all'\n   * });\n   * \n   * // Pattern 3: Emulation-only mode / エミュレーション専用モード\n   * const emulationRenderer = new VoxelRenderer(viewer, {\n   *   outlineRenderMode: 'emulation-only',\n   *   adaptiveOutlines: true\n   * });\n   * \n   * @example \n   * // AdaptiveOutlines + OutlineWidthPreset patterns / 適応的アウトライン + 幅プリセットパターン\n   * \n   * // Pattern 1: Uniform width (default) / 均一幅（デフォルト）\n   * const uniformRenderer = new VoxelRenderer(viewer, {\n   *   adaptiveOutlines: false,\n   *   outlineWidthPreset: 'uniform'\n   * });\n   * \n   * // Pattern 2: Density-adaptive width / 密度適応幅\n   * const densityRenderer = new VoxelRenderer(viewer, {\n   *   adaptiveOutlines: true,\n   *   outlineWidthPreset: 'adaptive-density',\n   *   adaptiveParams: {\n   *     minOutlineWidth: 1,\n   *     maxOutlineWidth: 4\n   *   }\n   * });\n   * \n   * // Pattern 3: TopN focused width / TopN集中幅\n   * const topnRenderer = new VoxelRenderer(viewer, {\n   *   adaptiveOutlines: true,\n   *   outlineWidthPreset: 'topn-focus',\n   *   highlightTopN: 20,\n   *   highlightStyle: {\n   *     outlineWidth: 5,\n   *     outlineOpacity: 1.0\n   *   }\n   * });\n   * \n   * @since v0.1.0\n   */\n  constructor(viewer, options = {}) {\n    this.viewer = viewer;\n    this.options = {\n      minColor: [0, 0, 255],\n      maxColor: [255, 0, 0],\n      opacity: 0.8,\n      emptyOpacity: 0.03,\n      showOutline: true,\n      showEmptyVoxels: false,\n      wireframeOnly: false,    // 枠線のみ表示\n      heightBased: false,      // 高さベース表現\n      outlineWidth: 2,         // 枠線の太さ\n      // v0.1.6.1: インセット枠線のデフォルト値\n      outlineInset: 0,         // インセット枠線オフセット（メートル）\n      outlineInsetMode: 'all', // インセット枠線適用範囲\n      // v0.1.7: 新オプション\n      outlineRenderMode: 'standard',\n      adaptiveOutlines: false,\n      outlineWidthPreset: 'uniform',\n      boxOpacityResolver: null,\n      outlineOpacityResolver: null,\n      adaptiveParams: {\n        neighborhoodRadius: 50,\n        densityThreshold: 5,\n        cameraDistanceFactor: 1.0,\n        overlapRiskFactor: 0.3\n      },\n      ...options\n    };\n    \n    // v0.1.10: Initialize selection strategies / 選択戦略を初期化\n    this._initializeSelectionStrategies();\n    \n    // ADR-0008 Phase 1: Initialize debug renderer / デバッグレンダラーを初期化\n    this.debugRenderer = new DebugRenderer(viewer);\n    \n    // ADR-0008 Phase 2: Initialize outline components / 枠線コンポーネントを初期化\n    this.adaptiveOutlineController = new AdaptiveOutlineController(this.options.adaptiveParams);\n    this.outlineRenderer = new OutlineRenderer(viewer);\n    \n    // ADR-0008 Phase 3: Initialize description builder / 説明文ビルダーを初期化\n    this.descriptionBuilder = new DescriptionBuilder();\n    \n    // ADR-0008 Phase 3: Initialize rendering engine and entity manager / レンダリングエンジンとエンティティマネージャーを初期化\n    this.renderingEngine = new VoxelRenderingEngine(viewer);\n    this.entityManager = new VoxelEntityManager(viewer);\n    \n    Logger.debug('VoxelRenderer initialized with options:', this.options);\n  }\n\n  /**\n   * Initialize selection strategies (v0.1.10).\n   * 選択戦略を初期化します (v0.1.10)。\n   * @private\n   */\n  _initializeSelectionStrategies() {\n    this._selectionStrategies = {\n      density: new DensitySelectionStrategy(),\n      coverage: new CoverageSelectionStrategy(),\n      hybrid: new HybridSelectionStrategy()\n    };\n  }\n\n  /**\n   * Compute adaptive outline parameters (v0.1.7).\n   * 適応的枠線パラメータを計算します (v0.1.7)。\n   * @param {Object} voxelInfo - Voxel information / ボクセル情報\n   * @param {boolean} isTopN - Is TopN voxel / TopNボクセルか\n   * @param {Map} voxelData - Voxel data / ボクセルデータ\n   * @param {Object} statistics - Statistics / 統計情報\n   * @returns {Object} Adaptive parameters / 適応的パラメータ\n   * @private\n   */\n  _calculateAdaptiveParams(voxelInfo, isTopN, voxelData, statistics) {\n    return this.adaptiveOutlineController.calculateAdaptiveParams(\n      voxelInfo, \n      isTopN, \n      voxelData, \n      statistics, \n      this.viewer, \n      this.options\n    );\n  }\n\n  /**\n   * Render voxel data (simplified implementation using rendering engine).\n   * ボクセルデータを描画（レンダリングエンジンを使用したシンプル実装）。\n   * @param {Map} voxelData - Voxel data / ボクセルデータ\n   * @param {Object} bounds - Bounds info / 境界情報\n   * @param {Object} grid - Grid info / グリッド情報\n   * @param {Object} statistics - Statistics / 統計情報\n   * @returns {number} Number of rendered voxels / 実際に描画されたボクセル数\n   */\n  render(voxelData, bounds, grid, statistics) {\n    this.clear();\n    Logger.debug('VoxelRenderer.render - Starting render with rendering engine', {\n      voxelDataSize: voxelData.size,\n      bounds,\n      grid,\n      statistics\n    });\n\n    // ADR-0008 Phase 1: DebugRendererでバウンディングボックス表示制御\n    this.debugRenderer.renderBoundingBox(bounds, this.options.debug);\n\n    // ADR-0008 Phase 3: Use rendering engine to process display voxels\n    const { displayVoxels, topNVoxels } = this.renderingEngine.processDisplayVoxels(\n      voxelData, bounds, grid, this.options, \n      this._selectVoxelsForRendering.bind(this)\n    );\n\n    // Update selection stats if applicable\n    if (this.options.maxRenderVoxels && voxelData.size > this.options.maxRenderVoxels) {\n      /**\n       * Internal selection statistics for debugging and performance monitoring.\n       * デバッグとパフォーマンス監視用の内部選択統計。\n       * @private\n       * @type {Object}\n       */\n      this._selectionStats = this._selectionStats || {\n        strategy: 'none',\n        clippedNonEmpty: 0,\n        coverageRatio: 1.0\n      };\n    }\n\n    // ADR-0008 Phase 3: Use rendering engine to render voxels  \n    const entities = this.renderingEngine.renderVoxels(\n      displayVoxels, \n      topNVoxels, \n      bounds, \n      grid, \n      statistics, \n      {\n        ...this.options,\n        createVoxelDescription: this.descriptionBuilder.createVoxelDescription.bind(this.descriptionBuilder)\n      },\n      this._calculateAdaptiveParams.bind(this),\n      this.outlineRenderer,\n      this.adaptiveOutlineController\n    );\n\n    // Add entities to manager\n    entities.forEach(entity => this.entityManager.addEntity(entity));\n\n    Logger.info(`Successfully rendered ${entities.length} voxels`);\n    return entities.length;\n  }\n\n  /**\n   * Backward-compatible color interpolation API.\n   * 後方互換の色補間API（Phase1抽出後もI/F維持）。\n   * @param {number} normalizedDensity\n   * @param {number} [rawValue]\n   * @returns {Cesium.Color}\n   */\n  interpolateColor(normalizedDensity, rawValue = null) {\n    return ColorMap.interpolateColor(normalizedDensity, rawValue, this.options);\n  }\n\n  /**\n   * Backward-compatible debug bounds flag checker.\n   * 後方互換のデバッグ境界表示判定（旧_private I/F維持）。\n   * @returns {boolean}\n   * @private\n   */\n  _shouldShowBounds() {\n    return this.debugRenderer.shouldShowBounds(this.options?.debug);\n  }\n\n  /**\n   * 描画されたエンティティを全てクリア\n   */\n  clear() {\n    // ADR-0008 Phase 3: Use entity manager for clearing\n    this.entityManager.clear();\n    \n    // ADR-0008 Phase 1: DebugRendererもクリア\n    if (this.debugRenderer) {\n      this.debugRenderer.clear();\n    }\n  }\n\n  /**\n   * Toggle visibility.\n   * 表示/非表示を切り替え。\n   * @param {boolean} show - true=表示 false=非表示\n   */\n  setVisible(show) {\n    // ADR-0008 Phase 3: Use entity manager for visibility control\n    this.entityManager.setVisible(show);\n  }\n\n  /**\n   * Select voxels for rendering based on the specified strategy.\n   * 指定された戦略に基づいてレンダリング用ボクセルを選択します。\n   * @param {Array} allVoxels - All voxels / 全ボクセル\n   * @param {number} maxCount - Maximum count / 最大数\n   * @param {Object} bounds - Bounds / 境界\n   * @param {Object} grid - Grid / グリッド\n   * @returns {Object} Selection result / 選択結果\n   * @private\n   */\n  _selectVoxelsForRendering(allVoxels, maxCount, bounds, grid) {\n    const strategy = this.options.voxelSelectionStrategy || 'density';\n    let selectedVoxels;\n    let clippedCount;\n    let coverageRatio;\n\n    // TopNボクセルの処理\n    const topNVoxels = new Set();\n    if (this.options.highlightTopN && this.options.highlightTopN > 0) {\n      const sortedForTopN = [...allVoxels].sort((a, b) => b.info.count - a.info.count);\n      const topN = sortedForTopN.slice(0, this.options.highlightTopN);\n      topN.forEach(voxel => topNVoxels.add(voxel.key));\n    }\n    \n    switch (strategy) {\n      case 'coverage': {\n        const coverageResult = this._selectionStrategies.coverage.select(allVoxels, maxCount, grid, topNVoxels, this.options);\n        selectedVoxels = coverageResult.selected;\n        clippedCount = allVoxels.length - selectedVoxels.length;\n        break;\n      }\n      \n      case 'hybrid': {\n        const hybridResult = this._selectionStrategies.hybrid.select(allVoxels, maxCount, grid, topNVoxels, this.options);\n        selectedVoxels = hybridResult.selected;\n        clippedCount = allVoxels.length - selectedVoxels.length;\n        coverageRatio = hybridResult.metadata?.coverageRatio;\n        break;\n      }\n      \n      case 'density':\n      default: {\n        const densityStrategy = this._selectionStrategies.density;\n        const densityResult = densityStrategy.select(allVoxels, maxCount, grid, topNVoxels, this.options);\n        selectedVoxels = densityResult.selected;\n        clippedCount = densityResult.metadata.clippedCount;\n        break;\n      }\n    }\n    \n    return {\n      selectedVoxels,\n      strategy,\n      clippedNonEmpty: clippedCount,\n      coverageRatio\n    };\n  }\n\n  /**\n   * Get selection statistics.\n   * 選択統計を取得します。\n   * @returns {Object|null} Selection statistics / 選択統計\n   */\n  getSelectionStats() {\n    return this._selectionStats || null;\n  }\n\n  /**\n   * Backward compatibility: Get voxel entities.\n   * 後方互換性: ボクセルエンティティを取得。\n   * @returns {Array} Voxel entities / ボクセルエンティティ\n   */\n  get voxelEntities() {\n    return this.entityManager.voxelEntities || [];\n  }\n\n  /**\n   * Backward compatibility: Check if inset outline should be applied.\n   * 後方互換性: インセット枠線を適用すべきかどうかを判定。\n   * @param {boolean} isTopN - Is TopN voxel / TopNボクセルか\n   * @returns {boolean} Whether to apply inset outline / インセット枠線を適用するかどうか\n   * @private\n   */\n  _shouldApplyInsetOutline(isTopN) {\n    const mode = this.options.outlineInsetMode || 'all';\n    if (mode === 'topn') return !!isTopN;\n    return true;\n  }\n}\n","/**\n * ViewFitter utility for optimal camera positioning.\n * カメラの最適配置のためのViewFitterユーティリティ\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from './logger.js';\n\n/**\n * Utility class for fitting camera view to data bounds.\n * データ境界にカメラビューを合わせるためのユーティリティクラス\n */\nexport class ViewFitter {\n  /**\n   * Fit camera view to data bounds with optimal positioning.\n   * データ境界に最適な位置でカメラビューを合わせます。\n   * \n   * @param {Cesium.Viewer} viewer - Cesium viewer instance / Cesiumビューアインスタンス\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} options - View fitting options / ビューフィッティングオプション\n   * @returns {Promise} Promise that resolves when camera movement completes / カメラ移動完了時に解決されるPromise\n   */\n  static async fitToBounds(viewer, bounds, options = {}) {\n    try {\n      if (!viewer || !bounds) {\n        throw new Error('Viewer and bounds are required');\n      }\n      \n      // 境界の妥当性チェック\n      if (!ViewFitter._isValidBounds(bounds)) {\n        Logger.warn('Invalid bounds provided to ViewFitter:', bounds);\n        return Promise.resolve();\n      }\n      \n      // オプションのマージ\n      const fitOptions = {\n        paddingPercent: 0.1,\n        pitchDegrees: -45,\n        headingDegrees: 0,\n        duration: 2.0,\n        maximumHeight: 50000,\n        minimumHeight: 100,\n        ...options\n      };\n      \n      Logger.debug('ViewFitter: fitting to bounds', bounds, 'with options', fitOptions);\n      \n      // データ範囲が極小または極大の場合の特別処理\n      const dataRange = ViewFitter._calculateDataRange(bounds);\n      const maxRange = Math.max(dataRange.x, dataRange.y, dataRange.z);\n      \n      if (maxRange < 10) {\n        return ViewFitter._handleMinimalDataRange(viewer, bounds, fitOptions);\n      }\n      \n      if (maxRange > 100000) {\n        return ViewFitter._handleLargeDataRange(viewer, bounds, fitOptions);\n      }\n      \n      // 標準的なカメラ配置計算\n      return ViewFitter._executeStandardFit(viewer, bounds, fitOptions, maxRange);\n      \n    } catch (error) {\n      Logger.error('ViewFitter: Failed to fit view to bounds:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Calculate data range in meters from bounds.\n   * 境界からメートル単位のデータ範囲を計算します。\n   * @param {Object} bounds - Data bounds / データ境界\n   * @returns {Object} Data range {x, y, z} in meters / メートル単位のデータ範囲\n   * @private\n   */\n  static _calculateDataRange(bounds) {\n    // 緯度経度をメートルに変換（簡易変換）\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    const cosLat = Math.cos(centerLat * Math.PI / 180);\n    \n    const lonRangeMeters = (bounds.maxLon - bounds.minLon) * 111000 * cosLat;\n    const latRangeMeters = (bounds.maxLat - bounds.minLat) * 111000;\n    const altRangeMeters = Math.max(bounds.maxAlt - bounds.minAlt, 1);\n    \n    return {\n      x: Math.max(lonRangeMeters, 1),\n      y: Math.max(latRangeMeters, 1),\n      z: altRangeMeters\n    };\n  }\n  \n  /**\n   * Validate bounds object.\n   * 境界オブジェクトの妥当性をチェックします。\n   * @param {Object} bounds - Bounds to validate / 検証する境界\n   * @returns {boolean} True if valid / 有効な場合true\n   * @private\n   */\n  static _isValidBounds(bounds) {\n    if (!bounds) {\n      return false;\n    }\n    \n    return typeof bounds.minLon === 'number' && !isNaN(bounds.minLon) &&\n           typeof bounds.maxLon === 'number' && !isNaN(bounds.maxLon) &&\n           typeof bounds.minLat === 'number' && !isNaN(bounds.minLat) &&\n           typeof bounds.maxLat === 'number' && !isNaN(bounds.maxLat) &&\n           typeof bounds.minAlt === 'number' && !isNaN(bounds.minAlt) &&\n           typeof bounds.maxAlt === 'number' && !isNaN(bounds.maxAlt) &&\n           bounds.minLon <= bounds.maxLon &&\n           bounds.minLat <= bounds.maxLat &&\n           bounds.minAlt <= bounds.maxAlt;\n  }\n  \n  /**\n   * Handle minimal data range (very small datasets).\n   * 極小データ範囲の処理（非常に小さなデータセット）\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesiumビューア\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} options - Fit options / フィットオプション\n   * @returns {Promise} Camera movement promise / カメラ移動Promise\n   * @private\n   */\n  static _handleMinimalDataRange(viewer, bounds, options) {\n    Logger.debug('ViewFitter: handling minimal data range');\n    \n    const centerLon = (bounds.minLon + bounds.maxLon) / 2;\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    \n    // 極小データの場合は固定高度を使用\n    const fixedHeight = Math.max(options.minimumHeight, 500);\n    \n    return ViewFitter._executeCameraMovement(viewer, {\n      destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, fixedHeight),\n      orientation: {\n        heading: Cesium.Math.toRadians(options.headingDegrees),\n        pitch: Cesium.Math.toRadians(options.pitchDegrees),\n        roll: 0.0\n      },\n      duration: options.duration\n    });\n  }\n  \n  /**\n   * Handle large data range (very large datasets).\n   * 極大データ範囲の処理（非常に大きなデータセット）\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesiumビューア\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} options - Fit options / フィットオプション\n   * @returns {Promise} Camera movement promise / カメラ移動Promise\n   * @private\n   */\n  static _handleLargeDataRange(viewer, bounds, options) {\n    Logger.debug('ViewFitter: handling large data range');\n    \n    // 大きなデータセットの場合はRectangleを使用\n    const rectangle = Cesium.Rectangle.fromDegrees(\n      bounds.minLon, bounds.minLat, bounds.maxLon, bounds.maxLat\n    );\n    \n    const cameraOptions = {\n      duration: options.duration,\n      maximumHeight: options.maximumHeight\n    };\n    \n    return new Promise((resolve, reject) => {\n      try {\n        viewer.camera.flyTo({\n          destination: rectangle,\n          ...cameraOptions,\n          complete: () => {\n            Logger.debug('ViewFitter: large data range fit completed');\n            resolve();\n          },\n          cancel: () => {\n            Logger.debug('ViewFitter: large data range fit cancelled');\n            resolve();\n          }\n        });\n      } catch (error) {\n        Logger.error('ViewFitter: large data range fit failed:', error);\n        reject(error);\n      }\n    });\n  }\n  \n  /**\n   * Execute standard camera fit for normal data ranges.\n   * 通常のデータ範囲に対する標準カメラフィットを実行します。\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesiumビューア\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} options - Fit options / フィットオプション\n   * @param {number} maxRange - Maximum data range / 最大データ範囲\n   * @returns {Promise} Camera movement promise / カメラ移動Promise\n   * @private\n   */\n  static _executeStandardFit(viewer, bounds, options, maxRange) {\n    const centerLon = (bounds.minLon + bounds.maxLon) / 2;\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    \n    // パディングの計算\n    const paddingPercent = Math.max(0.05, Math.min(0.5, options.paddingPercent));\n    const paddingMeters = paddingPercent * maxRange;\n    \n    // カメラ高度の計算\n    const cameraHeight = ViewFitter._calculateOptimalCameraHeight(\n      maxRange, \n      paddingMeters, \n      options\n    );\n    \n    // カメラ移動の実行\n    return ViewFitter._executeCameraMovement(viewer, {\n      destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, cameraHeight),\n      orientation: {\n        heading: Cesium.Math.toRadians(options.headingDegrees),\n        pitch: Cesium.Math.toRadians(options.pitchDegrees),\n        roll: 0.0\n      },\n      duration: options.duration\n    });\n  }\n  \n  /**\n   * Calculate optimal camera height based on data range and viewing parameters.\n   * データ範囲と表示パラメータに基づいて最適なカメラ高度を計算します。\n   * @param {number} maxRange - Maximum data range / 最大データ範囲\n   * @param {number} paddingMeters - Padding in meters / メートル単位のパディング\n   * @param {Object} options - Fit options / フィットオプション\n   * @returns {number} Optimal camera height / 最適なカメラ高度\n   * @private\n   */\n  static _calculateOptimalCameraHeight(maxRange, paddingMeters, options) {\n    // 視野角（通常60度程度）\n    const fovRadians = Math.PI / 3; // 60度\n    const pitchRadians = Math.abs(Cesium.Math.toRadians(options.pitchDegrees));\n    \n    // ピッチを考慮した有効表示範囲\n    const effectiveRange = maxRange + (2 * paddingMeters);\n    const pitchFactor = Math.cos(pitchRadians);\n    \n    // 基本的な高度計算\n    let cameraHeight = (effectiveRange / pitchFactor) / (2 * Math.tan(fovRadians / 2));\n    \n    // 安全マージンの追加（20%）\n    cameraHeight *= 1.2;\n    \n    // 高度制限の適用（安全マージン後）\n    cameraHeight = Math.max(options.minimumHeight, \n                          Math.min(options.maximumHeight, cameraHeight));\n    \n    return cameraHeight;\n  }\n  \n  /**\n   * Execute camera movement with proper promise handling.\n   * 適切なPromise処理でカメラ移動を実行します。\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesiumビューア\n   * @param {Object} cameraOptions - Camera movement options / カメラ移動オプション\n   * @returns {Promise} Camera movement promise / カメラ移動Promise\n   * @private\n   */\n  static _executeCameraMovement(viewer, cameraOptions) {\n    return new Promise((resolve, reject) => {\n      try {\n        const flyToOptions = {\n          ...cameraOptions,\n          complete: () => {\n            Logger.debug('ViewFitter: camera movement completed');\n            resolve();\n          },\n          cancel: () => {\n            Logger.debug('ViewFitter: camera movement cancelled');\n            resolve();\n          }\n        };\n        \n        viewer.camera.flyTo(flyToOptions);\n        \n      } catch (error) {\n        Logger.error('ViewFitter: camera movement failed:', error);\n        reject(error);\n      }\n    });\n  }\n  \n  /**\n   * Create a Rectangle from bounds for large datasets.\n   * 大きなデータセット用に境界からRectangleを作成します。\n   * @param {Object} bounds - Data bounds / データ境界\n   * @returns {Cesium.Rectangle} Cesium Rectangle / CesiumのRectangle\n   * @static\n   */\n  static createRectangleFromBounds(bounds) {\n    if (!ViewFitter._isValidBounds(bounds)) {\n      throw new Error('Invalid bounds provided');\n    }\n    \n    return Cesium.Rectangle.fromDegrees(\n      bounds.minLon, bounds.minLat, bounds.maxLon, bounds.maxLat\n    );\n  }\n  \n  /**\n   * Calculate camera position for specific viewing angle.\n   * 特定の視角に対するカメラ位置を計算します。\n   * @param {Object} bounds - Data bounds / データ境界\n   * @param {Object} viewOptions - View options / ビューオプション\n   * @returns {Object} Camera position and orientation / カメラ位置と向き\n   * @static\n   */\n  static calculateCameraPosition(bounds, viewOptions = {}) {\n    if (!ViewFitter._isValidBounds(bounds)) {\n      throw new Error('Invalid bounds provided');\n    }\n    \n    const options = {\n      paddingPercent: 0.1,\n      pitchDegrees: -45,\n      headingDegrees: 0,\n      minimumHeight: 100,\n      maximumHeight: 50000,\n      ...viewOptions\n    };\n    \n    const centerLon = (bounds.minLon + bounds.maxLon) / 2;\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    const dataRange = ViewFitter._calculateDataRange(bounds);\n    const maxRange = Math.max(dataRange.x, dataRange.y, dataRange.z);\n    \n    const paddingMeters = options.paddingPercent * maxRange;\n    const cameraHeight = ViewFitter._calculateOptimalCameraHeight(\n      maxRange, paddingMeters, options\n    );\n    \n    return {\n      position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, cameraHeight),\n      orientation: {\n        heading: Cesium.Math.toRadians(options.headingDegrees),\n        pitch: Cesium.Math.toRadians(options.pitchDegrees),\n        roll: 0.0\n      },\n      metadata: {\n        dataRange: maxRange,\n        cameraHeight,\n        paddingMeters\n      }\n    };\n  }\n}\n","/**\n * CesiumJS Heatbox - Main library entry point with comprehensive API exports.\n * CesiumJS Heatbox - 包括的API エクスポートを備えたメインライブラリエントリーポイント。\n * \n * This module serves as the primary entry point for the CesiumJS Heatbox library,\n * providing all essential classes, utilities, and helper functions needed for \n * 3D voxel-based heatmap visualization. Includes both default and named exports\n * for maximum compatibility with different import styles.\n * \n * このモジュールは CesiumJS Heatbox ライブラリの主要エントリーポイントとして機能し、\n * 3D ボクセルベースのヒートマップ可視化に必要なすべての重要なクラス、ユーティリティ、\n * ヘルパー関数を提供します。異なるインポートスタイルとの最大互換性のため、\n * デフォルトエクスポートと名前付きエクスポートの両方を含みます。\n * \n * @fileoverview Main entry point for CesiumJS Heatbox library\n * @author cesium-heatbox team\n * @version 0.1.10-alpha.1\n * @since 0.1.0\n */\n\nimport { Heatbox } from './Heatbox.js';\nimport { Logger } from './utils/logger.js';\nimport { getAllEntities, generateTestEntities } from './utils/sampleData.js';\n\n// デフォルトエクスポート\nexport default Heatbox;\n\n// 名前付きエクスポート\nexport { Heatbox };\nexport { getAllEntities, generateTestEntities };\n\n// 互換性のための追加エクスポート\nexport { Heatbox as CesiumHeatbox };\n\n/**\n * Library metadata.\n * ライブラリのメタ情報。\n */\nexport const VERSION = '0.1.9';\nexport const AUTHOR = 'hiro-nyon';\nexport const REPOSITORY = 'https://github.com/hiro-nyon/cesium-heatbox';\n\n/**\n * Convenient factory function for quick Heatbox instance creation.\n * 迅速なHeatboxインスタンス作成のための便利なファクトリー関数。\n * \n * This helper function provides a streamlined way to create Heatbox instances\n * without needing to import the class directly. Ideal for quick prototyping\n * and simple use cases where minimal setup is desired.\n * \n * このヘルパー関数は、クラスを直接インポートすることなく、Heatboxインスタンスを\n * 作成する合理化された方法を提供します。迅速なプロトタイピングと最小限の\n * セットアップが望まれるシンプルな使用例に理想的です。\n * \n * @param {Cesium.Viewer} viewer - Initialized CesiumJS Viewer instance / 初期化されたCesiumJSビューアーインスタンス\n * @param {Object} [options={}] - Heatbox configuration options / Heatbox設定オプション\n * @returns {Heatbox} Fully configured Heatbox instance ready for use / 使用準備完了の完全設定済みHeatboxインスタンス\n * \n * @example\n * // Quick setup with default options / デフォルトオプションでのクイックセットアップ\n * import { createHeatbox } from 'cesium-heatbox';\n * const heatbox = createHeatbox(viewer);\n * \n * @example\n * // With custom configuration / カスタム設定付き\n * const heatbox = createHeatbox(viewer, {\n *   voxelSize: 50,\n *   opacity: 0.8,\n *   colorMap: 'viridis'\n * });\n * \n * @since v0.1.0\n */\nexport function createHeatbox(viewer, options) {\n  return new Heatbox(viewer, options);\n}\n\n/**\n * Comprehensive environment detection and capability assessment.\n * 包括的な環境検出と機能評価。\n * \n * This diagnostic function analyzes the current runtime environment to provide\n * detailed information about browser capabilities, CesiumJS version, WebGL support,\n * and other relevant technical details. Essential for troubleshooting and\n * ensuring optimal performance configuration.\n * \n * この診断関数は現在の実行環境を分析して、ブラウザー機能、CesiumJSバージョン、\n * WebGLサポート、その他の関連技術詳細に関する詳細情報を提供します。\n * トラブルシューティングと最適なパフォーマンス構成の確保に不可欠です。\n * \n * @returns {Object} Comprehensive environment information / 包括的な環境情報\n * @returns {string} returns.version - Current library version / 現在のライブラリバージョン\n * @returns {string} returns.cesiumVersion - CesiumJS version if available / 利用可能な場合のCesiumJSバージョン\n * @returns {string} returns.userAgent - Browser user agent string / ブラウザーユーザーエージェント文字列\n * @returns {boolean} returns.webglSupport - Whether WebGL is supported / WebGLサポートの可否\n * @returns {string} returns.timestamp - ISO timestamp of assessment / 評価のISOタイムスタンプ\n * \n * @example\n * // Environment diagnostics / 環境診断\n * import { getEnvironmentInfo } from 'cesium-heatbox';\n * const env = getEnvironmentInfo();\n * console.log(`Running Heatbox v${env.version} with Cesium ${env.cesiumVersion}`);\n * \n * @example\n * // Check WebGL support before initialization / 初期化前のWebGLサポート確認\n * const env = getEnvironmentInfo();\n * if (!env.webglSupport) {\n *   console.error('WebGL not supported - heatmap visualization unavailable');\n * }\n * \n * @since v0.1.0\n */\nexport function getEnvironmentInfo() {\n  // WebGL サポートの確認\n  let webglSupport = false;\n  try {\n    if (typeof WebGLRenderingContext !== 'undefined') {\n      const canvas = document.createElement('canvas');\n      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n      webglSupport = !!gl;\n    }\n  } catch (_e) {\n    webglSupport = false;\n  }\n  \n  return {\n    version: VERSION,\n    cesiumVersion: typeof Cesium !== 'undefined' ? Cesium.VERSION : 'N/A',\n    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'N/A',\n    webglSupport: webglSupport,\n    timestamp: new Date().toISOString()\n  };\n}\n\n// ライブラリの初期化ログ\nLogger.info(`CesiumJS Heatbox v${VERSION} loaded`);\n","/**\n * CesiumJS Heatbox - メインクラス\n */\nimport * as Cesium from 'cesium';\nimport { DEFAULT_OPTIONS, ERROR_MESSAGES, PERFORMANCE_LIMITS } from './utils/constants.js';\nimport { \n  isValidViewer,\n  isValidEntities,\n  validateAndNormalizeOptions,\n  validateVoxelCount,\n  calculateDataRange\n} from './utils/validation.js';\nimport { DeviceTierDetector } from './utils/deviceTierDetector.js';\nimport { VoxelSizeEstimator } from './utils/voxelSizeEstimator.js';\nimport { Logger } from './utils/logger.js';\nimport { CoordinateTransformer } from './core/CoordinateTransformer.js';\nimport { VoxelGrid } from './core/VoxelGrid.js';\nimport { DataProcessor } from './core/DataProcessor.js';\nimport { VoxelRenderer } from './core/VoxelRenderer.js';\nimport { ViewFitter } from './utils/ViewFitter.js';\n\n/**\n * Main class of CesiumJS Heatbox.\n * Provides 3D voxel-based heatmap visualization in CesiumJS environments.\n *\n * CesiumJS Heatbox メインクラス。\n * CesiumJS 環境で 3D ボクセルベースのヒートマップ可視化を提供します。\n */\nexport class Heatbox {\n  /**\n   * Constructor\n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer instance / CesiumJS Viewer インスタンス\n   * @param {Object} options - Configuration options / 設定オプション\n   */\n  constructor(viewer, options = {}) {\n    if (!isValidViewer(viewer)) {\n      throw new Error(ERROR_MESSAGES.INVALID_VIEWER);\n    }\n    \n    this.viewer = viewer;\n    \n    // v0.1.9: Auto Render Budgetの適用\n    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n    this.options = validateAndNormalizeOptions(DeviceTierDetector.applyAutoRenderBudget(mergedOptions));\n    \n    // ログレベルをオプションに基づいて設定\n    Logger.setLogLevel(this.options);\n    this.renderer = new VoxelRenderer(this.viewer, this.options);\n    this.viewFitter = new ViewFitter(this.viewer);\n    \n    this._bounds = null;\n    this._grid = null;\n    this._voxelData = null;\n    this._statistics = null;\n    this._eventHandler = null;\n\n    this._initializeEventListeners();\n  }\n\n  /**\n   * Set heatmap data and render 3D voxel visualization.\n   * ヒートマップデータを設定し、3Dボクセル可視化を描画します。\n   * \n   * This method processes the provided entity array, calculates optimal voxel grid,\n   * and renders 3D voxel-based heatmap visualization in the Cesium viewer.\n   * \n   * このメソッドは提供されたエンティティ配列を処理し、最適なボクセルグリッドを計算して、\n   * Cesiumビューアーで3Dボクセルベースのヒートマップ可視化を描画します。\n   * \n   * @param {Cesium.Entity[]} entities - Array of Cesium entities with position information / 位置情報を持つCesiumエンティティの配列\n   * @throws {Error} Throws error if entities array is invalid / エンティティ配列が無効な場合はエラーを投げます\n   * @returns {Promise<void>} Promise that resolves when rendering is complete / 描画完了時に解決するPromise\n   * \n   * @example\n   * // Basic usage / 基本使用法\n   * const entities = generateTestEntities(viewer, bounds, 1000);\n   * await heatbox.setData(entities);\n   * \n   * @example  \n   * // With error handling / エラーハンドリング付き\n   * try {\n   *   await heatbox.setData(entities);\n   *   console.log('Heatmap rendered successfully');\n   * } catch (error) {\n   *   console.error('Failed to render heatmap:', error);\n   * }\n   * \n   * @since v0.1.0\n   */\n  async setData(entities) {\n    if (!isValidEntities(entities)) {\n      this.clear();\n      return;\n    }\n    \n    try {\n      Logger.debug('Heatbox.setData - 処理開始:', entities.length, '個のエンティティ');\n      \n      // 1. 境界計算\n      Logger.debug('Step 1: 境界計算');\n      this._bounds = CoordinateTransformer.calculateBounds(entities);\n      if (!this._bounds) {\n        Logger.error('境界計算に失敗');\n        this.clear();\n        return;\n      }\n      Logger.debug('境界計算完了:', this._bounds);\n\n      // v0.1.4+v0.1.9: 自動ボクセルサイズ調整（占有率ベース対応）\n      let finalVoxelSize = this.options.voxelSize || DEFAULT_OPTIONS.voxelSize;\n      let autoAdjustmentInfo = null;\n      \n      if (this.options.autoVoxelSize && !this.options.voxelSize) {\n        try {\n          Logger.debug('自動ボクセルサイズ調整開始');\n          \n          // v0.1.9: 占有率ベースの計算オプション\n          const sizeOptions = {\n            autoVoxelSizeMode: this.options.autoVoxelSizeMode,\n            autoVoxelTargetFill: this.options.autoVoxelTargetFill,\n            maxRenderVoxels: this.options.maxRenderVoxels\n          };\n          \n          const estimatedSize = VoxelSizeEstimator.estimate(entities, this._bounds, this.options.autoVoxelSizeMode, sizeOptions);\n          const tempGrid = VoxelGrid.createGrid(this._bounds, estimatedSize);\n          const validation = validateVoxelCount(tempGrid.totalVoxels, estimatedSize);\n          \n          if (!validation.valid && validation.recommendedSize) {\n            finalVoxelSize = validation.recommendedSize;\n            autoAdjustmentInfo = {\n              enabled: true,\n              mode: this.options.autoVoxelSizeMode,\n              originalSize: estimatedSize,\n              finalSize: finalVoxelSize,\n              adjusted: true,\n              reason: `Performance limit exceeded: ${tempGrid.totalVoxels} > ${PERFORMANCE_LIMITS.maxVoxels}`\n            };\n            Logger.info(`Auto-adjusted voxelSize: ${estimatedSize}m → ${finalVoxelSize}m (${tempGrid.totalVoxels} voxels)`);\n          } else {\n            finalVoxelSize = estimatedSize;\n            autoAdjustmentInfo = {\n              enabled: true,\n              mode: this.options.autoVoxelSizeMode,\n              originalSize: estimatedSize,\n              finalSize: finalVoxelSize,\n              adjusted: false,\n              reason: null\n            };\n            Logger.info(`Auto-determined voxelSize: ${finalVoxelSize}m`);\n          }\n        } catch (error) {\n          Logger.warn('Auto voxel size adjustment failed, using default:', error);\n          finalVoxelSize = DEFAULT_OPTIONS.voxelSize;\n          autoAdjustmentInfo = {\n            enabled: true,\n            adjusted: false,\n            reason: 'Estimation failed, using default size',\n            originalSize: null,\n            finalSize: finalVoxelSize\n          };\n        }\n      }\n\n      // 2. グリッド生成（最終的なボクセルサイズを使用）\n      Logger.debug('Step 2: グリッド生成 (サイズ:', finalVoxelSize, 'm)');\n      this._grid = VoxelGrid.createGrid(this._bounds, finalVoxelSize);\n      Logger.debug('グリッド生成完了:', this._grid);\n      \n      // 3. エンティティ分類\n      Logger.debug('Step 3: エンティティ分類');\n      this._voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, this._bounds, this._grid);\n      Logger.debug('エンティティ分類完了:', this._voxelData.size, '個のボクセル');\n      \n      // 4. 統計計算\n      Logger.debug('Step 4: 統計計算');\n      this._statistics = DataProcessor.calculateStatistics(this._voxelData, this._grid);\n      Logger.debug('統計情報:', this._statistics);\n      \n      // 統計情報に自動調整情報を追加\n      if (autoAdjustmentInfo) {\n        this._statistics.autoAdjusted = autoAdjustmentInfo.adjusted;\n        this._statistics.originalVoxelSize = autoAdjustmentInfo.originalSize;\n        this._statistics.finalVoxelSize = autoAdjustmentInfo.finalSize;\n        this._statistics.adjustmentReason = autoAdjustmentInfo.reason;\n      }\n      \n      // 5. 描画\n      Logger.debug('Step 5: 描画');\n      const renderedVoxelCount = this.renderer.render(this._voxelData, this._bounds, this._grid, this._statistics);\n      \n      // 統計情報に実際の描画数を反映\n      this._statistics.renderedVoxels = renderedVoxelCount;\n      Logger.info('描画完了 - 実際の描画数:', renderedVoxelCount);\n      \n      // v0.1.9: 自動視点調整\n      if (this.options.autoView) {\n        try {\n          Logger.debug('Auto view adjustment triggered');\n          await this.fitView();\n          Logger.debug('Auto view adjustment completed');\n        } catch (error) {\n          Logger.warn('Auto view adjustment failed:', error);\n          // 自動視点調整の失敗は致命的エラーとしない\n        }\n      }\n      \n      Logger.debug('Heatbox.setData - 処理完了');\n      \n    } catch (error) {\n      Logger.error('ヒートマップ作成エラー:', error);\n      this.clear();\n      throw error;\n    }\n  }\n\n  /**\n   * Create heatmap from entities and return detailed statistics.\n   * エンティティからヒートマップを作成し、詳細統計情報を返します。\n   * \n   * This method is equivalent to calling setData() followed by getStatistics().\n   * It processes the entity array to create voxel-based heatmap visualization\n   * and returns comprehensive statistics about the rendered result.\n   * \n   * このメソッドは setData() に続けて getStatistics() を呼び出すことと同等です。\n   * エンティティ配列を処理してボクセルベースのヒートマップ可視化を作成し、\n   * レンダリング結果に関する包括的な統計情報を返します。\n   * \n   * @param {Cesium.Entity[]} entities - Array of Cesium entities to process / 処理するCesiumエンティティの配列\n   * @returns {Promise<Object>} Detailed rendering statistics / 詳細なレンダリング統計情報\n   * @returns {Promise<number>} returns.totalVoxels - Total number of voxels in grid / グリッド内の総ボクセル数\n   * @returns {Promise<number>} returns.renderedVoxels - Number of actually rendered voxels / 実際にレンダリングされたボクセル数\n   * @returns {Promise<number>} returns.nonEmptyVoxels - Number of voxels containing data / データを含むボクセル数\n   * @returns {Promise<number>} returns.minCount - Minimum entity count in any voxel / 任意のボクセル内の最小エンティティ数\n   * @returns {Promise<number>} returns.maxCount - Maximum entity count in any voxel / 任意のボクセル内の最大エンティティ数\n   * @returns {Promise<number>} returns.averageCount - Average entity count per non-empty voxel / 非空ボクセルあたりの平均エンティティ数\n   * @throws {Error} Throws error if entities array is empty or invalid / エンティティ配列が空または無効な場合はエラーを投げます\n   * \n   * @example\n   * // Create heatmap and get statistics / ヒートマップ作成と統計取得\n   * const entities = generateTestEntities(viewer, bounds, 1000);\n   * const stats = await heatbox.createFromEntities(entities);\n   * console.log(`Rendered ${stats.renderedVoxels} out of ${stats.totalVoxels} voxels`);\n   * \n   * @example\n   * // Error handling with statistics / 統計情報付きエラーハンドリング\n   * try {\n   *   const stats = await heatbox.createFromEntities(entities);\n   *   if (stats.renderedVoxels === 0) {\n   *     console.warn('No voxels were rendered - check data distribution');\n   *   }\n   * } catch (error) {\n   *   console.error('Failed to create heatmap:', error);\n   * }\n   * \n   * @since v0.1.0\n   * @see {@link setData} For data processing without returning statistics\n   * @see {@link getStatistics} For retrieving statistics after rendering\n   */\n  async createFromEntities(entities) {\n    if (!isValidEntities(entities)) {\n      throw new Error(ERROR_MESSAGES.NO_ENTITIES);\n    }\n    await this.setData(entities);\n    return this.getStatistics();\n  }\n\n  /**\n   * Control heatmap visibility without clearing data or re-rendering.\n   * データやレンダリングをクリアすることなくヒートマップの表示を制御します。\n   * \n   * This method efficiently toggles the visibility of all rendered voxels\n   * by setting the 'show' property on Cesium entities. The underlying data\n   * and voxel grid remain intact, allowing for fast show/hide operations.\n   * \n   * このメソッドはCesiumエンティティの'show'プロパティを設定することで、\n   * レンダリングされた全ボクセルの表示を効率的に切り替えます。基盤データと\n   * ボクセルグリッドはそのまま保持され、高速な表示/非表示操作が可能です。\n   * \n   * @param {boolean} show - Whether to show the heatmap (true) or hide it (false) / ヒートマップを表示する（true）か隠す（false）か\n   * @returns {void}\n   * \n   * @example\n   * // Show heatmap / ヒートマップを表示\n   * heatbox.setVisible(true);\n   * \n   * @example\n   * // Hide heatmap temporarily / 一時的にヒートマップを隠す\n   * heatbox.setVisible(false);\n   * // ... other operations ...\n   * heatbox.setVisible(true); // Show again quickly\n   * \n   * @example\n   * // Toggle visibility based on user interaction / ユーザー操作に基づく表示切り替え\n   * const toggleButton = document.getElementById('toggleHeatmap');\n   * let isVisible = true;\n   * toggleButton.onclick = () => {\n   *   isVisible = !isVisible;\n   *   heatbox.setVisible(isVisible);\n   *   toggleButton.textContent = isVisible ? 'Hide' : 'Show';\n   * };\n   * \n   * @since v0.1.0\n   * @see {@link clear} For permanently removing the heatmap\n   */\n  setVisible(show) {\n    this.renderer.setVisible(show);\n  }\n\n  /**\n   * Completely clear heatmap visualization and reset internal state.\n   * ヒートマップ可視化を完全にクリアし、内部状態をリセットします。\n   * \n   * This method removes all rendered voxel entities from the Cesium viewer and\n   * resets all internal data structures (bounds, grid, voxel data, statistics).\n   * After calling this method, the Heatbox instance returns to its initial state\n   * and is ready to process new data.\n   * \n   * このメソッドは、レンダリングされた全ボクセルエンティティをCesiumビューアーから削除し、\n   * 全ての内部データ構造（境界、グリッド、ボクセルデータ、統計）をリセットします。\n   * このメソッドを呼び出した後、Heatboxインスタンスは初期状態に戻り、新しいデータを処理する準備ができます。\n   * \n   * @returns {void}\n   * \n   * @example\n   * // Clear current heatmap before loading new data / 新しいデータを読み込む前に現在のヒートマップをクリア\n   * heatbox.clear();\n   * await heatbox.setData(newEntities);\n   * \n   * @example\n   * // Clean up when component is destroyed / コンポーネント破棄時のクリーンアップ\n   * const cleanup = () => {\n   *   heatbox.clear();\n   *   heatbox.destroy(); // Final cleanup\n   * };\n   * \n   * @example\n   * // Reset to initial state for reuse / 再利用のため初期状態にリセット\n   * heatbox.clear();\n   * console.log(heatbox.getBounds()); // null - no data loaded\n   * console.log(heatbox.getStatistics()); // null - no statistics available\n   * \n   * @since v0.1.0\n   * @see {@link setVisible} For temporary hiding without clearing data\n   * @see {@link destroy} For final cleanup including event handlers\n   */\n  clear() {\n    this.renderer.clear();\n    this._bounds = null;\n    this._grid = null;\n    this._voxelData = null;\n    this._statistics = null;\n  }\n\n  /**\n   * Destroy the instance and release event listeners.\n   * インスタンスを破棄し、イベントリスナーを解放します。\n   */\n  destroy() {\n    this.clear();\n    if (this._eventHandler && !this._eventHandler.isDestroyed()) {\n      this._eventHandler.destroy();\n    }\n    this._eventHandler = null;\n  }\n\n  /**\n   * Alias for destroy() to match examples and tests.\n   * 互換性のための別名。destroy() を呼び出します。\n   */\n  dispose() {\n    this.destroy();\n  }\n\n  /**\n   * Get current options.\n   * 現在のオプションを取得します。\n   * @returns {Object} Options / オプション\n   */\n  getOptions() {\n    return { ...this.options };\n  }\n\n  /**\n   * Update heatbox configuration options and automatically re-render if data exists.\n   * ヒートボックスの設定オプションを更新し、データが存在する場合は自動的に再描画します。\n   * \n   * This method merges new options with existing configuration and triggers \n   * automatic re-rendering when data is already loaded. Options are validated\n   * and normalized before application.\n   * \n   * このメソッドは新しいオプションを既存の設定とマージし、データが既にロードされている場合は\n   * 自動的な再描画をトリガーします。オプションは適用前に検証・正規化されます。\n   * \n   * @param {Object} newOptions - Configuration options to update / 更新する設定オプション\n   * @param {number} [newOptions.voxelSize] - Voxel size in meters / ボクセルサイズ（メートル）\n   * @param {number} [newOptions.opacity] - Base opacity (0-1) / 基本不透明度（0-1）\n   * @param {boolean} [newOptions.showOutline] - Whether to show voxel outlines / ボクセル輪郭の表示\n   * @param {string} [newOptions.colorMap] - Color map type ('custom', 'viridis', 'inferno') / カラーマップタイプ\n   * @param {number} [newOptions.highlightTopN] - Number of top voxels to highlight / 強調表示するトップボクセル数\n   * @param {boolean} [newOptions.adaptiveOutlines] - Enable adaptive outline control / 適応的輪郭制御を有効化\n   * @throws {Error} Throws error if options validation fails / オプション検証が失敗した場合はエラーを投げます\n   * @returns {void}\n   * \n   * @example\n   * // Update color settings / 色設定の更新\n   * heatbox.updateOptions({\n   *   colorMap: 'viridis',\n   *   opacity: 0.9,\n   *   highlightTopN: 50\n   * });\n   * \n   * @example\n   * // Enable adaptive features / 適応機能を有効化\n   * heatbox.updateOptions({\n   *   adaptiveOutlines: true,\n   *   outlineWidthPreset: 'adaptive-density'\n   * });\n   * \n   * @since v0.1.0\n   */\n  updateOptions(newOptions) {\n    this.options = validateAndNormalizeOptions({ ...this.options, ...newOptions });\n    this.renderer.options = this.options;\n    \n    // 既存のヒートマップがある場合は再描画\n    if (this._voxelData) {\n      const renderedVoxelCount = this.renderer.render(this._voxelData, this._bounds, this._grid, this._statistics);\n      // 統計情報を更新\n      this._statistics.renderedVoxels = renderedVoxelCount;\n    }\n  }\n\n  /**\n   * Initialize internal event listeners.\n   * 内部のイベントリスナーを初期化します。\n   * @private\n   */\n  _initializeEventListeners() {\n    this._eventHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n\n    // クリックイベントでInfoBoxを更新\n    this._eventHandler.setInputAction(movement => {\n      const pickedObject = this.viewer.scene.pick(movement.position);\n      if (Cesium.defined(pickedObject) && pickedObject.id && \n          pickedObject.id.properties && \n          pickedObject.id.properties.type === 'voxel') {\n        // プロパティからキー値を取得\n        const voxelKey = pickedObject.id.properties.key;\n        const voxelInfo = {\n          x: pickedObject.id.properties.x,\n          y: pickedObject.id.properties.y,\n          z: pickedObject.id.properties.z,\n          count: pickedObject.id.properties.count\n        };\n        \n        // InfoBoxに表示するためのダミーエンティティを作成\n        const dummyEntity = new Cesium.Entity({\n          id: `voxel-${voxelKey}`,\n          description: this.renderer.createVoxelDescription(voxelInfo, voxelKey)\n        });\n        this.viewer.selectedEntity = dummyEntity;\n      }\n    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n  }\n\n  /**\n   * Get statistics information.\n   * 統計情報を取得します（未作成の場合は null）。\n   * @returns {Object|null} Statistics or null / 統計情報 または null\n   */\n  getStatistics() {\n    if (!this._statistics) {\n      return null;\n    }\n\n    // 基本統計情報\n    const stats = { ...this._statistics };\n\n    // v0.1.9: 選択戦略統計を追加\n    const selectionStats = this.renderer.getSelectionStats();\n    if (selectionStats) {\n      stats.selectionStrategy = selectionStats.strategy;\n      stats.clippedNonEmpty = selectionStats.clippedNonEmpty;\n      stats.coverageRatio = selectionStats.coverageRatio ?? 0;\n    }\n\n    // v0.1.9: Auto Render Budget統計を追加\n    if (this.options._autoRenderBudget) {\n      stats.renderBudgetTier = this.options._autoRenderBudget.tier;\n      stats.autoMaxRenderVoxels = this.options._autoRenderBudget.autoMaxRenderVoxels;\n    }\n\n    // v0.1.9: occupancy ratio (rendered / budget) for diagnostics\n    if (typeof this.options.maxRenderVoxels === 'number' && this.options.maxRenderVoxels > 0) {\n      stats.occupancyRatio = Math.min(1, Math.max(0, (stats.renderedVoxels || 0) / this.options.maxRenderVoxels));\n    } else {\n      stats.occupancyRatio = null;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get bounds info if available.\n   * 境界情報を取得します（未作成の場合は null）。\n   * @returns {Object|null} Bounds or null / 境界情報 または null\n   */\n  getBounds() {\n    return this._bounds;\n  }\n\n  /**\n   * Get debug information.\n   * デバッグ情報を取得します。\n   * @returns {Object} Debug info / デバッグ情報\n   */\n  getDebugInfo() {\n    const baseInfo = {\n      options: { ...this.options },\n      bounds: this._bounds,\n      grid: this._grid,\n      statistics: this._statistics\n    };\n    \n    // v0.1.4: 自動調整情報を追加\n    if (this.options.autoVoxelSize) {\n      baseInfo.autoVoxelSizeInfo = {\n        enabled: this.options.autoVoxelSize,\n        originalSize: this._statistics?.originalVoxelSize,\n        finalSize: this._statistics?.finalVoxelSize,\n        adjusted: this._statistics?.autoAdjusted || false,\n        reason: this._statistics?.adjustmentReason,\n        dataRange: this._bounds ? calculateDataRange(this._bounds) : null,\n        estimatedDensity: this._bounds && this._statistics ? \n          this._statistics.totalEntities / (calculateDataRange(this._bounds).x * calculateDataRange(this._bounds).y * calculateDataRange(this._bounds).z) : null\n      };\n    }\n    \n    return baseInfo;\n  }\n\n  /**\n   * Automatically fit camera view to data bounds with intelligent positioning.\n   * データ境界にインテリジェントな位置決めでカメラビューを自動フィットします。\n   * \n   * This method calculates optimal camera position and orientation to view the entire\n   * heatmap data with appropriate padding and viewing angle. Uses smart algorithms to\n   * avoid extreme camera positions and ensure good visibility.\n   * \n   * このメソッドは適切なパディングと視角でヒートマップデータ全体を表示するため、\n   * 最適なカメラ位置と向きを計算します。極端なカメラ位置を避けて良好な視認性を\n   * 確保するスマートアルゴリズムを使用します。\n   * \n   * @param {Object} [bounds] - Target bounds to fit to (uses current data bounds if omitted) / フィット対象境界（省略時は現在のデータ境界を使用）\n   * @param {number} bounds.minLon - Minimum longitude in degrees / 最小経度（度）\n   * @param {number} bounds.maxLon - Maximum longitude in degrees / 最大経度（度）\n   * @param {number} bounds.minLat - Minimum latitude in degrees / 最小緯度（度）\n   * @param {number} bounds.maxLat - Maximum latitude in degrees / 最大緯度（度）\n   * @param {number} bounds.minAlt - Minimum altitude in meters / 最小高度（メートル）\n   * @param {number} bounds.maxAlt - Maximum altitude in meters / 最大高度（メートル）\n   * @param {Object} [options={}] - Camera positioning options / カメラ位置決めオプション\n   * @param {number} [options.paddingPercent=0.1] - Padding around data as percentage (0-1) / データ周辺パディング（0-1の割合）\n   * @param {number} [options.pitchDegrees=-45] - Camera pitch angle in degrees / カメラピッチ角度（度）\n   * @param {number} [options.headingDegrees=0] - Camera heading angle in degrees / カメラヘディング角度（度）\n   * @param {number} [options.duration=2.0] - Animation duration in seconds / アニメーション時間（秒）\n   * @returns {Promise<void>} Promise that resolves when camera animation completes / カメラアニメーション完了時に解決するPromise\n   * @throws {Error} Throws error if no bounds available for fitting / フィット用境界が利用できない場合はエラーを投げます\n   * \n   * @example\n   * // Fit to current data bounds / 現在のデータ境界にフィット\n   * await heatbox.fitView();\n   * \n   * @example\n   * // Custom camera angle and padding / カスタムカメラ角度とパディング  \n   * await heatbox.fitView(null, {\n   *   pitchDegrees: -60,      // 上空60度からの視点\n   *   headingDegrees: 45,     // 北東45度方向\n   *   paddingPercent: 0.2,    // データ周辺に20%マージン\n   *   duration: 3.0           // 3秒でアニメーション\n   * });\n   * \n   * @example\n   * // Typical fitViewOptions patterns / 典型的なfitViewOptionsパターン\n   * \n   * // Pattern 1: Top-down view / 真上からの視点\n   * await heatbox.fitView(bounds, {\n   *   pitchDegrees: -90,      // 真下を向く\n   *   headingDegrees: 0,      // 北向き\n   *   paddingPercent: 0.1\n   * });\n   * \n   * // Pattern 2: Diagonal overview / 斜め俯瞰\n   * await heatbox.fitView(bounds, {\n   *   pitchDegrees: -45,      // 45度斜め\n   *   headingDegrees: 135,    // 南東方向から\n   *   paddingPercent: 0.15\n   * });\n   * \n   * // Pattern 3: Close inspection / 近接観察\n   * await heatbox.fitView(bounds, {\n   *   pitchDegrees: -30,      // 浅い角度\n   *   headingDegrees: 0,\n   *   paddingPercent: 0.05,   // 狭いマージン\n   *   duration: 1.0           // 素早く移動\n   * });\n   * \n   * @example\n   * // Fit to specific bounds / 特定の境界にフィット\n   * const customBounds = {\n   *   minLon: 139.7, maxLon: 139.8,\n   *   minLat: 35.6, maxLat: 35.7,\n   *   minAlt: 0, maxAlt: 100\n   * };\n   * await heatbox.fitView(customBounds);\n   * \n   * @since v0.1.9\n   */\n  async fitView(bounds = null, options = {}) {\n    try {\n      const targetBounds = bounds || this._bounds;\n      if (!targetBounds) {\n        Logger.warn('No bounds available for fitView');\n        return;\n      }\n\n      // Merge with default fit view options\n      const fitOptions = {\n        ...this.options.fitViewOptions,\n        ...options\n      };\n\n      Logger.debug('fitView called with bounds:', targetBounds, 'options:', fitOptions);\n\n      // Map option names and delegate to ViewFitter\n      const mapped = {\n        paddingPercent: fitOptions.paddingPercent,\n        pitchDegrees: fitOptions.pitch ?? fitOptions.pitchDegrees,\n        headingDegrees: fitOptions.heading ?? fitOptions.headingDegrees,\n        duration: fitOptions.duration,\n        maximumHeight: fitOptions.maximumHeight,\n        minimumHeight: fitOptions.minimumHeight\n      };\n      return await ViewFitter.fitToBounds(this.viewer, targetBounds, mapped);\n\n    } catch (error) {\n      Logger.error('fitView failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Filter entity array (utility static method).\n   * エンティティ配列をフィルタします（ユーティリティ・静的メソッド）。\n   * @param {Cesium.Entity[]} entities - Entity array / エンティティ配列\n   * @param {Function} predicate - Predicate function / フィルタ関数\n   * @returns {Cesium.Entity[]} Filtered array / フィルタ済み配列\n   */\n  static filterEntities(entities, predicate) {\n    if (!Array.isArray(entities) || typeof predicate !== 'function') return [];\n    return entities.filter(predicate);\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__50__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","DEFAULT_OPTIONS","voxelSize","opacity","emptyOpacity","showOutline","showEmptyVoxels","minColor","maxColor","maxRenderVoxels","batchMode","debug","autoVoxelSize","colorMap","diverging","divergingPivot","highlightTopN","highlightStyle","outlineWidth","boostOpacity","voxelGap","outlineOpacity","outlineInset","outlineInsetMode","enableThickFrames","outlineRenderMode","adaptiveOutlines","outlineWidthPreset","adaptiveParams","neighborhoodRadius","densityThreshold","cameraDistanceFactor","overlapRiskFactor","renderLimitStrategy","minCoverageRatio","coverageBinsXY","autoVoxelSizeMode","autoVoxelTargetFill","renderBudgetMode","autoView","fitViewOptions","paddingPercent","pitchDegrees","headingDegrees","altitudeStrategy","PERFORMANCE_LIMITS","ERROR_MESSAGES","Math","PI","currentLogLevel","process","env","DEBUG","Logger","error","args","console","warn","info","log","setLogLevel","options","VoxelSizeEstimator","estimate","data","bounds","mode","entityCount","length","estimateByOccupancy","estimateBasic","dataRange","calculateDataRange","volume","x","y","max","z","density","estimatedSize","min","sqrt","round","targetFill","currentSize","iteration","totalVoxels","ceil","expectedOccupied","exp","currentFill","toFixed","abs","pow","finalSize","minLon","west","maxLon","east","minLat","south","maxLat","north","minAlt","minimumHeight","maxAlt","maximumHeight","centerLat","lonRangeMeters","cos","latRangeMeters","altRangeMeters","getEstimationMetadata","densityCategory","isValidEntities","entities","Array","isArray","validateAndNormalizeOptions","normalized","isNaN","Error","map","c","floor","includes","parseFloat","v","inset","Boolean","n","parseInt","Number","isFinite","f","padding","pitch","heading","DEVICE_TIER_RANGES","low","mid","high","DeviceTierDetector","detect","webglInfo","_getWebGLInfo","deviceInfo","_getDeviceInfo","tier","detectionMethod","deviceMemory","hardwareConcurrency","adjustedScore","screenPixels","maxTextureSize","webgl2","range","metadata","tierRange","message","applyAutoRenderBudget","detection","updatedOptions","_autoRenderBudget","autoMaxRenderVoxels","document","createElement","maxRenderbufferSize","canvas","getContext","gl","getParameter","MAX_TEXTURE_SIZE","MAX_RENDERBUFFER_SIZE","remove","navigator","dpr","window","devicePixelRatio","width","screen","height","nav","userAgent","CoordinateTransformer","calculateBounds","Infinity","validCount","currentTime","Cesium","now","forEach","entity","index","position","getValue","cartographic","fromCartesian","lon","toDegrees","longitude","lat","latitude","alt","centerLon","centerAlt","voxelIndexToCoordinate","grid","numVoxelsX","numVoxelsY","numVoxelsZ","coordinateToCartesian3","fromDegrees","VoxelGrid","createGrid","voxelSizeMeters","cellSizeX","cellSizeY","cellSizeZ","getVoxelKey","parseVoxelKey","split","iterateAllVoxels","callback","DataProcessor","classifyEntitiesIntoVoxels","voxelData","Map","processedCount","skippedCount","lonDen","latDen","altDen","voxelX","voxelY","voxelZ","voxelKey","has","set","count","voxelInfo","push","size","calculateStatistics","renderedVoxels","nonEmptyVoxels","emptyVoxels","totalEntities","minCount","maxCount","averageCount","autoAdjusted","originalVoxelSize","finalVoxelSize","adjustmentReason","counts","from","values","voxel","reduce","sum","stats","getTopNVoxels","topN","sortedVoxels","sort","a","b","slice","SelectionStrategyInterface","select","allVoxels","_forceInclude","Set","_options","getStrategyName","validateOptions","DensitySelectionStrategy","forceInclude","sorted","selected","included","add","selectedCount","clippedCount","strategy","forceIncludedCount","densityRange","CoverageSelectionStrategy","_addForceIncludedVoxels","_createResult","remainingVoxels","filter","binsXY","_calculateOptimalBinCount","bins","_createSpatialBins","_selectFromBins","totalBins","targetCount","calculatedBins","voxels","maxX","maxY","binKey","binKeys","keys","binIndex","maxIterations","binVoxels","_selectBestVoxelFromBin","voxelIndex","indexOf","splice","delete","keyIndex","binSelectionMode","random","additionalMetadata","totalSelected","selectionRatio","HybridSelectionStrategy","constructor","super","densityStrategy","coverageStrategy","coverageRatio","_determineCoverageRatio","remainingCount","coverageCount","densityCount","actualCoverageCount","_executeCoverageSelection","actualDensityCount","_executeDensitySelection","availableVoxels","coverageOptions","hybridCoverageMode","coverageResult","addedCount","densityOptions","selectionMode","hybridDensityMode","densityResult","totalSelectionCount","coverageSelected","densitySelected","targetCoverageRatio","COLOR_MAPS","viridis","inferno","ColorMap","interpolateColor","normalizedDensity","rawValue","_interpolateDivergingColor","_interpolateFromColorMap","minR","minG","minB","maxR","maxG","maxB","r","g","fromBytes","normalizedValue","colorMapName","scaledValue","lowerIndex","upperIndex","fraction","lowerR","lowerG","lowerB","upperR","upperG","upperB","pivot","getAvailableColorMaps","hasColorMap","VoxelEntityFactory","createBoxEntity","config","dimensions","color","wireframe","outline","properties","description","entityConfig","box","show","outlineColor","WHITE","type","material","TRANSPARENT","fill","withAlpha","createPolylineEntity","positions","polyline","arcType","NONE","createBoxEdgePolylines","centerCart","sizeX","sizeY","sizeZ","halfX","halfY","halfZ","enu","eastNorthUpToFixedFrame","toWorld","dx","dy","dz","local","multiplyByPoint","corners","i","j","edgeType","createDebugBoundingBox","widthMeters","depthMeters","heightMeters","YELLOW","createInsetOutlinePolylines","insetAmount","insetSizeX","insetSizeY","insetSizeZ","DebugRenderer","viewer","debugEntities","shouldShowBounds","debugOptions","showBounds","renderBoundingBox","boundingBoxConfig","boundingBox","center","depth","renderGridLines","showGrid","renderedLines","gridLine","CYAN","direction","MAGENTA","renderStatsOverlay","showStats","renderTime","memoryUsage","clear","isDestroyed","getEntityCount","logDebugInfo","category","AdaptiveOutlineController","calculateAdaptiveParams","isTopN","statistics","baseOptions","boxOpacity","shouldUseEmulation","neighborDensity","_calculateNeighborhoodDensity","cameraFactor","_calculateCameraDistanceFactor","overlapRisk","_calculateOverlapRisk","_calculateOutlineWidth","_calculateBoxOpacity","_calculateOutlineOpacity","_shouldUseEmulation","result","radius","totalCount","voxelCount","neighbor","camera","voxelPosition","cameraPosition","distance","_viewer","adjacentCount","neighbors","nx","ny","nz","preset","baseWidth","baseOpacity","densityComponent","neighborComponent","cameraComponent","renderMode","updateOptions","newOptions","OutlineRenderer","renderOutline","outlineOptions","adaptive","_shouldApplyInsetOutline","_renderInsetOutline","_renderEmulationOutline","_renderStandardOutline","maxInsetX","maxInsetY","maxInsetZ","effInsetX","effInsetY","effInsetZ","boxEntity","parentKey","insetSize","emulationWidth","polylineEntities","_createInsetVoxelInfo","insetValue","insetMode","insetVoxelInfo","original","offset","shouldRenderOutline","getOutlineColor","DescriptionBuilder","fontFamily","containerPadding","headerMargin","tableWidth","createVoxelDescription","createExtendedVoxelDescription","baseDescription","statsSection","percentile","rank","total","replace","createCustomVoxelDescription","customFields","customRows","field","label","value","join","VoxelGeometry","calculateVoxelCenter","altitude","calculateVoxelPosition","calculateVoxelSizes","baseCellSizeZ","calculateAdjustedHeight","baseSizeZ","heightBased","calculateVoxelDimensions","sizes","adjustedHeight","calculateBoundsCenter","calculateBoundsCenterPosition","VoxelRenderingEngine","entityFactory","renderVoxels","displayVoxels","topNVoxels","outlineRenderer","_adaptiveOutlineController","LIGHTGRAY","boxOpacityResolver","resolverCtx","resolverOpacity","e","dims","adjustedAlt","outlineWidthResolver","resolverWidth","wireframeOnly","id","voxelInfoWithPosition","processDisplayVoxels","selectVoxelsForRendering","maxVoxels","entries","selectionResult","selectedVoxels","clippedNonEmpty","VoxelEntityManager","voxelEntities","addEntity","setVisible","createInsetOutline","baseSizeX","baseSizeY","actualInset","insetX","insetY","insetZ","finalInsetX","finalInsetY","finalInsetZ","insetDimensions","insetEntity","createThickOutlineFrames","outerX","outerY","outerZ","innerX","innerY","innerZ","frameColor","frameEntities","frameThickness","frame","frameEntity","shouldApplyInsetOutline","getEntityStats","activeEntities","VoxelRenderer","outlineOpacityResolver","_initializeSelectionStrategies","debugRenderer","adaptiveOutlineController","descriptionBuilder","renderingEngine","entityManager","_selectionStrategies","coverage","hybrid","_calculateAdaptiveParams","render","voxelDataSize","_selectVoxelsForRendering","bind","_selectionStats","_shouldShowBounds","voxelSelectionStrategy","hybridResult","getSelectionStats","ViewFitter","fitToBounds","_isValidBounds","Promise","resolve","fitOptions","duration","_calculateDataRange","maxRange","_handleMinimalDataRange","_handleLargeDataRange","_executeStandardFit","cosLat","fixedHeight","_executeCameraMovement","destination","orientation","toRadians","roll","rectangle","cameraOptions","reject","flyTo","complete","cancel","paddingMeters","cameraHeight","_calculateOptimalCameraHeight","fovRadians","pitchRadians","tan","flyToOptions","createRectangleFromBounds","calculateCameraPosition","viewOptions","scene","isValidViewer","mergedOptions","renderer","viewFitter","_bounds","_grid","_voxelData","_statistics","_eventHandler","_initializeEventListeners","setData","autoAdjustmentInfo","sizeOptions","tempGrid","validation","valid","warning","recommendedSize","validateVoxelCount","enabled","originalSize","adjusted","reason","renderedVoxelCount","fitView","createFromEntities","getStatistics","destroy","dispose","getOptions","setInputAction","movement","pickedObject","pick","dummyEntity","selectedEntity","LEFT_CLICK","selectionStats","selectionStrategy","renderBudgetTier","occupancyRatio","getBounds","getDebugInfo","baseInfo","autoVoxelSizeInfo","estimatedDensity","targetBounds","mapped","filterEntities","predicate"],"sourceRoot":""}