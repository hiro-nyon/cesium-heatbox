{"version":3,"file":"cesium-heatbox.umd.min.js","mappings":"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","sources":["webpack://CesiumHeatbox/webpack/universalModuleDefinition","webpack://CesiumHeatbox/external umd {\"commonjs\":\"cesium\",\"commonjs2\":\"cesium\",\"amd\":\"cesium\",\"root\":\"Cesium\"}","webpack://CesiumHeatbox/webpack/bootstrap","webpack://CesiumHeatbox/webpack/runtime/define property getters","webpack://CesiumHeatbox/webpack/runtime/hasOwnProperty shorthand","webpack://CesiumHeatbox/./src/utils/constants.js","webpack://CesiumHeatbox/./src/utils/logger.js","webpack://CesiumHeatbox/./src/utils/voxelSizeEstimator.js","webpack://CesiumHeatbox/./src/utils/validation.js","webpack://CesiumHeatbox/./src/utils/deviceTierDetector.js","webpack://CesiumHeatbox/./src/core/CoordinateTransformer.js","webpack://CesiumHeatbox/./src/core/VoxelGrid.js","webpack://CesiumHeatbox/./src/core/DataProcessor.js","webpack://CesiumHeatbox/./src/core/selection/SelectionStrategyInterface.js","webpack://CesiumHeatbox/./src/core/selection/DensitySelectionStrategy.js","webpack://CesiumHeatbox/./src/core/selection/CoverageSelectionStrategy.js","webpack://CesiumHeatbox/./src/core/selection/HybridSelectionStrategy.js","webpack://CesiumHeatbox/./src/core/color/ColorMap.js","webpack://CesiumHeatbox/./src/core/voxel/VoxelEntityFactory.js","webpack://CesiumHeatbox/./src/core/voxel/DebugRenderer.js","webpack://CesiumHeatbox/./src/core/outline/AdaptiveOutlineController.js","webpack://CesiumHeatbox/./src/core/outline/OutlineRenderer.js","webpack://CesiumHeatbox/./src/core/voxel/DescriptionBuilder.js","webpack://CesiumHeatbox/./src/core/voxel/VoxelGeometry.js","webpack://CesiumHeatbox/./src/core/voxel/VoxelRenderingEngine.js","webpack://CesiumHeatbox/./src/core/voxel/VoxelEntityManager.js","webpack://CesiumHeatbox/./src/core/VoxelRenderer.js","webpack://CesiumHeatbox/./src/utils/ViewFitter.js","webpack://CesiumHeatbox/./src/index.js","webpack://CesiumHeatbox/./src/Heatbox.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"cesium\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"cesium\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CesiumHeatbox\"] = factory(require(\"cesium\"));\n\telse\n\t\troot[\"CesiumHeatbox\"] = factory(root[\"Cesium\"]);\n})(this, (__WEBPACK_EXTERNAL_MODULE__50__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__50__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * Constant definitions for CesiumJS Heatbox library.\n * CesiumJS Heatbox \n */\n\n/**\n * Default option values.\n * \n */\nexport const DEFAULT_OPTIONS = {\n  voxelSize: 20,\n  opacity: 0.8,\n  emptyOpacity: 0.03,\n  showOutline: true,\n  showEmptyVoxels: false,\n  minColor: [0, 32, 255],\n  maxColor: [255, 64, 0],\n  maxRenderVoxels: 50000,\n  batchMode: 'auto',\n  debug: false, // false true \n  autoVoxelSize: false, // v0.1.4: false\n  // v0.1.5: \n  colorMap: 'custom', // 'custom', 'viridis', 'inferno'\n  diverging: false, // \n  divergingPivot: 0, // \n  highlightTopN: null, // Nnull: \n  highlightStyle: {\n    outlineWidth: 4,\n    boostOpacity: 0.2\n  },\n  // v0.1.6: \n  voxelGap: 0, // \n  outlineOpacity: 1.0, // 0-1\n  // v0.1.6.1: ADR-0004\n  outlineInset: 0, // 0\n  outlineInsetMode: 'all', // 'all' | 'topn'TopN\n  enableThickFrames: false, // \n  \n  // v0.1.7: ADR-0005\n  outlineRenderMode: 'standard', // 'standard' | 'inset' | 'emulation-only' \n  adaptiveOutlines: false, // \n  outlineWidthPreset: 'uniform', // 'adaptive-density' | 'topn-focus' | 'uniform' \n  \n  \n  // v0.1.7: \n  adaptiveParams: {\n    neighborhoodRadius: 50, // \n    densityThreshold: 5, // /\n    cameraDistanceFactor: 1.0, // \n    overlapRiskFactor: 0.3 // \n  },\n  \n  // v0.1.9: ADR-0006 Phase 1\n  renderLimitStrategy: 'density', // 'density' | 'coverage' | 'hybrid' \n  minCoverageRatio: 0.2, // hybrid0-1\n  coverageBinsXY: 'auto', // 'auto' | number\n  \n  // \n  autoVoxelSizeMode: 'basic', // 'basic' | 'occupancy' \n  autoVoxelTargetFill: 0.6, // 0-1, occupancy\n  \n  // Auto Render Budget\n  renderBudgetMode: 'manual', // 'manual' | 'auto' \n  \n  // \n  autoView: false, // \n  fitViewOptions: {\n    paddingPercent: 0.1, // 10%\n    pitchDegrees: -30, // \n    headingDegrees: 0, // \n    altitudeStrategy: 'auto' // 'auto' | 'manual' \n  }\n};\n\n/**\n * Performance limits.\n * \n */\nexport const PERFORMANCE_LIMITS = {\n  maxEntities: 5000,\n  maxVoxels: 50000,\n  maxEmptyVoxelsRendered: 10000,\n  minVoxelSize: 5,\n  maxVoxelSize: 1000,\n  warningThreshold: 30000\n};\n\n/**\n * Coordinate-related constants.\n * \n */\nexport const COORDINATE_CONSTANTS = {\n  EARTH_RADIUS: 6378137,\n  DEGREES_TO_METERS_LAT: 111000,\n  DEGREES_TO_RADIANS: Math.PI / 180\n};\n\n/**\n * Error message strings.\n * \n */\nexport const ERROR_MESSAGES = {\n  NO_ENTITIES: '',\n  NO_VIEWER: 'CesiumJS Viewer',\n  INVALID_VIEWER: 'CesiumJS Viewer',\n  VOXEL_LIMIT_EXCEEDED: '',\n  MEMORY_WARNING: '',\n  WEBGL_NOT_SUPPORTED: 'WebGL',\n  INVALID_VOXEL_SIZE: ''\n};\n\n/**\n * Default statistics values.\n * \n */\nexport const DEFAULT_STATISTICS = {\n  totalVoxels: 0,\n  renderedVoxels: 0,\n  nonEmptyVoxels: 0,\n  emptyVoxels: 0,\n  totalEntities: 0,\n  minCount: 0,\n  maxCount: 0,\n  averageCount: 0\n};\n\n/**\n * Color-related constants.\n * \n */\nexport const COLOR_CONSTANTS = {\n  MIN_HUE: 240, // \n  MAX_HUE: 0,   // \n  SATURATION: 0.8,\n  BRIGHTNESS: 0.7,\n  SATURATION_RANGE: 0.2,\n  BRIGHTNESS_RANGE: 0.3\n};\n","/**\n * Comprehensive logging utility with configurable levels and environment-aware output.\n * \n * \n * This logging system provides intelligent log level management based on environment\n * variables (NODE_ENV, DEBUG) and runtime configuration. Supports multiple log levels\n * (ERROR, WARN, INFO, DEBUG) with automatic filtering based on production vs development\n * environments. Essential for debugging and monitoring heatbox operations.\n * \n * NODE_ENVDEBUG\n * \n * ERRORWARNINFODEBUGvs\n * \n * \n * @namespace Logger\n * @since v0.1.0\n * @version 1.2.0 - Enhanced environment detection and configuration support\n */\n\n/**\n * Log level constants.\n * \n */\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3\n};\n\n/**\n * Determine current log level.\n * \n * NODE_ENV=production  ERROR  WARN DEBUG=true  NODE_ENV=development \n */\nfunction getLogLevel() {\n  // DEBUG=true\n  if (typeof process !== 'undefined' && process.env && process.env.DEBUG === 'true') {\n    return LOG_LEVELS.DEBUG;\n  }\n  \n  // NODE_ENV\n  if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'production') {\n    return LOG_LEVELS.WARN;\n  }\n  \n  // \n  return LOG_LEVELS.DEBUG;\n}\n\nlet currentLogLevel = getLogLevel();\n\n/**\n * Common logging utility.\n * \n */\nexport const Logger = {\n  /**\n   * Error log (always output).\n   * \n   * @param {...any} args - Log arguments / \n   */\n  error(...args) {\n    if (currentLogLevel >= LOG_LEVELS.ERROR) {\n      console.error('[Heatbox ERROR]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * Warning log.\n   * \n   * @param {...any} args - Log arguments / \n   */\n  warn(...args) {\n    if (currentLogLevel >= LOG_LEVELS.WARN) {\n      console.warn('[Heatbox WARN]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * Info log.\n   * \n   * @param {...any} args - Log arguments / \n   */\n  info(...args) {\n    if (currentLogLevel >= LOG_LEVELS.INFO) {\n      console.log('[Heatbox INFO]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * Debug log.\n   * \n   * @param {...any} args - Log arguments / \n   */\n  debug(...args) {\n    if (currentLogLevel >= LOG_LEVELS.DEBUG) {\n      console.log('[Heatbox DEBUG]', ...args); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * Control log level by options.\n   * \n   * v0.1.5: debug \n   * @param {Object} options - Options / \n   */\n  setLogLevel(options) {\n    if (options && options.debug !== undefined) {\n      if (typeof options.debug === 'boolean') {\n        // debug: true  debug: false  \n        currentLogLevel = options.debug ? LOG_LEVELS.DEBUG : LOG_LEVELS.WARN;\n      } else if (typeof options.debug === 'object' && options.debug !== null) {\n        // DEBUG\n        currentLogLevel = LOG_LEVELS.DEBUG;\n      }\n    }\n    return currentLogLevel;\n  }\n};\n\n/**\n * Wrapper functions for backward compatibility.\n *  console.log \n */\nexport const log = Logger.debug;\nexport const warn = Logger.warn;\nexport const error = Logger.error;\nexport const info = Logger.info;\n","/**\n * Voxel Size Estimator for automatic voxel size calculation.\n * \n */\n\nimport { Logger } from './logger.js';\nimport { PERFORMANCE_LIMITS } from './constants.js';\n\n/**\n * Voxel Size Estimator class for calculating optimal voxel sizes\n * \n */\nexport class VoxelSizeEstimator {\n  /**\n   * Estimate optimal voxel size\n   * \n   * @param {Array} data - Data points / \n   * @param {Object} bounds - Data bounds / \n   * @param {string} mode - Estimation mode: 'basic' | 'occupancy' / \n   * @param {Object} options - Estimation options / \n   * @returns {number} Estimated voxel size in meters / \n   */\n  static estimate(data, bounds, mode = 'basic', options = {}) {\n    try {\n      // Support backward compatibility with entityCount in options\n      const entityCount = options.entityCount !== undefined ? options.entityCount : (data ? data.length : 0);\n      \n      if (mode === 'occupancy') {\n        return VoxelSizeEstimator.estimateByOccupancy(bounds, entityCount, options);\n      } else {\n        return VoxelSizeEstimator.estimateBasic(bounds, entityCount);\n      }\n    } catch (error) {\n      Logger.warn('Voxel size estimation failed:', error);\n      return 20; // \n    }\n  }\n\n  /**\n   * Basic voxel size estimation (existing algorithm)\n   * \n   * @param {Object} bounds - Bounds info / \n   * @param {number} entityCount - Number of entities / \n   * @returns {number} Estimated voxel size in meters / \n   */\n  static estimateBasic(bounds, entityCount) {\n    // 1. X/Y/Z\n    const dataRange = VoxelSizeEstimator.calculateDataRange(bounds);\n    \n    // 2. \n    const volume = dataRange.x * dataRange.y * Math.max(dataRange.z, 10); // 10m\n    const density = entityCount / volume; // /\n    \n    // 3. \n    // - : 10-20m\n    // - : 20-50m\n    // - : 50-100m\n    let estimatedSize;\n    \n    if (density > 0.001) {\n      // \n      estimatedSize = Math.max(10, Math.min(20, 20 / Math.sqrt(density * 1000)));\n    } else if (density > 0.0001) {\n      // \n      estimatedSize = Math.max(20, Math.min(50, 50 / Math.sqrt(density * 10000)));\n    } else {\n      // \n      estimatedSize = Math.max(50, Math.min(100, 100 / Math.sqrt(density * 100000)));\n    }\n    \n    // \n    estimatedSize = Math.max(PERFORMANCE_LIMITS.minVoxelSize, \n                            Math.min(PERFORMANCE_LIMITS.maxVoxelSize, estimatedSize));\n    \n    Logger.debug(`Basic voxel size estimated: ${estimatedSize}m (density: ${density}, volume: ${volume})`);\n    return Math.round(estimatedSize);\n  }\n\n  /**\n   * Occupancy-based voxel size estimation with iterative approximation\n   * \n   * @param {Object} bounds - Bounds info / \n   * @param {number} entityCount - Number of entities / \n   * @param {Object} options - Calculation options / \n   * @returns {number} Estimated voxel size in meters / \n   */\n  static estimateByOccupancy(bounds, entityCount, options) {\n    const dataRange = VoxelSizeEstimator.calculateDataRange(bounds);\n    const maxRenderVoxels = options.maxRenderVoxels || 50000;\n    const targetFill = options.autoVoxelTargetFill || 0.6;\n    const maxIterations = 10;\n    const tolerance = 0.05; // 5%\n    \n    // \n    let currentSize = VoxelSizeEstimator.estimateBasic(bounds, entityCount);\n    \n    Logger.debug(`Starting occupancy-based estimation: N=${entityCount}, target=${targetFill}, maxVoxels=${maxRenderVoxels}`);\n    \n    for (let iteration = 0; iteration < maxIterations; iteration++) {\n      // \n      const numVoxelsX = Math.ceil(dataRange.x / currentSize);\n      const numVoxelsY = Math.ceil(dataRange.y / currentSize);\n      const numVoxelsZ = Math.ceil(dataRange.z / currentSize);\n      const totalVoxels = numVoxelsX * numVoxelsY * numVoxelsZ;\n      \n      // : E[occupied]  M  (1 - exp(-N/M))\n      const expectedOccupied = totalVoxels * (1 - Math.exp(-entityCount / totalVoxels));\n      \n      // \n      const currentFill = Math.min(expectedOccupied / maxRenderVoxels, 1.0);\n      \n      Logger.debug(`Iteration ${iteration}: size=${currentSize.toFixed(1)}m, totalVoxels=${totalVoxels}, expectedOccupied=${expectedOccupied.toFixed(0)}, fill=${currentFill.toFixed(3)}`);\n      \n      // \n      const fillError = Math.abs(currentFill - targetFill);\n      if (fillError < tolerance) {\n        Logger.debug(`Converged at iteration ${iteration}: size=${currentSize.toFixed(1)}m, fill=${currentFill.toFixed(3)}`);\n        break;\n      }\n      \n      // Newton\n      if (currentFill > targetFill) {\n        //   \n        currentSize *= Math.pow(currentFill / targetFill, 0.3);\n      } else {\n        //   \n        currentSize *= Math.pow(currentFill / targetFill, 0.3);\n      }\n      \n      // \n      currentSize = Math.max(PERFORMANCE_LIMITS.minVoxelSize, \n                            Math.min(PERFORMANCE_LIMITS.maxVoxelSize, currentSize));\n    }\n    \n    const finalSize = Math.round(currentSize);\n    Logger.info(`Occupancy-based voxel size: ${finalSize}m (target fill: ${targetFill})`);\n    \n    return finalSize;\n  }\n\n  /**\n   * Calculate data range from bounds\n   * \n   * @param {Object} bounds - Bounds info / \n   * @returns {Object} Data range {x, y, z} in meters / \n   */\n  static calculateDataRange(bounds) {\n    const minLon = bounds.west * 180 / Math.PI; // \n    const maxLon = bounds.east * 180 / Math.PI;\n    const minLat = bounds.south * 180 / Math.PI;\n    const maxLat = bounds.north * 180 / Math.PI;\n    const minAlt = bounds.minimumHeight || 0;\n    const maxAlt = bounds.maximumHeight || 100;\n    \n    // \n    // 1  111,000m\n    const centerLat = (minLat + maxLat) / 2;\n    const lonRangeMeters = (maxLon - minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);\n    const latRangeMeters = (maxLat - minLat) * 111000;\n    const altRangeMeters = Math.abs(maxAlt - minAlt);\n    \n    return {\n      x: Math.abs(lonRangeMeters),\n      y: Math.abs(latRangeMeters),\n      z: Math.abs(altRangeMeters)\n    };\n  }\n\n  /**\n   * Get estimation metadata\n   * \n   * @param {Object} bounds - Bounds info / \n   * @param {number} entityCount - Number of entities / \n   * @param {string} mode - Estimation mode / \n   * @returns {Object} Estimation metadata / \n   */\n  static getEstimationMetadata(bounds, entityCount, mode) {\n    const dataRange = VoxelSizeEstimator.calculateDataRange(bounds);\n    const volume = dataRange.x * dataRange.y * Math.max(dataRange.z, 10);\n    const density = entityCount / volume;\n    \n    return {\n      mode,\n      entityCount,\n      dataRange,\n      volume,\n      density,\n      densityCategory: density > 0.001 ? 'high' : density > 0.0001 ? 'medium' : 'low'\n    };\n  }\n}\n","/**\n * Validation utility functions.\n * \n */\n\nimport * as Cesium from 'cesium';\nimport { PERFORMANCE_LIMITS, ERROR_MESSAGES } from './constants.js';\nimport { Logger } from './logger.js';\nimport { VoxelSizeEstimator } from './voxelSizeEstimator.js';\n\n/**\n * Check whether a CesiumJS Viewer is valid.\n * CesiumJS Viewer\n * @param {Object} viewer - CesiumJS Viewer\n * @returns {boolean} true if valid /  true\n */\nexport function isValidViewer(viewer) {\n  if (!viewer) {\n    return false;\n  }\n  \n  // \n  if (!viewer.scene || !viewer.entities || !viewer.scene.canvas) {\n    return false;\n  }\n  \n  // WebGLWebGL2 \n  const canvas = viewer.scene.canvas;\n  const gl = canvas.getContext('webgl2') || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  if (!gl) {\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Check whether the entity array is valid.\n * \n * @param {Array} entities - Entity array / \n * @returns {boolean} true if valid /  true\n */\nexport function isValidEntities(entities) {\n  if (!Array.isArray(entities)) {\n    return false;\n  }\n  \n  if (entities.length === 0) {\n    return false;\n  }\n  \n  if (entities.length > PERFORMANCE_LIMITS.maxEntities) {\n    Logger.warn(`(${PERFORMANCE_LIMITS.maxEntities}): ${entities.length}`);\n  }\n  \n  return true;\n}\n\n/**\n * Check whether the voxel size is valid.\n * \n * @param {number} voxelSize - Voxel size / \n * @returns {boolean} true if valid /  true\n */\nexport function isValidVoxelSize(voxelSize) {\n  if (typeof voxelSize !== 'number' || isNaN(voxelSize)) {\n    return false;\n  }\n  \n  if (voxelSize < PERFORMANCE_LIMITS.minVoxelSize || voxelSize > PERFORMANCE_LIMITS.maxVoxelSize) {\n    return false;\n  }\n  \n  return true;\n}\n\n/**\n * Check whether an entity has a valid position.\n * \n * @param {Object} entity - Cesium Entity\n * @returns {boolean} true if valid /  true\n */\nexport function hasValidPosition(entity) {\n  if (!entity || !entity.position) {\n    return false;\n  }\n  \n  // Property\n  if (typeof entity.position.getValue === 'function') {\n    const position = entity.position.getValue(Cesium.JulianDate.now());\n    return position && !isNaN(position.x) && !isNaN(position.y) && !isNaN(position.z);\n  }\n  \n  // Cartesian3\n  if (entity.position.x !== undefined) {\n    return !isNaN(entity.position.x) && !isNaN(entity.position.y) && !isNaN(entity.position.z);\n  }\n  \n  return false;\n}\n\n/**\n * Validate that total voxel count is within limits.\n * \n * @param {number} totalVoxels - Total voxels / \n * @param {number} voxelSize - Voxel size / \n * @returns {Object} Validation result / \n */\nexport function validateVoxelCount(totalVoxels, voxelSize) {\n  const result = {\n    valid: true,\n    warning: false,\n    error: null,\n    recommendedSize: null\n  };\n  \n  if (totalVoxels > PERFORMANCE_LIMITS.maxVoxels) {\n    result.valid = false;\n    result.error = ERROR_MESSAGES.VOXEL_LIMIT_EXCEEDED;\n    result.recommendedSize = Math.ceil(voxelSize * Math.pow(totalVoxels / PERFORMANCE_LIMITS.maxVoxels, 1/3));\n  } else if (totalVoxels > PERFORMANCE_LIMITS.warningThreshold) {\n    result.warning = true;\n    result.error = ERROR_MESSAGES.MEMORY_WARNING;\n  }\n  \n  return result;\n}\n\n/**\n * Validate and normalize options.\n * \n * v0.1.5: batchMode \n * @param {Object} options - User-specified options / \n * @returns {Object} Normalized options / \n */\nexport function validateAndNormalizeOptions(options = {}) {\n  const normalized = { ...options };\n  \n  // v0.1.5: batchModedebug\n  if (normalized.batchMode && normalized.debug) {\n    Logger.warn('batchMode option is deprecated and will be removed in v1.0.0. It is currently ignored.');\n  }\n  \n  // \n  if (normalized.voxelSize !== undefined && !isValidVoxelSize(normalized.voxelSize)) {\n    throw new Error(`${ERROR_MESSAGES.INVALID_VOXEL_SIZE}: ${normalized.voxelSize}`);\n  }\n  \n  // \n  if (normalized.opacity !== undefined) {\n    normalized.opacity = Math.max(0, Math.min(1, normalized.opacity));\n  }\n  \n  if (normalized.emptyOpacity !== undefined) {\n    normalized.emptyOpacity = Math.max(0, Math.min(1, normalized.emptyOpacity));\n  }\n  \n  // \n  if (normalized.minColor && Array.isArray(normalized.minColor) && normalized.minColor.length === 3) {\n    normalized.minColor = normalized.minColor.map(c => Math.max(0, Math.min(255, Math.floor(c))));\n  }\n  \n  if (normalized.maxColor && Array.isArray(normalized.maxColor) && normalized.maxColor.length === 3) {\n    normalized.maxColor = normalized.maxColor.map(c => Math.max(0, Math.min(255, Math.floor(c))));\n  }\n  \n  // v0.1.5: \n  if (normalized.colorMap !== undefined) {\n    const validColorMaps = ['custom', 'viridis', 'inferno'];\n    if (!validColorMaps.includes(normalized.colorMap)) {\n      Logger.warn(`Invalid colorMap: ${normalized.colorMap}. Using 'custom'.`);\n      normalized.colorMap = 'custom';\n    }\n  }\n  \n  if (normalized.highlightTopN !== undefined && normalized.highlightTopN !== null) {\n    if (typeof normalized.highlightTopN !== 'number' || normalized.highlightTopN <= 0) {\n      Logger.warn(`Invalid highlightTopN: ${normalized.highlightTopN}. Must be a positive number.`);\n      normalized.highlightTopN = null;\n    }\n  }\n  \n  // v0.1.6: \n  if (normalized.voxelGap !== undefined) {\n    normalized.voxelGap = Math.max(0, Math.min(100, parseFloat(normalized.voxelGap) || 0));\n  }\n  \n  if (normalized.outlineOpacity !== undefined) {\n    normalized.outlineOpacity = Math.max(0, Math.min(1, parseFloat(normalized.outlineOpacity) || 1));\n  }\n  \n\n  // v0.1.6.1 (ADR-0004): \n  if (normalized.outlineInset !== undefined) {\n    const v = parseFloat(normalized.outlineInset);\n    normalized.outlineInset = isNaN(v) || v < 0 ? 0 : v;\n  }\n  if (normalized.outlineInsetMode !== undefined) {\n    const validModes = ['all', 'topn'];\n    if (!validModes.includes(normalized.outlineInsetMode)) {\n      Logger.warn(`Invalid outlineInsetMode: ${normalized.outlineInsetMode}. Using 'all'.`);\n      normalized.outlineInsetMode = 'all';\n    }\n  }\n\n  // v0.1.6.1: ADR-0004\n  if (normalized.outlineInset !== undefined) {\n    // 0100m\n    const inset = parseFloat(normalized.outlineInset);\n    normalized.outlineInset = Math.max(0, Math.min(100, isNaN(inset) ? 0 : inset));\n  }\n  \n  if (normalized.outlineInsetMode !== undefined) {\n    const validInsetModes = ['all', 'topn'];\n    if (!validInsetModes.includes(normalized.outlineInsetMode)) {\n      Logger.warn(`Invalid outlineInsetMode: ${normalized.outlineInsetMode}. Using 'all'.`);\n      normalized.outlineInsetMode = 'all';\n    }\n  }\n  \n  // \n  if (normalized.enableThickFrames !== undefined) {\n    normalized.enableThickFrames = Boolean(normalized.enableThickFrames);\n  }\n  \n  // v0.1.9: \n  if (normalized.renderLimitStrategy !== undefined) {\n    const validStrategies = ['density', 'coverage', 'hybrid'];\n    if (!validStrategies.includes(normalized.renderLimitStrategy)) {\n      Logger.warn(`Invalid renderLimitStrategy: ${normalized.renderLimitStrategy}. Using 'density'.`);\n      normalized.renderLimitStrategy = 'density';\n    }\n  }\n  if (normalized.minCoverageRatio !== undefined) {\n    const v = parseFloat(normalized.minCoverageRatio);\n    normalized.minCoverageRatio = isNaN(v) ? 0.2 : Math.max(0, Math.min(1, v));\n  }\n  if (normalized.coverageBinsXY !== undefined) {\n    const v = normalized.coverageBinsXY;\n    if (v !== 'auto') {\n      const n = parseInt(v, 10);\n      if (!Number.isFinite(n) || n <= 0) {\n        Logger.warn(`Invalid coverageBinsXY: ${v}. Using 'auto'.`);\n        normalized.coverageBinsXY = 'auto';\n      } else {\n        normalized.coverageBinsXY = n;\n      }\n    }\n  }\n  \n  // v0.1.9: \n  if (normalized.autoVoxelSizeMode !== undefined) {\n    const validModes = ['basic', 'occupancy'];\n    if (!validModes.includes(normalized.autoVoxelSizeMode)) {\n      Logger.warn(`Invalid autoVoxelSizeMode: ${normalized.autoVoxelSizeMode}. Using 'basic'.`);\n      normalized.autoVoxelSizeMode = 'basic';\n    }\n  }\n  if (normalized.autoVoxelTargetFill !== undefined) {\n    const v = parseFloat(normalized.autoVoxelTargetFill);\n    normalized.autoVoxelTargetFill = isNaN(v) ? 0.6 : Math.max(0, Math.min(1, v));\n  }\n  \n  // v0.1.9: Auto Render Budget\n  if (normalized.renderBudgetMode !== undefined) {\n    const validModes = ['manual', 'auto'];\n    if (!validModes.includes(normalized.renderBudgetMode)) {\n      Logger.warn(`Invalid renderBudgetMode: ${normalized.renderBudgetMode}. Using 'manual'.`);\n      normalized.renderBudgetMode = 'manual';\n    }\n  }\n  \n  // v0.1.10: fitViewOptions API (ADR-0008 Phase 4)\n  if (normalized.fitViewOptions !== undefined) {\n    const f = normalized.fitViewOptions || {};\n    const padding = parseFloat(f.paddingPercent);\n    // : pitch/heading  pitchDegrees/headingDegrees\n    const pitch = parseFloat(f.pitchDegrees ?? f.pitch);\n    const heading = parseFloat(f.headingDegrees ?? f.heading);\n    const altitudeStrategy = f.altitudeStrategy;\n    \n    // API\n    if (f.pitch !== undefined || f.heading !== undefined) {\n      Logger.warn('fitViewOptions.pitch/heading pitchDegrees/headingDegrees');\n    }\n    \n    normalized.fitViewOptions = {\n      paddingPercent: Number.isFinite(padding) ? Math.max(0, Math.min(1, padding)) : 0.1,\n      pitchDegrees: Number.isFinite(pitch) ? Math.max(-90, Math.min(0, pitch)) : -30,\n      headingDegrees: Number.isFinite(heading) ? heading : 0,\n      altitudeStrategy: altitudeStrategy === 'manual' ? 'manual' : 'auto'\n    };\n  }\n  \n  return normalized;\n}\n\n/**\n * Estimate initial voxel size based on data bounds and entity count.\n * \n * @param {Object} bounds - Bounds info / \n * @param {number} entityCount - Number of entities / \n * @param {Object} options - Calculation options / \n * @returns {number} Estimated voxel size in meters / \n * @deprecated Use VoxelSizeEstimator.estimate() instead\n */\nexport function estimateInitialVoxelSize(bounds, entityCount, options = {}) {\n  const mode = options.autoVoxelSizeMode || 'basic';\n  return VoxelSizeEstimator.estimate(null, bounds, mode, { ...options, entityCount });\n}\n\n/**\n * Calculate data range from bounds\n * \n * @param {Object} bounds - Bounds info / \n * @returns {Object} Data range {x, y, z} in meters / \n * @deprecated Use VoxelSizeEstimator.calculateDataRange() instead\n */\nexport function calculateDataRange(bounds) {\n  return VoxelSizeEstimator.calculateDataRange(bounds);\n}\n\n// Note: Occupancy-based voxel size estimation was moved to VoxelSizeEstimator.\n// This module intentionally avoids duplicating estimation logic.\n","/**\n * Device tier detection for Auto Render Budget.\n * Auto Render Budget\n */\n\nimport { Logger } from './logger.js';\nimport { PERFORMANCE_LIMITS } from './constants.js';\n\n/**\n * Device tier constants\n * \n */\nconst DEVICE_TIER_RANGES = {\n  low: { min: 8000, max: 12000 },\n  mid: { min: 20000, max: 35000 },\n  high: { min: 40000, max: 50000 }\n};\n\n/**\n * Device Tier Detector class for performance tier detection\n * \n */\nexport class DeviceTierDetector {\n  /**\n   * Detect device performance tier\n   * \n   * @returns {Object} { tier: string, maxRenderVoxels: number, metadata: Object }\n   */\n  static detect() {\n    try {\n      const webglInfo = DeviceTierDetector._getWebGLInfo();\n      const deviceInfo = DeviceTierDetector._getDeviceInfo();\n      \n      // \n      let tier = 'mid'; // \n      let detectionMethod = 'fallback';\n      \n      // Primary: deviceMemoryChrome\n      if (deviceInfo.deviceMemory !== null) {\n        if (deviceInfo.deviceMemory <= 4) {\n          tier = 'low';\n        } else if (deviceInfo.deviceMemory <= 8) {\n          tier = 'mid';\n        } else {\n          tier = 'high';\n        }\n        detectionMethod = 'deviceMemory';\n      } \n      // Fallback: hardwareConcurrency + \n      else if (deviceInfo.hardwareConcurrency !== null) {\n        const baseScore = deviceInfo.hardwareConcurrency;\n        const resolutionFactor = Math.min(deviceInfo.screenPixels / 2073600, 2.0); // 1920x1080 = 2073600\n        const adjustedScore = baseScore * resolutionFactor;\n        \n        if (adjustedScore <= 4) {\n          tier = 'low';\n        } else if (adjustedScore <= 8) {\n          tier = 'mid';\n        } else {\n          tier = 'high';\n        }\n        detectionMethod = 'hardwareConcurrency+resolution';\n      }\n      \n      // WebGL\n      // \n      if (\n        detectionMethod !== 'fallback' &&\n        webglInfo.maxTextureSize > 0 &&\n        (webglInfo.maxTextureSize < 4096 || !webglInfo.webgl2)\n      ) {\n        tier = tier === 'high' ? 'mid' : 'low';\n        detectionMethod += '+webglLimits';\n      }\n      \n      // \n      const range = DEVICE_TIER_RANGES[tier];\n      const maxRenderVoxels = Math.min(\n        Math.floor((range.min + range.max) / 2),\n        PERFORMANCE_LIMITS.maxVoxels\n      );\n      \n      Logger.debug(`Device tier detected: ${tier} (${detectionMethod}), maxRenderVoxels: ${maxRenderVoxels}`);\n      \n      return {\n        tier,\n        maxRenderVoxels,\n        metadata: {\n          detectionMethod,\n          deviceInfo,\n          webglInfo,\n          tierRange: range\n        }\n      };\n      \n    } catch (error) {\n      Logger.warn('Device tier detection failed, using default mid tier:', error);\n      return {\n        tier: 'mid',\n        maxRenderVoxels: Math.min(25000, PERFORMANCE_LIMITS.maxVoxels),\n        metadata: {\n          detectionMethod: 'error-fallback',\n          deviceInfo: null,\n          webglInfo: null,\n          error: error.message\n        }\n      };\n    }\n  }\n\n  /**\n   * Apply auto render budget to options\n   * Auto Render Budget\n   * @param {Object} options - \n   * @returns {Object} \n   */\n  static applyAutoRenderBudget(options) {\n    if (options.renderBudgetMode !== 'auto' && options.maxRenderVoxels !== 'auto') {\n      return options; // \n    }\n    \n    const detection = DeviceTierDetector.detect();\n    \n    const updatedOptions = {\n      ...options,\n      maxRenderVoxels: detection.maxRenderVoxels,\n      // \n      _autoRenderBudget: {\n        tier: detection.tier,\n        detectionMethod: detection.metadata.detectionMethod,\n        autoMaxRenderVoxels: detection.maxRenderVoxels\n      }\n    };\n    \n    Logger.info(`Auto Render Budget applied: ${detection.tier} tier, maxRenderVoxels: ${detection.maxRenderVoxels}`);\n    \n    return updatedOptions;\n  }\n\n  /**\n   * Get WebGL capability information\n   * WebGL\n   * @returns {Object} WebGL\n   * @private\n   */\n  static _getWebGLInfo() {\n    try {\n      // Avoid triggering jsdom's unimplemented getContext error by probing first\n      if (typeof document === 'undefined' || typeof document.createElement !== 'function') {\n        return {\n          webgl2: false,\n          maxTextureSize: 0,\n          maxRenderbufferSize: 0\n        };\n      }\n\n      const canvas = document.createElement('canvas');\n      const canGetContext = canvas && typeof canvas.getContext === 'function';\n      if (!canGetContext) {\n        return {\n          webgl2: false,\n          maxTextureSize: 0,\n          maxRenderbufferSize: 0\n        };\n      }\n\n      const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');\n      \n      if (!gl) {\n        return {\n          webgl2: false,\n          maxTextureSize: 0,\n          maxRenderbufferSize: 0\n        };\n      }\n      \n      const info = {\n        webgl2: !!canvas.getContext && !!canvas.getContext('webgl2'),\n        maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),\n        maxRenderbufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)\n      };\n      \n      // \n      canvas.remove();\n      \n      return info;\n    } catch (error) {\n      Logger.warn('WebGL info detection failed:', error);\n      return {\n        webgl2: false,\n        maxTextureSize: 0,\n        maxRenderbufferSize: 0\n      };\n    }\n  }\n\n  /**\n   * Get device information\n   * \n   * @returns {Object} \n   * @private\n   */\n  static _getDeviceInfo() {\n    // detect()  error-fallback \n    if (typeof navigator === 'undefined') {\n      throw new Error('navigator is undefined');\n    }\n    const dpr = (typeof window !== 'undefined' && typeof window.devicePixelRatio === 'number') ? window.devicePixelRatio : 1;\n    const width = (typeof screen !== 'undefined' && typeof screen.width === 'number') ? screen.width : 1920;\n    const height = (typeof screen !== 'undefined' && typeof screen.height === 'number') ? screen.height : 1080;\n    const nav = navigator;\n\n    return {\n      deviceMemory: (nav && typeof nav.deviceMemory !== 'undefined') ? nav.deviceMemory : null,\n      hardwareConcurrency: (nav && typeof nav.hardwareConcurrency !== 'undefined') ? nav.hardwareConcurrency : null,\n      devicePixelRatio: dpr,\n      screenPixels: width * height * Math.pow(dpr, 2),\n      userAgent: (nav && nav.userAgent) ? nav.userAgent : ''\n    };\n  }\n}\n\n// \nexport function detectDeviceTier() {\n  const result = DeviceTierDetector.detect();\n  return {\n    tier: result.tier,\n    maxRenderVoxels: result.maxRenderVoxels,\n    detectionMethod: result.metadata.detectionMethod,\n    deviceInfo: result.metadata.deviceInfo,\n    webglInfo: result.metadata.webglInfo\n  };\n}\n\nexport function applyAutoRenderBudget(options) {\n  return DeviceTierDetector.applyAutoRenderBudget(options);\n}\n","/**\n * Coordinate transformation utilities (simple implementation).\n * \n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../utils/logger.js';\n\n/**\n * Comprehensive coordinate transformation utilities for geospatial data processing.\n * \n * \n * This utility class provides essential coordinate transformation and bounds calculation\n * functions for processing geospatial entity data in CesiumJS environments. Handles\n * conversions between different coordinate systems, calculates 3D spatial bounds,\n * and provides robust error handling for invalid coordinate data.\n * \n * CesiumJS\n * 3D\n * \n * \n * @since v0.1.0\n * @version 1.0.0 - Stable coordinate transformation utilities\n */\nexport class CoordinateTransformer {\n  /**\n   * Calculate comprehensive 3D spatial bounds from Cesium entity array.\n   * Cesium3D\n   * \n   * This method analyzes all provided entities to determine the minimum and maximum\n   * longitude, latitude, and altitude values, creating a bounding box that encompasses\n   * the entire dataset. Handles various entity position formats and provides robust\n   * error handling for invalid or missing position data.\n   * \n   * \n   * \n   * \n   * \n   * \n   * @param {Cesium.Entity[]} entities - Array of Cesium entities with position information / Cesium\n   * @returns {Object} Comprehensive bounds information / \n   * @returns {number} returns.minLon - Minimum longitude in degrees / \n   * @returns {number} returns.maxLon - Maximum longitude in degrees / \n   * @returns {number} returns.minLat - Minimum latitude in degrees / \n   * @returns {number} returns.maxLat - Maximum latitude in degrees / \n   * @returns {number} returns.minAlt - Minimum altitude in meters / \n   * @returns {number} returns.maxAlt - Maximum altitude in meters / \n   * @returns {number} returns.validEntityCount - Number of entities with valid positions / \n   * @throws {Error} Throws error if entity array is empty or invalid / \n   * \n   * @example\n   * // Calculate bounds for visualization / \n   * const entities = getAllEntities(viewer);\n   * const bounds = CoordinateTransformer.calculateBounds(entities);\n   * console.log(`Data spans ${bounds.maxLon - bounds.minLon} longitude`);\n   * \n   * @example  \n   * // Error handling for invalid data / \n   * try {\n   *   const bounds = CoordinateTransformer.calculateBounds(entities);\n   *   if (bounds.validEntityCount === 0) {\n   *     console.warn('No entities with valid positions found');\n   *   }\n   * } catch (error) {\n   *   console.error('Failed to calculate bounds:', error);\n   * }\n   * \n   * @since v0.1.0\n   * @static\n   */\n  static calculateBounds(entities) {\n    if (!Array.isArray(entities) || entities.length === 0) {\n      throw new Error('');\n    }\n    \n    let minLon = Infinity;\n    let maxLon = -Infinity;\n    let minLat = Infinity;\n    let maxLat = -Infinity;\n    let minAlt = Infinity;\n    let maxAlt = -Infinity;\n    \n    let validCount = 0;\n    const currentTime = Cesium.JulianDate.now();\n    \n    entities.forEach((entity, index) => {\n      try {\n        // \n        let position;\n        if (entity.position) {\n          if (typeof entity.position.getValue === 'function') {\n            position = entity.position.getValue(currentTime);\n          } else {\n            position = entity.position;\n          }\n        }\n        \n        if (!position) {\n          return; // \n        }\n        \n        // Cartesian3Cartographic\n        const cartographic = Cesium.Cartographic.fromCartesian(position);\n        if (!cartographic) return;\n        \n        const lon = Cesium.Math.toDegrees(cartographic.longitude);\n        const lat = Cesium.Math.toDegrees(cartographic.latitude);\n        const alt = cartographic.height;\n        \n        minLon = Math.min(minLon, lon);\n        maxLon = Math.max(maxLon, lon);\n        minLat = Math.min(minLat, lat);\n        maxLat = Math.max(maxLat, lat);\n        minAlt = Math.min(minAlt, alt);\n        maxAlt = Math.max(maxAlt, alt);\n        \n        validCount++;\n      } catch (error) {\n        Logger.warn(` ${index} :`, error);\n      }\n    });\n    \n    if (validCount === 0) {\n      throw new Error('');\n    }\n    \n    // \n    Logger.debug(':', {\n      validCount,\n      bounds: {\n        minLon, maxLon, \n        minLat, maxLat, \n        minAlt, maxAlt\n      }\n    });\n    \n    return {\n      minLon,\n      maxLon,\n      minLat,\n      maxLat,\n      minAlt,\n      maxAlt,\n      centerLon: (minLon + maxLon) / 2,\n      centerLat: (minLat + maxLat) / 2,\n      centerAlt: (minAlt + maxAlt) / 2\n    };\n  }\n  \n  /**\n   * Convert voxel indices to geographic coordinates (cell center).\n   * \n   * @param {number} x - X-axis voxel index / X\n   * @param {number} y - Y-axis voxel index / Y\n   * @param {number} z - Z-axis voxel index / Z\n   * @param {Object} bounds - Bounds info / \n   * @param {Object} grid - Grid info / \n   * @returns {Object} Geographic coordinate {lon, lat, alt} /  {lon, lat, alt}\n   */\n  static voxelIndexToCoordinate(x, y, z, bounds, grid) {\n    const { minLon, maxLon, minLat, maxLat, minAlt, maxAlt } = bounds;\n    const { numVoxelsX, numVoxelsY, numVoxelsZ } = grid;\n    \n    // \n    const normalizedLon = (x + 0.5) / numVoxelsX;\n    const normalizedLat = (y + 0.5) / numVoxelsY;\n    const normalizedAlt = (z + 0.5) / numVoxelsZ;\n    \n    return {\n      lon: minLon + normalizedLon * (maxLon - minLon),\n      lat: minLat + normalizedLat * (maxLat - minLat),\n      alt: minAlt + normalizedAlt * (maxAlt - minAlt)\n    };\n  }\n  \n  /**\n   * Convert geographic coordinates to Cesium Cartesian3.\n   *  Cesium Cartesian3 \n   * @param {number} lon - Longitude / \n   * @param {number} lat - Latitude / \n   * @param {number} alt - Altitude / \n   * @returns {Cesium.Cartesian3} Cesium Cartesian3\n   */\n  static coordinateToCartesian3(lon, lat, alt) {\n    return Cesium.Cartesian3.fromDegrees(lon, lat, alt);\n  }\n}\n","/**\n * \n */\nimport { Logger } from '../utils/logger.js';\n\n/**\n * Class for managing 3D voxel grids.\n * 3D\n */\nexport class VoxelGrid {\n  /**\n   * Create a grid from bounds and voxel size (simple version).\n   * \n   * @param {Object} bounds - Bounds info / \n   * @param {number} voxelSizeMeters - Target voxel size in meters (actual cell size is range/divisions per axis) / /\n   * @returns {Object} Grid info { numVoxelsX, numVoxelsY, numVoxelsZ, totalVoxels, voxelSizeMeters, cellSizeX, cellSizeY, cellSizeZ, lonRangeMeters, latRangeMeters, altRangeMeters }\n   */\n  static createGrid(bounds, voxelSizeMeters) {\n    // \n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    const lonRangeMeters = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);\n    const latRangeMeters = (bounds.maxLat - bounds.minLat) * 111000;\n    const altRangeMeters = bounds.maxAlt - bounds.minAlt;\n    \n    // \n    const numVoxelsX = Math.max(1, Math.ceil(lonRangeMeters / voxelSizeMeters));\n    const numVoxelsY = Math.max(1, Math.ceil(latRangeMeters / voxelSizeMeters));\n    const numVoxelsZ = Math.max(1, Math.ceil(altRangeMeters / voxelSizeMeters));\n\n    // \n    // ceil \n    const cellSizeX = numVoxelsX > 0 ? (lonRangeMeters / numVoxelsX) : voxelSizeMeters;\n    const cellSizeY = numVoxelsY > 0 ? (latRangeMeters / numVoxelsY) : voxelSizeMeters;\n    // 01m\n    const cellSizeZ = numVoxelsZ > 0 ? Math.max(altRangeMeters / numVoxelsZ, 1) : Math.max(voxelSizeMeters, 1);\n    \n    const totalVoxels = numVoxelsX * numVoxelsY * numVoxelsZ;\n    \n    Logger.debug('VoxelGrid created:', {\n      numVoxelsX,\n      numVoxelsY,\n      numVoxelsZ,\n      totalVoxels,\n      voxelSizeMeters,\n      cellSizeX,\n      cellSizeY,\n      cellSizeZ,\n      lonRangeMeters,\n      latRangeMeters,\n      altRangeMeters\n    });\n    \n    return {\n      numVoxelsX,\n      numVoxelsY,\n      numVoxelsZ,\n      totalVoxels,\n      voxelSizeMeters,\n      cellSizeX,\n      cellSizeY,\n      cellSizeZ,\n      lonRangeMeters,\n      latRangeMeters,\n      altRangeMeters\n    };\n  }\n  \n  /**\n   * Generate a key from voxel indices.\n   * \n   * @param {number} x - X index / X\n   * @param {number} y - Y index / Y\n   * @param {number} z - Z index / Z\n   * @returns {string} Voxel key / \n   */\n  static getVoxelKey(x, y, z) {\n    return `${x},${y},${z}`;\n  }\n  \n  /**\n   * Parse voxel key into indices.\n   * \n   * @param {string} key - Voxel key / \n   * @returns {Object} Indices {x, y, z} /  {x, y, z}\n   */\n  static parseVoxelKey(key) {\n    const [x, y, z] = key.split(',').map(Number);\n    return { x, y, z };\n  }\n  \n  /**\n   * Iterate all voxels and invoke callback per cell.\n   * \n   * @param {Object} grid - Grid info / \n   * @param {Function} callback - Callback per voxel / \n   */\n  static iterateAllVoxels(grid, callback) {\n    const { numVoxelsX, numVoxelsY, numVoxelsZ } = grid;\n    \n    for (let x = 0; x < numVoxelsX; x++) {\n      for (let y = 0; y < numVoxelsY; y++) {\n        for (let z = 0; z < numVoxelsZ; z++) {\n          const key = this.getVoxelKey(x, y, z);\n          callback(x, y, z, key);\n        }\n      }\n    }\n  }\n}\n","/**\n * \n */\nimport * as Cesium from 'cesium';\nimport { VoxelGrid } from './VoxelGrid.js';\nimport { Logger } from '../utils/logger.js';\n\n/**\n * Class responsible for processing entity data.\n * \n */\nexport class DataProcessor {\n  /**\n   * Classify entities into voxels (simple implementation).\n   * \n   * @param {Array} entities - Entity array / \n   * @param {Object} bounds - Bounds info / \n   * @param {Object} grid - Grid info / \n   * @returns {Map} Voxel data Map (key: voxel key, value: info) / : , : \n   */\n  static classifyEntitiesIntoVoxels(entities, bounds, grid) {\n    const voxelData = new Map();\n    let processedCount = 0;\n    let skippedCount = 0;\n    \n    Logger.debug(`Processing ${entities.length} entities for classification`);\n    \n    const currentTime = Cesium.JulianDate.now();\n    \n    entities.forEach((entity, index) => {\n      try {\n        // \n        let position;\n        if (entity.position) {\n          if (typeof entity.position.getValue === 'function') {\n            position = entity.position.getValue(currentTime);\n          } else {\n            position = entity.position;\n          }\n        }\n        \n        if (!position) {\n          skippedCount++;\n          return; // \n        }\n        \n        // Cartesian3Cartographic\n        const cartographic = Cesium.Cartographic.fromCartesian(position);\n        if (!cartographic) {\n          skippedCount++;\n          return;\n        }\n        \n        // \n        const lon = Cesium.Math.toDegrees(cartographic.longitude);\n        const lat = Cesium.Math.toDegrees(cartographic.latitude);\n        const alt = cartographic.height;\n        \n        // \n        if (lon < bounds.minLon - 0.001 || lon > bounds.maxLon + 0.001 ||\n            lat < bounds.minLat - 0.001 || lat > bounds.maxLat + 0.001 ||\n            alt < bounds.minAlt - 1 || alt > bounds.maxAlt + 1) {\n          skippedCount++;\n          return;\n        }\n        \n        // 0\n        const lonDen = (bounds.maxLon - bounds.minLon);\n        const latDen = (bounds.maxLat - bounds.minLat);\n        const altDen = (bounds.maxAlt - bounds.minAlt);\n\n        const voxelX = lonDen === 0 ? 0 : Math.floor(\n          (lon - bounds.minLon) / lonDen * grid.numVoxelsX\n        );\n        const voxelY = latDen === 0 ? 0 : Math.floor(\n          (lat - bounds.minLat) / latDen * grid.numVoxelsY\n        );\n        const voxelZ = altDen === 0 ? 0 : Math.floor(\n          (alt - bounds.minAlt) / altDen * grid.numVoxelsZ\n        );\n        \n        // \n        if (voxelX >= 0 && voxelX < grid.numVoxelsX &&\n            voxelY >= 0 && voxelY < grid.numVoxelsY &&\n            voxelZ >= 0 && voxelZ < grid.numVoxelsZ) {\n            \n          const voxelKey = VoxelGrid.getVoxelKey(voxelX, voxelY, voxelZ);\n          \n          if (!voxelData.has(voxelKey)) {\n            voxelData.set(voxelKey, {\n              x: voxelX,\n              y: voxelY,\n              z: voxelZ,\n              entities: [],\n              count: 0\n            });\n          }\n          \n          const voxelInfo = voxelData.get(voxelKey);\n          voxelInfo.entities.push(entity);\n          voxelInfo.count++;\n          \n          processedCount++;\n        } else {\n          skippedCount++;\n        }\n      } catch (error) {\n        Logger.warn(` ${index} :`, error);\n        skippedCount++;\n      }\n    });\n    \n    Logger.info(`${processedCount}${voxelData.size}${skippedCount}`);\n    return voxelData;\n  }\n  \n  /**\n   * Calculate statistics from voxel data.\n   * \n   * @param {Map} voxelData - Voxel data / \n   * @param {Object} grid - Grid info / \n   * @returns {Object} Statistics / \n   */\n  static calculateStatistics(voxelData, grid) {\n    if (voxelData.size === 0) {\n      return {\n        totalVoxels: grid.totalVoxels,\n        renderedVoxels: 0,\n        nonEmptyVoxels: 0,\n        emptyVoxels: grid.totalVoxels,\n        totalEntities: 0,\n        minCount: 0,\n        maxCount: 0,\n        averageCount: 0,\n        // v0.1.4: \n        autoAdjusted: false,\n        originalVoxelSize: null,\n        finalVoxelSize: null,\n        adjustmentReason: null\n      };\n    }\n    \n    const counts = Array.from(voxelData.values()).map(voxel => voxel.count);\n    const totalEntities = counts.reduce((sum, count) => sum + count, 0);\n    \n    const stats = {\n      totalVoxels: grid.totalVoxels,\n      renderedVoxels: 0, // VoxelRenderer\n      nonEmptyVoxels: voxelData.size,\n      emptyVoxels: grid.totalVoxels - voxelData.size,\n      totalEntities: totalEntities,\n      minCount: Math.min(...counts),\n      maxCount: Math.max(...counts),\n      averageCount: totalEntities / voxelData.size,\n      // v0.1.4: \n      autoAdjusted: false,\n      originalVoxelSize: null,\n      finalVoxelSize: null,\n      adjustmentReason: null\n    };\n    \n    Logger.debug(':', stats);\n    return stats;\n  }\n  \n  /**\n   * Get top-N densest voxels.\n   *  N \n   * @param {Map} voxelData - Voxel data / \n   * @param {number} topN - Number to get / \n   * @returns {Array} Top-N voxel info / N\n   */\n  static getTopNVoxels(voxelData, topN) {\n    if (voxelData.size === 0 || topN <= 0) {\n      return [];\n    }\n    \n    // \n    const sortedVoxels = Array.from(voxelData.values())\n      .sort((a, b) => b.count - a.count);\n    \n    // N\n    return sortedVoxels.slice(0, Math.min(topN, sortedVoxels.length));\n  }\n}\n","/**\n * Interface for voxel selection strategies.\n * \n * \n * All selection strategies must implement the select method.\n * select\n */\n\n/**\n * Abstract base class for voxel selection strategies.\n * \n */\nexport class SelectionStrategyInterface {\n  /**\n   * Select voxels according to strategy.\n   * \n   * \n   * @param {Array} allVoxels - All available voxels / \n   * @param {number} maxCount - Maximum selection count / \n   * @param {Object} grid - Grid information / \n   * @param {Set} _forceInclude - Voxels to force include (e.g., TopN) / TopN\n   * @param {Object} _options - Strategy-specific options / \n   * @returns {Object} Selection result with metadata / \n   * @returns {Array} returns.selected - Selected voxels / \n   * @returns {Object} returns.metadata - Strategy metadata / \n   * @abstract\n   */\n  select(allVoxels, maxCount, grid, _forceInclude = new Set(), _options = {}) {\n    throw new Error('SelectionStrategyInterface.select() must be implemented by subclass');\n  }\n\n  /**\n   * Get strategy name.\n   * \n   * \n   * @returns {string} Strategy name / \n   * @abstract\n   */\n  getStrategyName() {\n    throw new Error('SelectionStrategyInterface.getStrategyName() must be implemented by subclass');\n  }\n\n  /**\n   * Validate strategy-specific options.\n   * \n   * \n   * @param {Object} _options - Options to validate / \n   * @returns {boolean} Whether options are valid / \n   */\n  validateOptions(_options) {\n    // Default implementation accepts any options\n    // \n    return true;\n  }\n}\n","/**\n * Density-based voxel selection strategy.\n * \n * \n * This strategy selects voxels with the highest density values first.\n * \n */\n\nimport { SelectionStrategyInterface } from './SelectionStrategyInterface.js';\n\n/**\n * Density selection strategy implementation.\n * \n */\nexport class DensitySelectionStrategy extends SelectionStrategyInterface {\n  /**\n   * Select voxels by density (highest density first).\n   * \n   * \n   * @param {Array} allVoxels - All available voxels / \n   * @param {number} maxCount - Maximum selection count / \n   * @param {Object} grid - Grid information (not used in density strategy) / \n   * @param {Set} forceInclude - Voxels to force include (e.g., TopN) / TopN\n   * @param {Object} _options - Strategy options (not used in density strategy) / \n   * @returns {Object} Selection result / \n   * @returns {Array} returns.selected - Selected voxels sorted by density / \n   * @returns {Object} returns.metadata - Selection metadata / \n   */\n  select(allVoxels, maxCount, grid, forceInclude = new Set(), _options = {}) {\n    // Validate inputs / \n    if (!Array.isArray(allVoxels)) {\n      throw new Error('allVoxels must be an array');\n    }\n    if (typeof maxCount !== 'number' || maxCount < 0) {\n      throw new Error('maxCount must be a non-negative number');\n    }\n    if (!(forceInclude instanceof Set)) {\n      throw new Error('forceInclude must be a Set');\n    }\n\n    // Sort voxels by density (highest first)\n    // \n    const sorted = [...allVoxels].sort((a, b) => b.info.count - a.info.count);\n    \n    // Initialize selection arrays\n    // \n    const selected = [];\n    const included = new Set();\n    \n    // Add force-included voxels first (e.g., TopN highlights)\n    // TopN\n    sorted.forEach(voxel => {\n      if (forceInclude.has(voxel.key) && selected.length < maxCount) {\n        selected.push(voxel);\n        included.add(voxel.key);\n      }\n    });\n    \n    // Add remaining voxels in density order\n    // \n    sorted.forEach(voxel => {\n      if (!included.has(voxel.key) && selected.length < maxCount) {\n        selected.push(voxel);\n        included.add(voxel.key);\n      }\n    });\n\n    // Calculate statistics\n    // \n    const totalVoxels = allVoxels.length;\n    const selectedCount = selected.length;\n    const clippedCount = totalVoxels - selectedCount;\n    \n    const metadata = {\n      strategy: this.getStrategyName(),\n      totalVoxels,\n      selectedCount,\n      clippedCount,\n      forceIncludedCount: Math.min(forceInclude.size, selectedCount),\n      densityRange: selected.length > 0 ? {\n        max: selected[0]?.info?.count || 0,\n        min: selected[selected.length - 1]?.info?.count || 0\n      } : { max: 0, min: 0 }\n    };\n\n    return {\n      selected,\n      metadata\n    };\n  }\n\n  /**\n   * Get strategy name.\n   * \n   * \n   * @returns {string} Strategy name / \n   */\n  getStrategyName() {\n    return 'density';\n  }\n\n  /**\n   * Validate density strategy options.\n   * \n   * \n   * @param {Object} _options - Options to validate / \n   * @returns {boolean} Whether options are valid / \n   */\n  validateOptions(_options) {\n    // Density strategy doesn't require specific options\n    // \n    return true;\n  }\n}\n","/**\n * Coverage-based selection strategy for voxels.\n * \n */\nimport { SelectionStrategyInterface } from './SelectionStrategyInterface.js';\nimport { Logger } from '../../utils/logger.js';\n\n/**\n * Implements coverage-based voxel selection using stratified sampling.\n * \n * \n * \n */\nexport class CoverageSelectionStrategy extends SelectionStrategyInterface {\n  /**\n   * Select voxels based on spatial coverage using stratified sampling.\n   * \n   * \n   * @param {Array} allVoxels - All available voxels / \n   * @param {number} maxCount - Maximum voxels to select / \n   * @param {Object} grid - Grid information / \n   * @param {Set} forceInclude - Voxels to force include / \n   * @param {Object} options - Selection options / \n   * @returns {Object} Selection result / \n   */\n  select(allVoxels, maxCount, grid, forceInclude = new Set(), options = {}) {\n    Logger.debug(`Coverage selection: ${allVoxels.length} candidates, max ${maxCount}`);\n    \n    const selected = [];\n    const included = new Set();\n    \n    // \n    this._addForceIncludedVoxels(allVoxels, selected, included, forceInclude, maxCount);\n    \n    if (selected.length >= maxCount) {\n      return this._createResult(selected, options);\n    }\n    \n    // \n    const remainingVoxels = allVoxels.filter(voxel => !included.has(voxel.key));\n    const binsXY = this._calculateOptimalBinCount(maxCount - selected.length, options);\n    const bins = this._createSpatialBins(remainingVoxels, grid, binsXY);\n    \n    // \n    this._selectFromBins(bins, selected, included, maxCount, options);\n    \n    Logger.debug(`Coverage selection completed: ${selected.length} voxels selected`);\n    return this._createResult(selected, options, { binsXY, totalBins: bins.size });\n  }\n  \n  /**\n   * Add force-included voxels to selection.\n   * \n   * @param {Array} allVoxels - All voxels / \n   * @param {Array} selected - Selected voxels array / \n   * @param {Set} included - Set of included voxel keys / \n   * @param {Set} forceInclude - Force include set / \n   * @param {number} maxCount - Maximum count / \n   * @private\n   */\n  _addForceIncludedVoxels(allVoxels, selected, included, forceInclude, maxCount) {\n    for (const voxel of allVoxels) {\n      if (forceInclude.has(voxel.key) && selected.length < maxCount) {\n        selected.push(voxel);\n        included.add(voxel.key);\n      }\n    }\n  }\n  \n  /**\n   * Calculate optimal number of bins for spatial division.\n   * \n   * @param {number} targetCount - Target selection count / \n   * @param {Object} options - Selection options / \n   * @returns {number} Optimal bin count / \n   * @private\n   */\n  _calculateOptimalBinCount(targetCount, options) {\n    if (options.coverageBinsXY && options.coverageBinsXY !== 'auto') {\n      return Math.max(1, parseInt(options.coverageBinsXY));\n    }\n    \n    // : 4/\n    const targetVoxelsPerBin = 4;\n    const calculatedBins = Math.ceil(Math.sqrt(targetCount / targetVoxelsPerBin));\n    \n    // 220\n    return Math.max(2, Math.min(20, calculatedBins));\n  }\n  \n  /**\n   * Create spatial bins for stratified sampling.\n   * \n   * @param {Array} voxels - Voxels to bin / \n   * @param {Object} grid - Grid information / \n   * @param {number} binsXY - Number of bins per axis / \n   * @returns {Map} Spatial bins / \n   * @private\n   */\n  _createSpatialBins(voxels, grid, binsXY) {\n    const bins = new Map();\n    const maxX = Math.max(1, grid.numVoxelsX);\n    const maxY = Math.max(1, grid.numVoxelsY);\n    \n    for (const voxel of voxels) {\n      const binX = Math.max(0, Math.min(binsXY - 1, \n        Math.floor((voxel.info.x / maxX) * binsXY)));\n      const binY = Math.max(0, Math.min(binsXY - 1, \n        Math.floor((voxel.info.y / maxY) * binsXY)));\n      const binKey = `${binX},${binY}`;\n      \n      if (!bins.has(binKey)) {\n        bins.set(binKey, []);\n      }\n      bins.get(binKey).push(voxel);\n    }\n    \n    return bins;\n  }\n  \n  /**\n   * Select representative voxels from each bin.\n   * \n   * @param {Map} bins - Spatial bins / \n   * @param {Array} selected - Selected voxels array / \n   * @param {Set} included - Included voxel keys / \n   * @param {number} maxCount - Maximum count / \n   * @param {Object} options - Selection options / \n   * @private\n   */\n  _selectFromBins(bins, selected, included, maxCount, options) {\n    const binKeys = Array.from(bins.keys());\n    let binIndex = 0;\n    const maxIterations = binKeys.length * 10; // \n    \n    while (selected.length < maxCount && binIndex < maxIterations && bins.size > 0) {\n      const binKey = binKeys[binIndex % binKeys.length];\n      const binVoxels = bins.get(binKey);\n      \n      if (binVoxels && binVoxels.length > 0) {\n        // \n        const voxel = this._selectBestVoxelFromBin(binVoxels, options);\n        \n        if (voxel && !included.has(voxel.key)) {\n          selected.push(voxel);\n          included.add(voxel.key);\n        }\n        \n        // \n        const voxelIndex = binVoxels.indexOf(voxel);\n        if (voxelIndex >= 0) {\n          binVoxels.splice(voxelIndex, 1);\n        }\n        \n        // \n        if (binVoxels.length === 0) {\n          bins.delete(binKey);\n          const keyIndex = binKeys.indexOf(binKey);\n          if (keyIndex >= 0) {\n            binKeys.splice(keyIndex, 1);\n          }\n        }\n      }\n      \n      binIndex++;\n    }\n  }\n  \n  /**\n   * Select the best voxel from a bin based on selection criteria.\n   * \n   * @param {Array} binVoxels - Voxels in the bin / \n   * @param {Object} options - Selection options / \n   * @returns {Object} Best voxel / \n   * @private\n   */\n  _selectBestVoxelFromBin(binVoxels, options) {\n    if (binVoxels.length === 0) return null;\n    if (binVoxels.length === 1) return binVoxels[0];\n    \n    // \n    const sortedVoxels = [...binVoxels].sort((a, b) => b.info.count - a.info.count);\n    \n    // : 'highest''median''random'\n    const selectionMode = options.binSelectionMode || 'highest';\n    \n    switch (selectionMode) {\n      case 'median':\n        return sortedVoxels[Math.floor(sortedVoxels.length / 2)];\n      case 'random':\n        return sortedVoxels[Math.floor(Math.random() * sortedVoxels.length)];\n      case 'highest':\n      default:\n        return sortedVoxels[0];\n    }\n  }\n  \n  /**\n   * Create selection result with metadata.\n   * \n   * @param {Array} selected - Selected voxels / \n   * @param {Object} options - Selection options / \n   * @param {Object} additionalMetadata - Additional metadata / \n   * @returns {Object} Selection result / \n   * @private\n   */\n  _createResult(selected, options, additionalMetadata = {}) {\n    const metadata = {\n      strategy: 'coverage',\n      totalSelected: selected.length,\n      selectionRatio: selected.length > 0 ? 1.0 : 0.0,\n      ...additionalMetadata\n    };\n    \n    return { selected, metadata };\n  }\n}\n","/**\n * Hybrid selection strategy combining density and coverage approaches.\n * \n */\nimport { SelectionStrategyInterface } from './SelectionStrategyInterface.js';\nimport { DensitySelectionStrategy } from './DensitySelectionStrategy.js';\nimport { CoverageSelectionStrategy } from './CoverageSelectionStrategy.js';\nimport { Logger } from '../../utils/logger.js';\n\n/**\n * Implements hybrid voxel selection combining density and coverage strategies.\n * \n * \n */\nexport class HybridSelectionStrategy extends SelectionStrategyInterface {\n  constructor() {\n    super();\n    this.densityStrategy = new DensitySelectionStrategy();\n    this.coverageStrategy = new CoverageSelectionStrategy();\n  }\n  \n  /**\n   * Select voxels using hybrid approach (density + coverage).\n   *  + \n   * \n   * @param {Array} allVoxels - All available voxels / \n   * @param {number} maxCount - Maximum voxels to select / \n   * @param {Object} grid - Grid information / \n   * @param {Set} forceInclude - Voxels to force include / \n   * @param {Object} options - Selection options / \n   * @returns {Object} Selection result / \n   */\n  select(allVoxels, maxCount, grid, forceInclude = new Set(), options = {}) {\n    Logger.debug(`Hybrid selection: ${allVoxels.length} candidates, max ${maxCount}`);\n    \n    const selected = [];\n    const included = new Set();\n    \n    // \n    this._addForceIncludedVoxels(allVoxels, selected, included, forceInclude, maxCount);\n    \n    if (selected.length >= maxCount) {\n      return this._createResult(selected, options, 0, 0);\n    }\n    \n    // \n    const coverageRatio = this._determineCoverageRatio(options);\n    const remainingCount = maxCount - selected.length;\n    \n    // Density\n    const coverageCount = Math.floor(remainingCount * coverageRatio);\n    const densityCount = remainingCount - coverageCount;\n    \n    Logger.debug(`Hybrid split: ${coverageCount} coverage, ${densityCount} density`);\n    \n    // \n    let actualCoverageCount = 0;\n    if (coverageCount > 0) {\n      actualCoverageCount = this._executeCoverageSelection(\n        allVoxels, coverageCount, grid, included, selected, maxCount, options\n      );\n    }\n    \n    // \n    let actualDensityCount = 0;\n    if (densityCount > 0 && selected.length < maxCount) {\n      actualDensityCount = this._executeDensitySelection(\n        allVoxels, densityCount, grid, included, selected, maxCount, options\n      );\n    }\n    \n    Logger.debug(`Hybrid selection completed: ${selected.length} total (${actualCoverageCount} coverage, ${actualDensityCount} density)`);\n    \n    return this._createResult(selected, options, actualCoverageCount, actualDensityCount);\n  }\n  \n  /**\n   * Add force-included voxels to selection.\n   * \n   * @param {Array} allVoxels - All voxels / \n   * @param {Array} selected - Selected voxels array / \n   * @param {Set} included - Set of included voxel keys / \n   * @param {Set} forceInclude - Force include set / \n   * @param {number} maxCount - Maximum count / \n   * @private\n   */\n  _addForceIncludedVoxels(allVoxels, selected, included, forceInclude, maxCount) {\n    for (const voxel of allVoxels) {\n      if (forceInclude.has(voxel.key) && selected.length < maxCount) {\n        selected.push(voxel);\n        included.add(voxel.key);\n      }\n    }\n  }\n  \n  /**\n   * Determine the coverage ratio for hybrid selection.\n   * \n   * @param {Object} options - Selection options / \n   * @returns {number} Coverage ratio (0.0-1.0) / \n   * @private\n   */\n  _determineCoverageRatio(options) {\n    const defaultRatio = 0.3; // 30%\n    \n    if (options.minCoverageRatio !== undefined) {\n      return Math.max(0.0, Math.min(1.0, options.minCoverageRatio));\n    }\n    \n    if (options.coverageRatio !== undefined) {\n      return Math.max(0.0, Math.min(1.0, options.coverageRatio));\n    }\n    \n    return defaultRatio;\n  }\n  \n  /**\n   * Execute coverage selection phase.\n   * \n   * @param {Array} allVoxels - All voxels / \n   * @param {number} coverageCount - Target coverage count / \n   * @param {Object} grid - Grid information / \n   * @param {Set} included - Already included voxels / \n   * @param {Array} selected - Selected voxels array / \n   * @param {number} maxCount - Maximum total count / \n   * @param {Object} options - Selection options / \n   * @returns {number} Actual coverage count added / \n   * @private\n   */\n  _executeCoverageSelection(allVoxels, coverageCount, grid, included, selected, maxCount, options) {\n    const availableVoxels = allVoxels.filter(voxel => !included.has(voxel.key));\n    \n    if (availableVoxels.length === 0 || coverageCount <= 0) {\n      return 0;\n    }\n    \n    const coverageOptions = {\n      ...options,\n      // \n      binSelectionMode: options.hybridCoverageMode || 'highest'\n    };\n    \n    const coverageResult = this.coverageStrategy.select(\n      availableVoxels,\n      coverageCount,\n      grid,\n      new Set(), // \n      coverageOptions\n    );\n    \n    let addedCount = 0;\n    for (const voxel of coverageResult.selected) {\n      if (selected.length < maxCount && !included.has(voxel.key)) {\n        selected.push(voxel);\n        included.add(voxel.key);\n        addedCount++;\n      }\n    }\n    \n    return addedCount;\n  }\n  \n  /**\n   * Execute density selection phase.\n   * \n   * @param {Array} allVoxels - All voxels / \n   * @param {number} densityCount - Target density count / \n   * @param {Object} grid - Grid information / \n   * @param {Set} included - Already included voxels / \n   * @param {Array} selected - Selected voxels array / \n   * @param {number} maxCount - Maximum total count / \n   * @param {Object} options - Selection options / \n   * @returns {number} Actual density count added / \n   * @private\n   */\n  _executeDensitySelection(allVoxels, densityCount, grid, included, selected, maxCount, options) {\n    const availableVoxels = allVoxels.filter(voxel => !included.has(voxel.key));\n    \n    if (availableVoxels.length === 0 || densityCount <= 0) {\n      return 0;\n    }\n    \n    const densityOptions = {\n      ...options,\n      // \n      selectionMode: options.hybridDensityMode || 'highest'\n    };\n    \n    const densityResult = this.densityStrategy.select(\n      availableVoxels,\n      densityCount,\n      grid,\n      new Set(), // \n      densityOptions\n    );\n    \n    let addedCount = 0;\n    for (const voxel of densityResult.selected) {\n      if (selected.length < maxCount && !included.has(voxel.key)) {\n        selected.push(voxel);\n        included.add(voxel.key);\n        addedCount++;\n      }\n    }\n    \n    return addedCount;\n  }\n  \n  /**\n   * Create selection result with hybrid metadata.\n   * \n   * @param {Array} selected - Selected voxels / \n   * @param {Object} options - Selection options / \n   * @param {number} coverageCount - Actual coverage count / \n   * @param {number} densityCount - Actual density count / \n   * @returns {Object} Selection result / \n   * @private\n   */\n  _createResult(selected, options, coverageCount, densityCount) {\n    const totalSelectionCount = selected.length;\n    const actualCoverageRatio = totalSelectionCount > 0 ? \n      coverageCount / totalSelectionCount : 0;\n    \n    const metadata = {\n      strategy: 'hybrid',\n      totalSelected: totalSelectionCount,\n      coverageSelected: coverageCount,\n      densitySelected: densityCount,\n      coverageRatio: actualCoverageRatio,\n      targetCoverageRatio: this._determineCoverageRatio(options),\n      selectionRatio: totalSelectionCount > 0 ? 1.0 : 0.0\n    };\n    \n    return { selected, metadata };\n  }\n}\n","/**\n * Color mapping and interpolation utilities for voxel rendering.\n * \n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\n\n// v0.1.5: 256LUT\nconst COLOR_MAPS = {\n  // Viridis16\n  viridis: [\n    [68, 1, 84], [71, 44, 122], [59, 81, 139], [44, 113, 142],\n    [33, 144, 141], [39, 173, 129], [92, 200, 99], [170, 220, 50],\n    [253, 231, 37], [255, 255, 255], [255, 255, 255], [255, 255, 255],\n    [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]\n  ],\n  // Inferno16\n  inferno: [\n    [0, 0, 4], [31, 12, 72], [85, 15, 109], [136, 34, 106],\n    [186, 54, 85], [227, 89, 51], [249, 142, 8], [252, 187, 17],\n    [245, 219, 76], [252, 255, 164], [255, 255, 255], [255, 255, 255],\n    [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]\n  ],\n  // blue-white-red\n  diverging: [\n    [0, 0, 255], [32, 64, 255], [64, 128, 255], [96, 160, 255],\n    [128, 192, 255], [160, 224, 255], [192, 240, 255], [224, 248, 255],\n    [255, 255, 255], [255, 248, 224], [255, 240, 192], [255, 224, 160],\n    [255, 192, 128], [255, 160, 96], [255, 128, 64], [255, 64, 32], [255, 0, 0]\n  ]\n};\n\n/**\n * Color mapping and interpolation utility class.\n * \n */\nexport class ColorMap {\n  /**\n   * Main color interpolation method.\n   * \n   * @param {number} normalizedDensity - Normalized density (0-1) /  (0-1)\n   * @param {number} [rawValue] - Raw value for diverging scheme / \n   * @param {Object} options - Color options / \n   * @returns {Cesium.Color} Calculated color / \n   */\n  static interpolateColor(normalizedDensity, rawValue = null, options = {}) {\n    // v0.1.5: pivot<=0 \n    if (options.diverging && rawValue !== null) {\n      const pivot = typeof options.divergingPivot === 'number' ? options.divergingPivot : 0;\n      if (pivot > 0) {\n        return ColorMap._interpolateDivergingColor(rawValue, options);\n      }\n      // pivot  0 \n    }\n    \n    // v0.1.5: \n    if (options.colorMap && options.colorMap !== 'custom') {\n      return ColorMap._interpolateFromColorMap(normalizedDensity, options.colorMap);\n    }\n    \n    // min/max\n    const minColor = options.minColor || [0, 0, 255];\n    const maxColor = options.maxColor || [255, 0, 0];\n    \n    const [minR, minG, minB] = minColor;\n    const [maxR, maxG, maxB] = maxColor;\n    \n    const r = Math.round(minR + (maxR - minR) * normalizedDensity);\n    const g = Math.round(minG + (maxG - minG) * normalizedDensity);\n    const b = Math.round(minB + (maxB - minB) * normalizedDensity);\n    \n    return Cesium.Color.fromBytes(r, g, b);\n  }\n\n  /**\n   * Interpolate color from a color map.\n   * \n   * @param {number} normalizedValue - Normalized value (0-1) /  (0-1)\n   * @param {string} colorMapName - Color map name / \n   * @returns {Cesium.Color} Calculated color / \n   * @private\n   */\n  static _interpolateFromColorMap(normalizedValue, colorMapName) {\n    const colorMap = COLOR_MAPS[colorMapName];\n    if (!colorMap) {\n      Logger.warn(`Unknown color map: ${colorMapName}. Falling back to custom.`);\n      return ColorMap.interpolateColor(normalizedValue);\n    }\n    \n    // \n    const scaledValue = normalizedValue * (colorMap.length - 1);\n    const lowerIndex = Math.floor(scaledValue);\n    const upperIndex = Math.min(lowerIndex + 1, colorMap.length - 1);\n    const fraction = scaledValue - lowerIndex;\n    \n    // \n    const [lowerR, lowerG, lowerB] = colorMap[lowerIndex];\n    const [upperR, upperG, upperB] = colorMap[upperIndex];\n    \n    const r = Math.round(lowerR + (upperR - lowerR) * fraction);\n    const g = Math.round(lowerG + (upperG - lowerG) * fraction);\n    const b = Math.round(lowerB + (upperB - lowerB) * fraction);\n    \n    return Cesium.Color.fromBytes(r, g, b);\n  }\n\n  /**\n   * Interpolate color using diverging scheme.\n   * \n   * @param {number} rawValue - Raw value / \n   * @param {Object} options - Color options / \n   * @returns {Cesium.Color} Calculated color / \n   * @private\n   */\n  static _interpolateDivergingColor(rawValue, options) {\n    const pivot = options.divergingPivot || 0;\n    \n    // \n    let normalizedValue;\n    if (rawValue <= pivot) {\n      //  (0 to 0.5)\n      normalizedValue = 0.5 * (rawValue / pivot);\n      normalizedValue = Math.max(0, Math.min(0.5, normalizedValue));\n    } else {\n      //  (0.5 to 1)\n      normalizedValue = 0.5 + 0.5 * ((rawValue - pivot) / pivot);\n      normalizedValue = Math.max(0.5, Math.min(1, normalizedValue));\n    }\n    \n    return ColorMap._interpolateFromColorMap(normalizedValue, 'diverging');\n  }\n\n  /**\n   * Get available color map names.\n   * \n   * @returns {string[]} Available color map names / \n   */\n  static getAvailableColorMaps() {\n    return Object.keys(COLOR_MAPS);\n  }\n\n  /**\n   * Check if a color map exists.\n   * \n   * @param {string} colorMapName - Color map name / \n   * @returns {boolean} True if exists / true\n   */\n  static hasColorMap(colorMapName) {\n    return Object.prototype.hasOwnProperty.call(COLOR_MAPS, colorMapName);\n  }\n}\n","/**\n * Voxel entity creation utilities.\n * \n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\n\n/**\n * Voxel entity factory class.\n * \n */\nexport class VoxelEntityFactory {\n  /**\n   * Create a box voxel entity.\n   * \n   * @param {Object} config - Entity configuration / \n   * @param {Cesium.Cartesian3} config.position - Position / \n   * @param {Cesium.Cartesian3} config.dimensions - Dimensions / \n   * @param {Cesium.Color} config.color - Fill color / \n   * @param {number} config.opacity - Opacity / \n   * @param {boolean} config.wireframe - Wireframe mode / \n   * @param {Object} config.outline - Outline settings / \n   * @param {Object} config.properties - Custom properties / \n   * @param {string} config.description - Description HTML / HTML\n   * @returns {Object} Entity configuration / \n   */\n  static createBoxEntity(config) {\n    const {\n      position,\n      dimensions,\n      color,\n      opacity,\n      wireframe = false,\n      outline = {},\n      properties = {},\n      description = ''\n    } = config;\n\n    const entityConfig = {\n      position: position,\n      box: {\n        dimensions: dimensions,\n        outline: outline.show || false,\n        outlineColor: outline.color || Cesium.Color.WHITE,\n        outlineWidth: Math.max(outline.width || 1, 0) // \n      },\n      properties: {\n        type: 'voxel',\n        ...properties\n      },\n      description: description\n    };\n\n    // Wireframe mode handling / \n    if (wireframe) {\n      entityConfig.box.material = Cesium.Color.TRANSPARENT;\n      entityConfig.box.fill = false;\n    } else {\n      entityConfig.box.material = color.withAlpha(opacity);\n      entityConfig.box.fill = true;\n    }\n\n    return entityConfig;\n  }\n\n  /**\n   * Create a polyline entity for edge outlines.\n   * \n   * @param {Object} config - Polyline configuration / \n   * @param {Array<Cesium.Cartesian3>} config.positions - Line positions / \n   * @param {Cesium.Color} config.color - Line color / \n   * @param {number} config.width - Line width / \n   * @param {Object} config.properties - Custom properties / \n   * @returns {Object} Entity configuration / \n   */\n  static createPolylineEntity(config) {\n    const {\n      positions,\n      color,\n      width = 1,\n      properties = {}\n    } = config;\n\n    return {\n      polyline: {\n        positions: positions,\n        width: width,\n        material: color,\n        arcType: Cesium.ArcType.NONE\n      },\n      properties: {\n        type: 'outline',\n        ...properties\n      }\n    };\n  }\n\n  /**\n   * Create edge polylines for a box (thick outline emulation).\n   * \n   * @param {Cesium.Cartesian3} centerCart - Box center position / \n   * @param {number} sizeX - X dimension / X\n   * @param {number} sizeY - Y dimension / Y\n   * @param {number} sizeZ - Z dimension / Z\n   * @param {Cesium.Color} color - Line color / \n   * @param {number} width - Line width / \n   * @returns {Array<Object>} Array of polyline entity configurations / \n   */\n  static createBoxEdgePolylines(centerCart, sizeX, sizeY, sizeZ, color, width) {\n    try {\n      const halfX = sizeX / 2;\n      const halfY = sizeY / 2;\n      const halfZ = sizeZ / 2;\n      \n      // ENU\n      const enu = Cesium.Transforms.eastNorthUpToFixedFrame(centerCart);\n      \n      // \n      const toWorld = (dx, dy, dz) => {\n        const local = new Cesium.Cartesian3(dx, dy, dz);\n        return Cesium.Matrix4.multiplyByPoint(enu, local, new Cesium.Cartesian3());\n      };\n      \n      // 8\n      const corners = [\n        toWorld(-halfX, -halfY, -halfZ), // 0: \n        toWorld( halfX, -halfY, -halfZ), // 1: \n        toWorld( halfX,  halfY, -halfZ), // 2: \n        toWorld(-halfX,  halfY, -halfZ), // 3: \n        toWorld(-halfX, -halfY,  halfZ), // 4: \n        toWorld( halfX, -halfY,  halfZ), // 5: \n        toWorld( halfX,  halfY,  halfZ), // 6: \n        toWorld(-halfX,  halfY,  halfZ)  // 7: \n      ];\n      \n      // 12\n      const edges = [\n        [0, 1], [1, 2], [2, 3], [3, 0], // 4\n        [4, 5], [5, 6], [6, 7], [7, 4], // 4\n        [0, 4], [1, 5], [2, 6], [3, 7]  // 4\n      ];\n      \n      // \n      return edges.map(([i, j]) => \n        VoxelEntityFactory.createPolylineEntity({\n          positions: [corners[i], corners[j]],\n          color: color,\n          width: width,\n          properties: {\n            edgeType: 'thick-outline-emulation'\n          }\n        })\n      );\n      \n    } catch (error) {\n      Logger.warn('Edge polyline creation failed:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Create a debug bounding box entity.\n   * \n   * @param {Object} bounds - Data bounds / \n   * @param {Object} bounds.minLon - Minimum longitude / \n   * @param {Object} bounds.maxLon - Maximum longitude / \n   * @param {Object} bounds.minLat - Minimum latitude / \n   * @param {Object} bounds.maxLat - Maximum latitude / \n   * @param {Object} bounds.minAlt - Minimum altitude / \n   * @param {Object} bounds.maxAlt - Maximum altitude / \n   * @returns {Object|null} Entity configuration or null if bounds invalid / null\n   */\n  static createDebugBoundingBox(bounds) {\n    if (!bounds) return null;\n\n    try {\n      // \n      const centerLon = (bounds.minLon + bounds.maxLon) / 2;\n      const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n      const centerAlt = (bounds.minAlt + bounds.maxAlt) / 2;\n      \n      // \n      const widthMeters = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);\n      const depthMeters = (bounds.maxLat - bounds.minLat) * 111000;\n      const heightMeters = bounds.maxAlt - bounds.minAlt;\n      \n      return {\n        position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt),\n        box: {\n          dimensions: new Cesium.Cartesian3(widthMeters, depthMeters, heightMeters),\n          material: Cesium.Color.YELLOW.withAlpha(0.1),\n          outline: true,\n          outlineColor: Cesium.Color.YELLOW.withAlpha(0.3),\n          outlineWidth: 2\n        },\n        properties: {\n          type: 'debug-bounds'\n        },\n        description: `<br>: ${widthMeters.toFixed(1)} x ${depthMeters.toFixed(1)} x ${heightMeters.toFixed(1)} m`\n      };\n      \n    } catch (error) {\n      Logger.warn('Failed to create debug bounding box:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Create inset outline polylines.\n   * \n   * @param {number} centerLon - Center longitude / \n   * @param {number} centerLat - Center latitude / \n   * @param {number} centerAlt - Center altitude / \n   * @param {number} sizeX - X dimension / X\n   * @param {number} sizeY - Y dimension / Y\n   * @param {number} sizeZ - Z dimension / Z\n   * @param {Cesium.Color} color - Outline color / \n   * @param {number} width - Line width / \n   * @param {number} insetAmount - Inset amount in meters / \n   * @returns {Array<Object>} Array of polyline entity configurations / \n   */\n  static createInsetOutlinePolylines(centerLon, centerLat, centerAlt, sizeX, sizeY, sizeZ, color, width, insetAmount) {\n    try {\n      const centerCart = Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt);\n      \n      // \n      const insetSizeX = Math.max(sizeX - insetAmount * 2, sizeX * 0.1);\n      const insetSizeY = Math.max(sizeY - insetAmount * 2, sizeY * 0.1);\n      const insetSizeZ = Math.max(sizeZ - insetAmount * 2, sizeZ * 0.1);\n      \n      return VoxelEntityFactory.createBoxEdgePolylines(\n        centerCart,\n        insetSizeX,\n        insetSizeY,\n        insetSizeZ,\n        color,\n        width\n      ).map(config => ({\n        ...config,\n        properties: {\n          ...config.properties,\n          edgeType: 'inset-outline'\n        }\n      }));\n      \n    } catch (error) {\n      Logger.warn('Failed to create inset outline:', error);\n      return [];\n    }\n  }\n}\n","/**\n * Debug rendering utilities.\n * \n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\nimport { VoxelEntityFactory } from './VoxelEntityFactory.js';\n\n/**\n * Debug renderer class for development and troubleshooting.\n * \n */\nexport class DebugRenderer {\n  /**\n   * Constructor.\n   * @param {Cesium.Viewer} viewer - Cesium viewer instance / Cesium\n   */\n  constructor(viewer) {\n    this.viewer = viewer;\n    this.debugEntities = [];\n  }\n\n  /**\n   * Check if debug bounds should be shown.\n   * \n   * @param {Object|boolean} debugOptions - Debug options / \n   * @returns {boolean} True if bounds should be shown / true\n   */\n  shouldShowBounds(debugOptions) {\n    if (!debugOptions) {\n      return false;\n    }\n    \n    if (typeof debugOptions === 'boolean') {\n      // debugtrue\n      return debugOptions;\n    }\n    \n    if (typeof debugOptions === 'object' && debugOptions !== null) {\n      // debug.showBounds\n      return debugOptions.showBounds === true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Render debug bounding box.\n   * \n   * @param {Object} bounds - Data bounds / \n   * @param {Object} debugOptions - Debug options / \n   * @returns {boolean} True if successfully rendered / true\n   */\n  renderBoundingBox(bounds, debugOptions) {\n    if (!this.shouldShowBounds(debugOptions)) {\n      return false;\n    }\n\n    try {\n      const boundingBoxConfig = VoxelEntityFactory.createDebugBoundingBox(bounds);\n      if (!boundingBoxConfig) {\n        Logger.warn('Failed to create debug bounding box configuration');\n        return false;\n      }\n\n      const boundingBox = this.viewer.entities.add(boundingBoxConfig);\n      this.debugEntities.push(boundingBox);\n      \n      Logger.debug('Debug bounding box added:', {\n        center: { \n          lon: (bounds.minLon + bounds.maxLon) / 2, \n          lat: (bounds.minLat + bounds.maxLat) / 2, \n          alt: (bounds.minAlt + bounds.maxAlt) / 2 \n        },\n        size: { \n          width: (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(((bounds.minLat + bounds.maxLat) / 2) * Math.PI / 180), \n          depth: (bounds.maxLat - bounds.minLat) * 111000, \n          height: bounds.maxAlt - bounds.minAlt \n        }\n      });\n      \n      return true;\n      \n    } catch (error) {\n      Logger.warn('Failed to render debug bounding box:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Render debug grid lines.\n   * \n   * @param {Object} bounds - Data bounds / \n   * @param {Object} grid - Grid information / \n   * @param {Object} debugOptions - Debug options / \n   * @returns {number} Number of grid lines rendered / \n   */\n  renderGridLines(bounds, grid, debugOptions) {\n    if (!debugOptions || !debugOptions.showGrid) {\n      return 0;\n    }\n\n    try {\n      let renderedLines = 0;\n      \n      // X\n      for (let x = 0; x <= grid.numVoxelsX; x++) {\n        const lon = bounds.minLon + x * (bounds.maxLon - bounds.minLon) / grid.numVoxelsX;\n        \n        const gridLine = this.viewer.entities.add({\n          polyline: {\n            positions: [\n              Cesium.Cartesian3.fromDegrees(lon, bounds.minLat, bounds.minAlt),\n              Cesium.Cartesian3.fromDegrees(lon, bounds.maxLat, bounds.minAlt),\n              Cesium.Cartesian3.fromDegrees(lon, bounds.maxLat, bounds.maxAlt),\n              Cesium.Cartesian3.fromDegrees(lon, bounds.minLat, bounds.maxAlt),\n              Cesium.Cartesian3.fromDegrees(lon, bounds.minLat, bounds.minAlt)\n            ],\n            width: 1,\n            material: Cesium.Color.CYAN.withAlpha(0.3),\n            arcType: Cesium.ArcType.NONE\n          },\n          properties: {\n            type: 'debug-grid',\n            direction: 'x',\n            index: x\n          }\n        });\n        \n        this.debugEntities.push(gridLine);\n        renderedLines++;\n      }\n      \n      // Y\n      for (let y = 0; y <= grid.numVoxelsY; y++) {\n        const lat = bounds.minLat + y * (bounds.maxLat - bounds.minLat) / grid.numVoxelsY;\n        \n        const gridLine = this.viewer.entities.add({\n          polyline: {\n            positions: [\n              Cesium.Cartesian3.fromDegrees(bounds.minLon, lat, bounds.minAlt),\n              Cesium.Cartesian3.fromDegrees(bounds.maxLon, lat, bounds.minAlt),\n              Cesium.Cartesian3.fromDegrees(bounds.maxLon, lat, bounds.maxAlt),\n              Cesium.Cartesian3.fromDegrees(bounds.minLon, lat, bounds.maxAlt),\n              Cesium.Cartesian3.fromDegrees(bounds.minLon, lat, bounds.minAlt)\n            ],\n            width: 1,\n            material: Cesium.Color.MAGENTA.withAlpha(0.3),\n            arcType: Cesium.ArcType.NONE\n          },\n          properties: {\n            type: 'debug-grid',\n            direction: 'y',\n            index: y\n          }\n        });\n        \n        this.debugEntities.push(gridLine);\n        renderedLines++;\n      }\n      \n      Logger.debug(`Debug grid rendered: ${renderedLines} lines`);\n      return renderedLines;\n      \n    } catch (error) {\n      Logger.warn('Failed to render debug grid:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Render debug statistics overlay.\n   * \n   * @param {Object} stats - Rendering statistics / \n   * @param {Object} debugOptions - Debug options / \n   * @returns {boolean} True if successfully rendered / true\n   */\n  renderStatsOverlay(stats, debugOptions) {\n    if (!debugOptions || !debugOptions.showStats) {\n      return false;\n    }\n\n    try {\n      // Create stats HTML overlay\n      const _statsHtml = `\n        <div style=\"\n          position: absolute;\n          top: 10px;\n          left: 10px;\n          background: rgba(0,0,0,0.8);\n          color: white;\n          padding: 10px;\n          border-radius: 5px;\n          font-family: monospace;\n          font-size: 12px;\n          z-index: 1000;\n        \">\n          <h4 style=\"margin: 0 0 10px 0;\">Debug Stats</h4>\n          <div>Total Voxels: ${stats.totalVoxels || 0}</div>\n          <div>Rendered Voxels: ${stats.renderedVoxels || 0}</div>\n          <div>Render Time: ${stats.renderTime || 0}ms</div>\n          <div>Memory Usage: ${stats.memoryUsage || 'N/A'}</div>\n        </div>\n      `;\n      \n      // Note: In a real implementation, you would need to handle DOM overlay creation\n      // This is a simplified version for demonstration\n      Logger.debug('Debug stats overlay would be rendered:', stats);\n      \n      return true;\n      \n    } catch (error) {\n      Logger.warn('Failed to render debug stats overlay:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all debug entities.\n   * \n   */\n  clear() {\n    Logger.debug('DebugRenderer.clear - Removing', this.debugEntities.length, 'debug entities');\n    \n    this.debugEntities.forEach(entity => {\n      try {\n        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n        \n        if (entity && !isDestroyed) {\n          this.viewer.entities.remove(entity);\n        }\n      } catch (error) {\n        Logger.warn('Debug entity removal error:', error);\n      }\n    });\n    \n    this.debugEntities = [];\n  }\n\n  /**\n   * Get debug entity count.\n   * \n   * @returns {number} Number of debug entities / \n   */\n  getEntityCount() {\n    return this.debugEntities.length;\n  }\n\n  /**\n   * Log debug information.\n   * \n   * @param {string} category - Debug category / \n   * @param {Object} data - Debug data / \n   */\n  logDebugInfo(category, data) {\n    Logger.debug(`[${category}]`, data);\n  }\n}\n","/**\n * Controller for adaptive outline parameter calculation.\n * \n * \n * Handles dynamic outline width, opacity, and emulation decisions based on\n * voxel density, camera distance, and neighborhood analysis.\n * \n * \n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\n\n/**\n * AdaptiveOutlineController class for dynamic outline parameter calculation.\n * AdaptiveOutlineController\n */\nexport class AdaptiveOutlineController {\n  /**\n   * Constructor\n   * @param {Object} options - Configuration options / \n   */\n  constructor(options = {}) {\n    this.options = {\n      neighborhoodRadius: 50,\n      densityThreshold: 5,\n      cameraDistanceFactor: 1.0,\n      overlapRiskFactor: 0.3,\n      ...options\n    };\n  }\n\n  /**\n   * Calculate adaptive outline parameters for a voxel.\n   * \n   * \n   * @param {Object} voxelInfo - Voxel information / \n   * @param {boolean} isTopN - Whether it is TopN / TopN\n   * @param {Map} voxelData - All voxel data / \n   * @param {Object} statistics - Statistics / \n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesium\n   * @param {Object} baseOptions - Base rendering options / \n   * @returns {Object} Adaptive parameters / \n   */\n  calculateAdaptiveParams(voxelInfo, isTopN, voxelData, statistics, viewer, baseOptions) {\n    if (!baseOptions.adaptiveOutlines) {\n      return {\n        outlineWidth: null,\n        boxOpacity: null,\n        outlineOpacity: null,\n        shouldUseEmulation: false\n      };\n    }\n\n    const { x, y, z, count } = voxelInfo;\n    const normalizedDensity = statistics.maxCount > statistics.minCount ? \n      (count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;\n\n    // Calculate neighborhood density / \n    const neighborDensity = this._calculateNeighborhoodDensity(x, y, z, voxelData);\n    \n    // Calculate camera distance factor / \n    const cameraFactor = this._calculateCameraDistanceFactor(voxelInfo, viewer);\n    \n    // Calculate overlap risk / \n    const overlapRisk = this._calculateOverlapRisk(voxelInfo, voxelData, viewer);\n\n    // Determine outline width based on preset / \n    const outlineWidth = this._calculateOutlineWidth(\n      normalizedDensity, \n      neighborDensity, \n      cameraFactor, \n      baseOptions.outlineWidthPreset,\n      baseOptions.outlineWidth,\n      isTopN\n    );\n\n    // Calculate adaptive opacities / \n    const boxOpacity = this._calculateBoxOpacity(normalizedDensity, isTopN, baseOptions.opacity);\n    const outlineOpacity = this._calculateOutlineOpacity(\n      normalizedDensity, \n      neighborDensity, \n      cameraFactor\n    );\n\n    // Determine if emulation should be used / \n    const shouldUseEmulation = this._shouldUseEmulation(\n      overlapRisk, \n      neighborDensity, \n      baseOptions.outlineRenderMode\n    );\n\n    Logger.debug('Calculated adaptive params for voxel:', {\n      voxel: { x, y, z, count },\n      normalizedDensity,\n      neighborDensity,\n      cameraFactor,\n      overlapRisk,\n      result: { outlineWidth, boxOpacity, outlineOpacity, shouldUseEmulation }\n    });\n\n    return {\n      outlineWidth,\n      boxOpacity,\n      outlineOpacity,\n      shouldUseEmulation\n    };\n  }\n\n  /**\n   * Calculate neighborhood density around a voxel.\n   * \n   * \n   * @param {number} x - X coordinate / X\n   * @param {number} y - Y coordinate / Y\n   * @param {number} z - Z coordinate / Z\n   * @param {Map} voxelData - All voxel data / \n   * @returns {number} Neighborhood density / \n   * @private\n   */\n  _calculateNeighborhoodDensity(x, y, z, voxelData) {\n    const radius = Math.floor(this.options.neighborhoodRadius / 100); // Convert to grid units\n    let totalCount = 0;\n    let voxelCount = 0;\n\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          const key = `${x + dx},${y + dy},${z + dz}`;\n          const neighbor = voxelData.get(key);\n          if (neighbor) {\n            totalCount += neighbor.count;\n            voxelCount++;\n          }\n        }\n      }\n    }\n\n    return voxelCount > 0 ? totalCount / voxelCount : 0;\n  }\n\n  /**\n   * Calculate camera distance factor for adaptive rendering.\n   * \n   * \n   * @param {Object} voxelInfo - Voxel information / \n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesium\n   * @returns {number} Camera distance factor / \n   * @private\n   */\n  _calculateCameraDistanceFactor(voxelInfo, viewer) {\n    // Fallback when viewer camera or position is unavailable (tests/mocks)\n    if (!viewer || !viewer.camera || !voxelInfo || !voxelInfo.position) {\n      return 1.0;\n    }\n    const camera = viewer.camera;\n    const voxelPosition = voxelInfo.position;\n    const cameraPosition = camera.position || new Cesium.Cartesian3(0, 0, 1000);\n    const distance = Cesium.Cartesian3.distance(cameraPosition, voxelPosition);\n    const normalizedDistance = Math.min(distance / 10000, 1.0); // Normalize to 0-1\n    \n    return 1.0 - (normalizedDistance * this.options.cameraDistanceFactor);\n  }\n\n  /**\n   * Calculate overlap risk between nearby voxels.\n   * \n   * \n   * @param {Object} voxelInfo - Voxel information / \n   * @param {Map} voxelData - All voxel data / \n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesium\n   * @returns {number} Overlap risk factor / \n   * @private\n   */\n_calculateOverlapRisk(voxelInfo, voxelData, _viewer) {\n    const { x, y, z } = voxelInfo;\n    let adjacentCount = 0;\n    \n    // Check immediate neighbors / \n    const neighbors = [\n      [x+1, y, z], [x-1, y, z],\n      [x, y+1, z], [x, y-1, z],\n      [x, y, z+1], [x, y, z-1]\n    ];\n    \n    for (const [nx, ny, nz] of neighbors) {\n      const key = `${nx},${ny},${nz}`;\n      if (voxelData.has(key)) {\n        adjacentCount++;\n      }\n    }\n    \n    const adjacencyRatio = adjacentCount / 6;\n    return adjacencyRatio * this.options.overlapRiskFactor;\n  }\n\n  /**\n   * Calculate outline width based on preset and adaptive factors.\n   * \n   * \n   * @param {number} normalizedDensity - Normalized density / \n   * @param {number} neighborDensity - Neighborhood density / \n   * @param {number} cameraFactor - Camera distance factor / \n   * @param {string} preset - Width preset / \n   * @param {number} baseWidth - Base outline width / \n   * @returns {number} Calculated outline width / \n   * @private\n   */\n  _calculateOutlineWidth(normalizedDensity, neighborDensity, cameraFactor, preset, baseWidth, isTopN = false) {\n    switch (preset) {\n      case 'adaptive-density':\n        return neighborDensity > this.options.densityThreshold\n          ? Math.max(0.5, baseWidth * (0.5 + normalizedDensity * 0.5))\n          : baseWidth;\n\n      case 'topn-focus':\n        return isTopN\n          ? baseWidth * (1.5 + normalizedDensity * 0.5)\n          : Math.max(0.5, baseWidth * 0.7);\n      \n      case 'density-based':\n        return baseWidth * (0.5 + normalizedDensity * 1.5);\n      \n      case 'distance-adaptive':\n        return baseWidth * (0.8 + cameraFactor * 0.4);\n      \n      case 'neighborhood-aware': {\n        const densityFactor = neighborDensity > this.options.densityThreshold ? 0.7 : 1.2;\n        return baseWidth * densityFactor;\n      }\n      \n      case 'uniform':\n      default:\n        return baseWidth;\n    }\n  }\n\n  /**\n   * Calculate adaptive box opacity.\n   * \n   * \n   * @param {number} normalizedDensity - Normalized density / \n   * @param {boolean} isTopN - Whether it is TopN / TopN\n   * @param {number} baseOpacity - Base opacity / \n   * @returns {number} Calculated box opacity / \n   * @private\n   */\n  _calculateBoxOpacity(normalizedDensity, isTopN, baseOpacity) {\n    if (isTopN) {\n      return Math.min(baseOpacity * 1.2, 1.0);\n    }\n    \n    return baseOpacity * (0.6 + normalizedDensity * 0.4);\n  }\n\n  /**\n   * Calculate adaptive outline opacity.\n   * \n   * \n   * @param {number} normalizedDensity - Normalized density / \n   * @param {number} neighborDensity - Neighborhood density / \n   * @param {number} cameraFactor - Camera distance factor / \n   * @returns {number} Calculated outline opacity / \n   * @private\n   */\n  _calculateOutlineOpacity(normalizedDensity, neighborDensity, cameraFactor) {\n    const densityComponent = 0.7 + normalizedDensity * 0.3;\n    const neighborComponent = neighborDensity > this.options.densityThreshold ? 0.9 : 1.0;\n    const cameraComponent = 0.8 + cameraFactor * 0.2;\n    \n    return Math.min(densityComponent * neighborComponent * cameraComponent, 1.0);\n  }\n\n  /**\n   * Determine if emulation mode should be used.\n   * \n   * \n   * @param {number} overlapRisk - Overlap risk factor / \n   * @param {number} neighborDensity - Neighborhood density / \n   * @param {string} renderMode - Outline render mode / \n   * @returns {boolean} Whether to use emulation / \n   * @private\n   */\n  _shouldUseEmulation(overlapRisk, neighborDensity, renderMode) {\n    if (renderMode === 'emulation-only') {\n      return true;\n    }\n    \n    if (renderMode === 'standard') {\n      return false;\n    }\n    \n    // For 'inset' mode, use emulation in high-density areas / 'inset'\n    return overlapRisk > 0.5 && neighborDensity > this.options.densityThreshold;\n  }\n\n  /**\n   * Update adaptive parameters configuration.\n   * \n   * \n   * @param {Object} newOptions - New options / \n   */\n  updateOptions(newOptions) {\n    this.options = { ...this.options, ...newOptions };\n    Logger.debug('AdaptiveOutlineController options updated:', this.options);\n  }\n}\n","/**\n * Renderer for various outline modes.\n * \n * \n * Handles standard, inset, and emulation-only outline rendering modes.\n * \n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\nimport { VoxelEntityFactory } from '../voxel/VoxelEntityFactory.js';\n\n/**\n * OutlineRenderer class for handling different outline rendering modes.\n * OutlineRenderer\n */\nexport class OutlineRenderer {\n  /**\n   * Constructor\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesium\n   */\n  constructor(viewer) {\n    this.viewer = viewer;\n  }\n\n  /**\n   * Render outline for a voxel based on the specified mode.\n   * \n   * \n   * @param {Object} voxelInfo - Voxel information / \n   * @param {Object} outlineOptions - Outline options / \n   * @param {Object} adaptiveParams - Adaptive parameters / \n   * @returns {Array} Created outline entities / \n   */\n  renderOutline(voxelInfo, outlineOptions, adaptiveParams = {}) {\n    const { outlineRenderMode } = outlineOptions;\n    \n    Logger.debug('Rendering outline for voxel:', {\n      voxel: voxelInfo,\n      mode: outlineRenderMode,\n      adaptive: adaptiveParams\n    });\n\n    switch (outlineRenderMode) {\n      case 'standard': {\n        const entities = [];\n        // Standard outline is already handled on the box entity (VoxelRenderer)\n        // If inset is requested, add inset outline as an additional entity\n        if ((outlineOptions.outlineInset || 0) > 0 && this._shouldApplyInsetOutline(voxelInfo, outlineOptions)) {\n          entities.push(...this._renderInsetOutline(voxelInfo, outlineOptions, adaptiveParams));\n        }\n        return entities;\n      }\n      \n      case 'inset':\n        return this._renderInsetOutline(voxelInfo, outlineOptions, adaptiveParams);\n      \n      case 'emulation-only':\n        return this._renderEmulationOutline(voxelInfo, outlineOptions, adaptiveParams);\n      \n      default:\n        Logger.warn('Unknown outline render mode:', outlineRenderMode);\n        return this._renderStandardOutline(voxelInfo, outlineOptions, adaptiveParams);\n    }\n  }\n\n  /**\n   * Determine if inset outline should be applied based on mode and TopN.\n   * \n   * @param {Object} voxelInfo - Voxel information (may include isTopN) / \n   * @param {Object} outlineOptions - Outline options / \n   * @returns {boolean}\n   * @private\n   */\n  _shouldApplyInsetOutline(voxelInfo, outlineOptions) {\n    const mode = outlineOptions.outlineInsetMode || 'all';\n    if (mode === 'topn') return !!voxelInfo.isTopN;\n    return true;\n  }\n\n  /**\n   * Render standard outline mode.\n   * \n   * \n   * @param {Object} voxelInfo - Voxel information / \n   * @param {Object} outlineOptions - Outline options / \n   * @param {Object} adaptiveParams - Adaptive parameters / \n   * @returns {Array} Created outline entities / \n   * @private\n   */\n  _renderStandardOutline(voxelInfo, outlineOptions, adaptiveParams) {\n    const outlineWidth = adaptiveParams.outlineWidth || outlineOptions.outlineWidth;\n    const outlineOpacity = adaptiveParams.outlineOpacity || 1.0;\n    // Use fromBytes to avoid dependency on fromCssColorString in tests\n    const outlineColor = Cesium.Color.fromBytes(255, 255, 255, Math.round(255 * outlineOpacity));\n    \n    // Create polyline entities for box edges / \n    const centerCart = voxelInfo.position;\n    const sizeX = voxelInfo.width;\n    const sizeY = voxelInfo.depth;\n    const sizeZ = voxelInfo.height;\n    const polylineEntities = VoxelEntityFactory.createBoxEdgePolylines(\n      centerCart,\n      sizeX,\n      sizeY,\n      sizeZ,\n      outlineColor,\n      outlineWidth\n    );\n\n    return polylineEntities;\n  }\n\n  /**\n   * Render inset outline mode.\n   * \n   * \n   * @param {Object} voxelInfo - Voxel information / \n   * @param {Object} outlineOptions - Outline options / \n   * @param {Object} adaptiveParams - Adaptive parameters / \n   * @returns {Array} Created outline entities / \n   * @private\n   */\n  _renderInsetOutline(voxelInfo, outlineOptions, adaptiveParams) {\n    const { outlineInset } = outlineOptions;\n    \n    if (outlineInset <= 0) {\n      // No inset, fall back to standard mode / \n      return this._renderStandardOutline(voxelInfo, outlineOptions, adaptiveParams);\n    }\n\n    // Use emulation for high overlap risk areas / \n    if (adaptiveParams.shouldUseEmulation) {\n      return this._renderEmulationOutline(voxelInfo, outlineOptions, adaptiveParams);\n    }\n\n    // Create inset voxel with reduced dimensions (computed inline below)\n    \n    const outlineWidth = adaptiveParams.outlineWidth || outlineOptions.outlineWidth;\n    const outlineOpacity = adaptiveParams.outlineOpacity || 1.0;\n    const centerCart = voxelInfo.position;\n    // Enforce 20% max inset per axis (ADR-0004)\n    const maxInsetX = voxelInfo.width * 0.2;\n    const maxInsetY = voxelInfo.depth * 0.2;\n    const maxInsetZ = voxelInfo.height * 0.2;\n    const effInsetX = Math.min(outlineInset, maxInsetX);\n    const effInsetY = Math.min(outlineInset, maxInsetY);\n    const effInsetZ = Math.min(outlineInset, maxInsetZ);\n    const sizeX = Math.max(voxelInfo.width - 2 * effInsetX, voxelInfo.width * 0.1);\n    const sizeY = Math.max(voxelInfo.depth - 2 * effInsetY, voxelInfo.depth * 0.1);\n    const sizeZ = Math.max(voxelInfo.height - 2 * effInsetZ, voxelInfo.height * 0.1);\n    const outlineColor = Cesium.Color.fromBytes(255, 255, 255, Math.round(255 * outlineOpacity));\n\n    // Create a box-only outline entity (no fill) to match prior behavior\n    const boxEntity = {\n      position: centerCart,\n      box: {\n        dimensions: new Cesium.Cartesian3(sizeX, sizeY, sizeZ),\n        material: Cesium.Color.TRANSPARENT,\n        outline: true,\n        outlineColor: outlineColor,\n        outlineWidth: Math.max(outlineWidth || 1, 1),\n        fill: false\n      },\n      properties: {\n        type: 'voxel-inset-outline',\n        parentKey: voxelInfo.key,\n        insetSize: { x: sizeX, y: sizeY, z: sizeZ }\n      }\n    };\n\n    Logger.debug('Created inset outline with offset:', outlineInset);\n    return [boxEntity];\n  }\n\n  /**\n   * Render emulation-only outline mode.\n   * \n   * \n   * @param {Object} voxelInfo - Voxel information / \n   * @param {Object} outlineOptions - Outline options / \n   * @param {Object} adaptiveParams - Adaptive parameters / \n   * @returns {Array} Created outline entities / \n   * @private\n   */\n  _renderEmulationOutline(voxelInfo, outlineOptions, adaptiveParams) {\n    const outlineWidth = adaptiveParams.outlineWidth || outlineOptions.outlineWidth;\n    const outlineOpacity = adaptiveParams.outlineOpacity || 1.0;\n    // Use darker outline color for emulation mode without CSS dependency\n    const outlineColor = Cesium.Color.fromBytes(51, 51, 51, Math.round(255 * outlineOpacity));\n    \n    // Create thicker outline for emulation / \n    const emulationWidth = outlineWidth * 1.5;\n    \n    const centerCart = voxelInfo.position;\n    const sizeX = voxelInfo.width;\n    const sizeY = voxelInfo.depth;\n    const sizeZ = voxelInfo.height;\n    const polylineEntities = VoxelEntityFactory.createBoxEdgePolylines(\n      centerCart,\n      sizeX,\n      sizeY,\n      sizeZ,\n      outlineColor,\n      emulationWidth\n    );\n\n    Logger.debug('Created emulation outline with enhanced width:', emulationWidth);\n    return polylineEntities;\n  }\n\n  /**\n   * Create inset voxel information with reduced dimensions.\n   * \n   * \n   * @param {Object} voxelInfo - Original voxel information / \n   * @param {number} insetValue - Inset offset in meters / \n   * @param {string} insetMode - Inset application mode / \n   * @returns {Object} Inset voxel information / \n   * @private\n   */\n  _createInsetVoxelInfo(voxelInfo, insetValue, insetMode) {\n    const insetVoxelInfo = { ...voxelInfo };\n    \n    // Apply inset to dimensions based on mode / \n    switch (insetMode) {\n      case 'all':\n        insetVoxelInfo.width = Math.max(0.1, voxelInfo.width - insetValue * 2);\n        insetVoxelInfo.height = Math.max(0.1, voxelInfo.height - insetValue * 2);\n        insetVoxelInfo.depth = Math.max(0.1, voxelInfo.depth - insetValue * 2);\n        break;\n      \n      case 'horizontal':\n        insetVoxelInfo.width = Math.max(0.1, voxelInfo.width - insetValue * 2);\n        insetVoxelInfo.depth = Math.max(0.1, voxelInfo.depth - insetValue * 2);\n        // height remains unchanged / \n        break;\n      \n      case 'vertical':\n        insetVoxelInfo.height = Math.max(0.1, voxelInfo.height - insetValue * 2);\n        // width and depth remain unchanged / \n        break;\n      \n      default:\n        Logger.warn('Unknown inset mode:', insetMode);\n        // Fall back to 'all' mode / 'all'\n        insetVoxelInfo.width = Math.max(0.1, voxelInfo.width - insetValue * 2);\n        insetVoxelInfo.height = Math.max(0.1, voxelInfo.height - insetValue * 2);\n        insetVoxelInfo.depth = Math.max(0.1, voxelInfo.depth - insetValue * 2);\n        break;\n    }\n    \n    Logger.debug('Created inset voxel info:', {\n      original: {\n        width: voxelInfo.width,\n        height: voxelInfo.height,\n        depth: voxelInfo.depth\n      },\n      inset: {\n        width: insetVoxelInfo.width,\n        height: insetVoxelInfo.height,\n        depth: insetVoxelInfo.depth\n      },\n      mode: insetMode,\n      offset: insetValue\n    });\n    \n    return insetVoxelInfo;\n  }\n\n  /**\n   * Check if outline should be rendered for a voxel.\n   * \n   * \n   * @param {Object} voxelInfo - Voxel information / \n   * @param {Object} outlineOptions - Outline options / \n   * @returns {boolean} Whether outline should be rendered / \n   */\n  shouldRenderOutline(voxelInfo, outlineOptions) {\n    if (!outlineOptions.showOutline) {\n      return false;\n    }\n    \n    // Always render outline for non-empty voxels when outline is enabled\n    // \n    return voxelInfo.count > 0;\n  }\n\n  /**\n   * Get outline color based on voxel information and options.\n   * \n   * \n   * @param {Object} voxelInfo - Voxel information / \n   * @param {Object} outlineOptions - Outline options / \n   * @param {boolean} isTopN - Whether it is TopN / TopN\n   * @returns {Cesium.Color} Outline color / \n   */\n  getOutlineColor(voxelInfo, outlineOptions, isTopN = false) {\n    if (isTopN) {\n      return Cesium.Color.fromBytes(255, 255, 0, 255); // Yellow\n    }\n    if (outlineOptions.outlineRenderMode === 'emulation-only') {\n      return Cesium.Color.fromBytes(51, 51, 51, 255); // Dark\n    }\n    return Cesium.Color.fromBytes(255, 255, 255, 255); // White\n  }\n}\n","/**\n * @fileoverview InfoBox\n * \n * ADR-0008 Phase 3: VoxelRendererDescriptionBuilder\n * \n * @author cesium-heatbox\n * @version 0.1.10\n * @since 0.1.10\n */\n\n/**\n * InfoBox\n * \n * VoxelRenderer\n * InfoBoxHTML\n * \n * @class DescriptionBuilder\n * @since 0.1.10\n */\nexport class DescriptionBuilder {\n  /**\n   * DescriptionBuilder\n   * \n   * @param {Object} [options={}] - \n   * @param {string} [options.fontFamily='Arial, sans-serif'] - \n   * @param {string} [options.containerPadding='10px'] - \n   * @param {string} [options.headerMargin='0'] - \n   * @param {string} [options.tableWidth='100%'] - \n   */\n  constructor(options = {}) {\n    this.options = {\n      fontFamily: options.fontFamily || 'Arial, sans-serif',\n      containerPadding: options.containerPadding || '10px',\n      headerMargin: options.headerMargin || '0',\n      tableWidth: options.tableWidth || '100%',\n      ...options\n    };\n  }\n\n  /**\n   * HTML\n   * \n   * @param {Object} voxelInfo - \n   * @param {number} voxelInfo.x - X\n   * @param {number} voxelInfo.y - Y\n   * @param {number} voxelInfo.z - Z\n   * @param {number} voxelInfo.count - \n   * @param {string} voxelKey - \n   * @returns {string} HTML\n   */\n  createVoxelDescription(voxelInfo, voxelKey) {\n    return `\n      <div style=\"padding: ${this.options.containerPadding}; font-family: ${this.options.fontFamily};\">\n        <h3 style=\"margin-top: ${this.options.headerMargin};\"> [${voxelInfo.x}, ${voxelInfo.y}, ${voxelInfo.z}]</h3>\n        <table style=\"width: ${this.options.tableWidth};\">\n          <tr><td><b>:</b></td><td>${voxelInfo.count}</td></tr>\n          <tr><td><b>ID:</b></td><td>${voxelKey}</td></tr>\n        </table>\n      </div>\n    `;\n  }\n\n  /**\n   * \n   * \n   * @param {Object} voxelInfo - \n   * @param {string} voxelKey - \n   * @param {Object} [statistics] - \n   * @param {number} [statistics.percentile] - \n   * @param {number} [statistics.rank] - \n   * @param {number} [statistics.total] - \n   * @returns {string} HTML\n   */\n  createExtendedVoxelDescription(voxelInfo, voxelKey, statistics = null) {\n    let baseDescription = this.createVoxelDescription(voxelInfo, voxelKey);\n    \n    if (statistics) {\n      const statsSection = `\n        <hr style=\"margin: 10px 0;\">\n        <h4 style=\"margin: 5px 0;\"></h4>\n        <table style=\"width: ${this.options.tableWidth};\">\n          ${statistics.percentile !== undefined ? `<tr><td><b>:</b></td><td>${statistics.percentile.toFixed(1)}%</td></tr>` : ''}\n          ${statistics.rank !== undefined && statistics.total !== undefined ? `<tr><td><b>:</b></td><td>${statistics.rank}/${statistics.total}</td></tr>` : ''}\n        </table>\n      `;\n      \n      // </div></div>\n      baseDescription = baseDescription.replace('</div>', statsSection + '</div>');\n    }\n    \n    return baseDescription;\n  }\n\n  /**\n   * \n   * \n   * @param {Object} voxelInfo - \n   * @param {string} voxelKey - \n   * @param {Array<Object>} [customFields=[]] - \n   * @param {string} customFields[].label - \n   * @param {string|number} customFields[].value - \n   * @returns {string} HTML\n   */\n  createCustomVoxelDescription(voxelInfo, voxelKey, customFields = []) {\n    const customRows = customFields.map(field => \n      `<tr><td><b>${field.label}:</b></td><td>${field.value}</td></tr>`\n    ).join('');\n\n    return `\n      <div style=\"padding: ${this.options.containerPadding}; font-family: ${this.options.fontFamily};\">\n        <h3 style=\"margin-top: ${this.options.headerMargin};\"> [${voxelInfo.x}, ${voxelInfo.y}, ${voxelInfo.z}]</h3>\n        <table style=\"width: ${this.options.tableWidth};\">\n          <tr><td><b>:</b></td><td>${voxelInfo.count}</td></tr>\n          <tr><td><b>ID:</b></td><td>${voxelKey}</td></tr>\n          ${customRows}\n        </table>\n      </div>\n    `;\n  }\n}\n","/**\n * Voxel geometry calculation utilities.\n * \n */\nimport * as Cesium from 'cesium';\n\n/**\n * Voxel geometry calculation utility class.\n * \n */\nexport class VoxelGeometry {\n  /**\n   * Calculate voxel center coordinates.\n   * \n   * @param {number} x - X grid index / X\n   * @param {number} y - Y grid index / Y  \n   * @param {number} z - Z grid index / Z\n   * @param {Object} bounds - Data bounds / \n   * @param {Object} grid - Grid info / \n   * @returns {Object} Center coordinates / \n   */\n  static calculateVoxelCenter(x, y, z, bounds, grid) {\n    const centerLon = bounds.minLon + (x + 0.5) * (bounds.maxLon - bounds.minLon) / grid.numVoxelsX;\n    const centerLat = bounds.minLat + (y + 0.5) * (bounds.maxLat - bounds.minLat) / grid.numVoxelsY;\n    const centerAlt = bounds.minAlt + (z + 0.5) * (bounds.maxAlt - bounds.minAlt) / grid.numVoxelsZ;\n    \n    return {\n      longitude: centerLon,\n      latitude: centerLat,\n      altitude: centerAlt\n    };\n  }\n\n  /**\n   * Calculate voxel center position as Cartesian3.\n   * Cartesian3\n   * @param {number} x - X grid index / X\n   * @param {number} y - Y grid index / Y  \n   * @param {number} z - Z grid index / Z\n   * @param {Object} bounds - Data bounds / \n   * @param {Object} grid - Grid info / \n   * @returns {Cesium.Cartesian3} Center position / \n   */\n  static calculateVoxelPosition(x, y, z, bounds, grid) {\n    const center = VoxelGeometry.calculateVoxelCenter(x, y, z, bounds, grid);\n    return Cesium.Cartesian3.fromDegrees(center.longitude, center.latitude, center.altitude);\n  }\n\n  /**\n   * Calculate voxel cell sizes for each axis.\n   * \n   * @param {Object} grid - Grid info / \n   * @param {Object} options - Rendering options / \n   * @returns {Object} Cell sizes / \n   */\n  static calculateVoxelSizes(grid, options = {}) {\n    // voxelSizeMeters\n    let cellSizeX = grid.cellSizeX || (grid.lonRangeMeters ? (grid.lonRangeMeters / grid.numVoxelsX) : grid.voxelSizeMeters);\n    let cellSizeY = grid.cellSizeY || (grid.latRangeMeters ? (grid.latRangeMeters / grid.numVoxelsY) : grid.voxelSizeMeters);\n    let baseCellSizeZ = grid.cellSizeZ || (grid.altRangeMeters ? Math.max(grid.altRangeMeters / Math.max(grid.numVoxelsZ, 1), 1) : Math.max(grid.voxelSizeMeters, 1));\n\n    // v0.1.6.1: \n    if (options.voxelGap > 0) {\n      cellSizeX = Math.max(cellSizeX - options.voxelGap, cellSizeX * 0.1);\n      cellSizeY = Math.max(cellSizeY - options.voxelGap, cellSizeY * 0.1);\n      baseCellSizeZ = Math.max(baseCellSizeZ - options.voxelGap, baseCellSizeZ * 0.1);\n    }\n\n    return {\n      sizeX: cellSizeX,\n      sizeY: cellSizeY,\n      sizeZ: baseCellSizeZ\n    };\n  }\n\n  /**\n   * Calculate adjusted voxel height based on density.\n   * \n   * @param {number} baseSizeZ - Base Z size / Z\n   * @param {number} normalizedDensity - Normalized density (0-1) / \n   * @param {boolean} heightBased - Height-based mode / \n   * @returns {number} Adjusted height / \n   */\n  static calculateAdjustedHeight(baseSizeZ, normalizedDensity, heightBased = false) {\n    if (!heightBased) {\n      return baseSizeZ;\n    }\n\n    // \n    const minHeightRatio = 0.1; // 10%\n    return baseSizeZ * (minHeightRatio + (1 - minHeightRatio) * normalizedDensity);\n  }\n\n  /**\n   * Calculate voxel dimensions with all adjustments.\n   * \n   * @param {Object} grid - Grid info / \n   * @param {number} normalizedDensity - Normalized density (0-1) / \n   * @param {Object} options - Rendering options / \n   * @returns {Cesium.Cartesian3} Voxel dimensions / \n   */\n  static calculateVoxelDimensions(grid, normalizedDensity, options = {}) {\n    const sizes = VoxelGeometry.calculateVoxelSizes(grid, options);\n    const adjustedHeight = VoxelGeometry.calculateAdjustedHeight(\n      sizes.sizeZ, \n      normalizedDensity, \n      options.heightBased\n    );\n\n    return new Cesium.Cartesian3(sizes.sizeX, sizes.sizeY, adjustedHeight);\n  }\n\n  /**\n   * Calculate data bounds center.\n   * \n   * @param {Object} bounds - Data bounds / \n   * @returns {Object} Center coordinates / \n   */\n  static calculateBoundsCenter(bounds) {\n    return {\n      longitude: (bounds.minLon + bounds.maxLon) / 2,\n      latitude: (bounds.minLat + bounds.maxLat) / 2,\n      altitude: (bounds.minAlt + bounds.maxAlt) / 2\n    };\n  }\n\n  /**\n   * Calculate data bounds center as Cartesian3.\n   * Cartesian3\n   * @param {Object} bounds - Data bounds / \n   * @returns {Cesium.Cartesian3} Center position / \n   */\n  static calculateBoundsCenterPosition(bounds) {\n    const center = VoxelGeometry.calculateBoundsCenter(bounds);\n    return Cesium.Cartesian3.fromDegrees(center.longitude, center.latitude, center.altitude);\n  }\n}\n","/**\n * ADR-0008 Phase 3: VoxelRenderer \n * Main rendering engine for 3D voxels.\n * 3D\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\nimport { ColorMap } from '../color/ColorMap.js';\nimport { VoxelGeometry } from './VoxelGeometry.js';\nimport { VoxelEntityFactory } from './VoxelEntityFactory.js';\n\n/**\n * VoxelRenderingEngine handles the main rendering loop and voxel creation.\n * VoxelRenderingEngine\n */\n/**\n * Advanced 3D voxel rendering engine with comprehensive visualization features.\n * 3D\n * \n * This specialized rendering engine handles the core voxel rendering pipeline,\n * including density calculations, color mapping, adaptive outline control,\n * TopN highlighting, and advanced rendering modes. Separated from VoxelRenderer\n * as part of ADR-0008 modular architecture for better maintainability.\n * \n * \n * TopN\n * ADR-0008VoxelRenderer\n * \n * @since v0.1.10\n * @version 1.0.0 - Initial modular implementation\n */\nexport class VoxelRenderingEngine {\n  /**\n   * Initialize rendering engine with comprehensive component integration.\n   * \n   * \n   * Creates the core rendering engine that orchestrates voxel visualization\n   * by coordinating entity management, debug rendering, outline control,\n   * and description building components.\n   * \n   * \n   * \n   * \n   * \n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer instance / CesiumJS\n   * @param {VoxelEntityManager} entityManager - Entity lifecycle manager / \n   * @param {DebugRenderer} debugRenderer - Debug visualization component / \n   * @param {AdaptiveOutlineController} adaptiveOutlineController - Adaptive outline control / \n   * @param {OutlineRenderer} outlineRenderer - Specialized outline rendering / \n   * @param {DescriptionBuilder} descriptionBuilder - InfoBox description generator / InfoBox\n   * \n   * @since v0.1.10\n   */\n  constructor(viewer) {\n    this.viewer = viewer;\n    this.entityFactory = new VoxelEntityFactory();\n    this.colorMap = new ColorMap();\n  }\n\n  /**\n   * Render voxel data (main rendering loop).\n   * \n   * @param {Array} displayVoxels - Voxels to display / \n   * @param {Set} topNVoxels - TopN highlighted voxels / TopN\n   * @param {Object} bounds - Bounds info / \n   * @param {Object} grid - Grid info /   \n   * @param {Object} statistics - Statistics / \n   * @param {Object} options - Rendering options / \n   * @param {Function} calculateAdaptiveParams - Adaptive parameter calculation / \n   * @param {Object} outlineRenderer - Outline renderer / \n   * @param {Object} adaptiveOutlineController - Adaptive outline controller / \n   * @returns {Array} Created entities / \n   */\n  renderVoxels(displayVoxels, topNVoxels, bounds, grid, statistics, options, calculateAdaptiveParams, outlineRenderer, _adaptiveOutlineController) {\n    const entities = [];\n    \n    Logger.debug(`Rendering ${displayVoxels.length} voxels`);\n    \n    // \n    displayVoxels.forEach(({ key, info }) => {\n      try {\n        const { x, y, z } = info;\n        \n        // ADR-0008 Phase 1: VoxelGeometry\n        const center = VoxelGeometry.calculateVoxelCenter(x, y, z, bounds, grid);\n        const centerLon = center.longitude;\n        const centerLat = center.latitude;\n        const centerAlt = center.altitude;\n        \n        const isTopN = topNVoxels.has(key); // v0.1.5: TopN\n        \n        // \n        const position = Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt);\n        // v0.1.7: \n        const adaptiveParams = calculateAdaptiveParams({ ...info, position }, isTopN, null, statistics);\n        \n        // \n        let color, opacity;\n        \n        // \n        const normalizedDensity = statistics.maxCount > statistics.minCount ? \n          (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;\n        \n        if (info.count === 0) {\n          // \n          color = Cesium.Color.LIGHTGRAY;\n          opacity = options.emptyOpacity;\n        } else {\n          // \n          color = ColorMap.interpolateColor(normalizedDensity, info.count, options);\n          \n          // v0.1.7: resolverresolver >  > \n          if (options.boxOpacityResolver && typeof options.boxOpacityResolver === 'function') {\n            const resolverCtx = {\n              voxel: { x, y, z, count: info.count },\n              isTopN,\n              normalizedDensity,\n              statistics,\n              adaptiveParams\n            };\n            try {\n              const resolverOpacity = options.boxOpacityResolver(resolverCtx);\n              opacity = isNaN(resolverOpacity) ? options.opacity : Math.max(0, Math.min(1, resolverOpacity));\n            } catch (e) {\n              Logger.warn('boxOpacityResolver error, using fallback:', e);\n              opacity = adaptiveParams.boxOpacity || options.opacity;\n            }\n          } else {\n            opacity = adaptiveParams.boxOpacity || options.opacity;\n          }\n          \n          // v0.1.5: TopN\n          if (options.highlightTopN && !isTopN && !options.boxOpacityResolver) {\n            opacity *= 0.3; // TopN\n          }\n        }\n\n        // ADR-0008 Phase 1: VoxelGeometryvoxelGap/heightBased\n        const dims = VoxelGeometry.calculateVoxelDimensions(grid, normalizedDensity, options);\n        const sizeX = dims.x;\n        const sizeY = dims.y;\n        const sizeZ = dims.z;\n        let adjustedAlt = centerAlt;\n\n        // \n        let outlineWidth = options.outlineWidth;\n        let outlineColor = options.showOutline ? Cesium.Color.fromBytes(255, 255, 255, 255) : undefined;\n        \n        // v0.1.6: resolver >  > \n        if (options.outlineWidthResolver && typeof options.outlineWidthResolver === 'function') {\n          const resolverCtx = {\n            voxel: { x, y, z, count: info.count },\n            isTopN,\n            density: info.count,\n            normalizedDensity: statistics.maxCount > statistics.minCount ? \n              (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0,\n            statistics,\n            adaptiveParams\n          };\n          try {\n            const resolverWidth = options.outlineWidthResolver(resolverCtx);\n            outlineWidth = isNaN(resolverWidth) ? options.outlineWidth : Math.max(0, resolverWidth);\n          } catch (e) {\n            Logger.warn('outlineWidthResolver error, using fallback:', e);\n            outlineWidth = adaptiveParams.outlineWidth || options.outlineWidth;\n          }\n        } else {\n          // v0.1.7: \n          if (options.adaptiveOutlines && adaptiveParams.outlineWidth !== null) {\n            outlineWidth = adaptiveParams.outlineWidth;\n          }\n        }\n        // v0.1.5: TopNresolver\n        if (isTopN && options.highlightTopN) {\n          outlineWidth = (options.highlightStyle && options.highlightStyle.outlineWidth) || outlineWidth;\n        }\n        \n        // ADR-0008 Phase 4: \n        const outlineOpacity = (adaptiveParams.outlineOpacity != null)\n          ? adaptiveParams.outlineOpacity\n          : (options.outlineOpacity != null ? options.outlineOpacity : 1.0);\n        // \n        if (options.showOutline) {\n          outlineColor = Cesium.Color.fromBytes(255, 255, 255, 255).withAlpha(outlineOpacity);\n        }\n\n        // ADR-0008 Phase 1: VoxelEntityFactory\n        const entityConfig = VoxelEntityFactory.createBoxEntity({\n          position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, adjustedAlt),\n          dimensions: new Cesium.Cartesian3(sizeX, sizeY, sizeZ),\n          color: color,\n          opacity: opacity,\n          wireframe: options.wireframeOnly,\n          outline: {\n            show: options.showOutline === true,\n            color: outlineColor,\n            width: outlineWidth || 1\n          },\n          properties: {\n            key: key,\n            count: info.count,\n            x: info.x,\n            y: info.y,\n            z: info.z,\n            isTopN: isTopN,\n            normalizedDensity: normalizedDensity\n          }\n        });\n\n        // Cesium\n        const boxEntity = new Cesium.Entity({\n          id: `voxel-${key}`,\n          ...entityConfig\n        });\n        \n        // \n        boxEntity.description = options.createVoxelDescription ? \n          options.createVoxelDescription(info, normalizedDensity, statistics) : `Count: ${info.count}`;\n        \n        this.viewer.entities.add(boxEntity);\n        entities.push(boxEntity);\n\n        // ADR-0008 Phase 2: Render outline using OutlineRenderer (after box added)\n        const outlineOptions = {\n          outlineRenderMode: options.outlineRenderMode,\n          outlineInset: options.outlineInset,\n          outlineInsetMode: options.outlineInsetMode,\n          showOutline: options.showOutline,\n          outlineColor: outlineColor,\n          outlineWidth: outlineWidth,\n          enableThickFrames: options.enableThickFrames\n        };\n        \n        const voxelInfoWithPosition = {\n          ...info,\n          key: key,\n          position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, adjustedAlt),\n          width: sizeX,\n          height: sizeZ,\n          depth: sizeY,\n          isTopN: isTopN\n        };\n\n        const outlineEntities = outlineRenderer.renderOutline(voxelInfoWithPosition, outlineOptions, adaptiveParams);\n        outlineEntities.forEach(entity => {\n          this.viewer.entities.add(entity);\n          entities.push(entity);\n        });\n\n      } catch (error) {\n        Logger.error('Error rendering voxel:', error, { key, info });\n      }\n    });\n\n    Logger.info(`Successfully rendered ${entities.length} voxels`);\n    return entities;\n  }\n\n  /**\n   * Process display voxels from voxel data.\n   * \n   * @param {Map} voxelData - Raw voxel data / \n   * @param {Object} bounds - Bounds info / \n   * @param {Object} grid - Grid info / \n   * @param {Object} options - Options / \n   * @param {Function} selectVoxelsForRendering - Voxel selection function / \n   * @returns {Object} Processing result / \n   */\n  processDisplayVoxels(voxelData, bounds, grid, options, selectVoxelsForRendering) {\n    let displayVoxels = [];\n    const topNVoxels = new Set();\n    const maxVoxels = 1000000;\n\n    // \n    if (options.showEmptyVoxels) {\n      // \n      for (let x = 0; x < grid.numVoxelsX; x++) {\n        for (let y = 0; y < grid.numVoxelsY; y++) {\n          for (let z = 0; z < grid.numVoxelsZ; z++) {\n            const voxelKey = `${x},${y},${z}`;\n            const voxelInfo = voxelData.get(voxelKey) || { x, y, z, count: 0, entities: [] };\n            \n            displayVoxels.push({\n              key: voxelKey,\n              info: voxelInfo\n            });\n            \n            if (displayVoxels.length >= maxVoxels) {\n              Logger.debug(`Reached maximum voxel limit of ${maxVoxels}`);\n              break;\n            }\n          }\n          if (displayVoxels.length >= maxVoxels) break;\n        }\n        if (displayVoxels.length >= maxVoxels) break;\n      }\n    } else {\n      // \n      displayVoxels = Array.from(voxelData.entries()).map(([key, info]) => {\n        return { key, info };\n      });\n      \n      // v0.1.9: \n      if (options.maxRenderVoxels && displayVoxels.length > options.maxRenderVoxels) {\n        const selectionResult = selectVoxelsForRendering(displayVoxels, options.maxRenderVoxels, bounds, grid);\n        displayVoxels = selectionResult.selectedVoxels;\n        \n        Logger.debug(`Applied ${selectionResult.strategy} strategy: ${displayVoxels.length} voxels selected, ${selectionResult.clippedNonEmpty} clipped`);\n      }\n    }\n\n    // v0.1.5: TopN\n    if (options.highlightTopN && options.highlightTopN > 0) {\n      const sortedForTopN = [...displayVoxels].sort((a, b) => b.info.count - a.info.count);\n      const topN = sortedForTopN.slice(0, options.highlightTopN);\n      topN.forEach(voxel => topNVoxels.add(voxel.key));\n      Logger.debug(`TopN highlight enabled: ${topNVoxels.size} voxels will be highlighted`);\n    }\n\n    return { displayVoxels, topNVoxels };\n  }\n}\n","/**\n * ADR-0008 Phase 3: VoxelRenderer \n * Entity management for 3D voxels.\n * 3D\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from '../../utils/logger.js';\nimport { VoxelEntityFactory } from './VoxelEntityFactory.js';\n\n/**\n * VoxelEntityManager handles entity creation, management, and cleanup.\n * VoxelEntityManager\n */\n/**\n * Specialized manager for Cesium entity lifecycle in voxel rendering.\n * Cesium\n * \n * This class handles all aspects of voxel entity management including creation,\n * addition to scene, visibility control, and cleanup. Extracted from VoxelRenderer\n * as part of ADR-0008 modular refactoring to improve separation of concerns\n * and maintainability.\n * \n * \n * \n * ADR-0008\n * VoxelRenderer\n * \n * @since v0.1.10\n * @version 1.0.0 - Initial modular implementation (ADR-0008 Phase 3)\n */\nexport class VoxelEntityManager {\n  /**\n   * Constructor\n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer / CesiumJS Viewer\n   */\n  constructor(viewer) {\n    this.viewer = viewer;\n    this.entityFactory = new VoxelEntityFactory();\n    this.voxelEntities = [];\n  }\n\n  /**\n   * Add entity to managed entities list.\n   * \n   * @param {Cesium.Entity} entity - Entity to add / \n   */\n  addEntity(entity) {\n    this.voxelEntities.push(entity);\n    return entity;\n  }\n\n  /**\n   * Clear all managed entities.\n   * \n   */\n  clear() {\n    Logger.debug('VoxelEntityManager.clear - Removing', this.voxelEntities.length, 'entities');\n    \n    this.voxelEntities.forEach(entity => {\n      try {\n        // isDestroyed\n        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n        \n        if (entity && !isDestroyed) {\n          this.viewer.entities.remove(entity);\n        }\n      } catch (error) {\n        Logger.warn('Entity removal error:', error);\n      }\n    });\n    \n    this.voxelEntities = [];\n  }\n\n  /**\n   * Set visibility of all managed entities.\n   * /\n   * @param {boolean} show - Visibility state / \n   */\n  setVisible(show) {\n    Logger.debug('VoxelEntityManager.setVisible:', show, 'for', this.voxelEntities.length, 'entities');\n    \n    this.voxelEntities.forEach(entity => {\n      try {\n        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n        \n        if (entity && !isDestroyed) {\n          entity.show = show;\n        }\n      } catch (error) {\n        Logger.warn('Entity visibility error:', error);\n      }\n    });\n  }\n\n  /**\n   * Create and add an inset outline entity.\n   * \n   * @param {number} centerLon - Center longitude / \n   * @param {number} centerLat - Center latitude / \n   * @param {number} centerAlt - Center altitude / \n   * @param {number} baseSizeX - Base X size / X\n   * @param {number} baseSizeY - Base Y size / Y  \n   * @param {number} baseSizeZ - Base Z size / Z\n   * @param {Cesium.Color} outlineColor - Outline color / \n   * @param {number} outlineWidth - Outline width / \n   * @param {string} voxelKey - Voxel key / \n   * @param {number} insetAmount - Inset amount / \n   * @returns {Cesium.Entity} Created entity / \n   */\n  createInsetOutline(centerLon, centerLat, centerAlt, baseSizeX, baseSizeY, baseSizeZ, outlineColor, outlineWidth, voxelKey, insetAmount = null) {\n    // ADR-0004\n    const actualInset = insetAmount || 1.0; // 1m\n    \n    // \n    const insetX = Math.max(baseSizeX * 0.1, baseSizeX - 2 * actualInset);\n    const insetY = Math.max(baseSizeY * 0.1, baseSizeY - 2 * actualInset);\n    const insetZ = Math.max(baseSizeZ * 0.1, baseSizeZ - 2 * actualInset);\n\n    // Enforce 20% max inset per axis (ADR-0004)\n    const maxInsetX = baseSizeX * 0.4; // 40%\n    const maxInsetY = baseSizeY * 0.4;\n    const maxInsetZ = baseSizeZ * 0.4;\n    \n    const finalInsetX = Math.max(insetX, baseSizeX - maxInsetX);\n    const finalInsetY = Math.max(insetY, baseSizeY - maxInsetY);  \n    const finalInsetZ = Math.max(insetZ, baseSizeZ - maxInsetZ);\n\n    const insetDimensions = new Cesium.Cartesian3(finalInsetX, finalInsetY, finalInsetZ);\n    \n    const insetEntity = this.entityFactory.createBoxEntity({\n      id: `voxel-inset-${voxelKey}`,\n      position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt),\n      dimensions: insetDimensions,\n      color: Cesium.Color.TRANSPARENT, // \n      opacity: 0.0,\n      outlineColor: outlineColor,\n      outlineWidth: outlineWidth,\n      wireframeOnly: true,\n      key: `inset-${voxelKey}`\n    });\n\n    this.viewer.entities.add(insetEntity);\n    this.addEntity(insetEntity);\n    \n    return insetEntity;\n  }\n\n  /**\n   * Create thick outline frames using multiple frame boxes.\n   * \n   * @param {number} centerLon - Center longitude / \n   * @param {number} centerLat - Center latitude /   \n   * @param {number} centerAlt - Center altitude / \n   * @param {number} outerX - Outer X size / X\n   * @param {number} outerY - Outer Y size / Y\n   * @param {number} outerZ - Outer Z size / Z\n   * @param {number} innerX - Inner X size / X\n   * @param {number} innerY - Inner Y size / Y\n   * @param {number} innerZ - Inner Z size / Z\n   * @param {Cesium.Color} frameColor - Frame color / \n   * @param {string} voxelKey - Voxel key / \n   * @returns {Array} Created frame entities / \n   */\n  createThickOutlineFrames(centerLon, centerLat, centerAlt, outerX, outerY, outerZ, innerX, innerY, innerZ, frameColor, voxelKey) {\n    const frameEntities = [];\n    const frameThickness = Math.max((outerX - innerX) / 2, 0.5); // minimum 0.5m thickness\n    \n    const frames = [\n      // 6 faces: top/bottom, front/back, left/right\n      \n      // Top frame\n      {\n        position: [centerLon, centerLat, centerAlt + (outerZ - frameThickness) / 2],\n        size: [outerX, outerY, frameThickness]\n      },\n      // Bottom frame  \n      {\n        position: [centerLon, centerLat, centerAlt - (outerZ - frameThickness) / 2],\n        size: [outerX, outerY, frameThickness]\n      },\n      \n      // Front frame (Y+)\n      {\n        position: [centerLon, centerLat + (outerY - frameThickness) / 2, centerAlt],\n        size: [outerX, frameThickness, innerZ]\n      },\n      // Back frame (Y-)\n      {\n        position: [centerLon, centerLat - (outerY - frameThickness) / 2, centerAlt], \n        size: [outerX, frameThickness, innerZ]\n      },\n      \n      // Right frame (X+)\n      {\n        position: [centerLon + (outerX - frameThickness) / 2, centerLat, centerAlt],\n        size: [frameThickness, innerY, innerZ]\n      },\n      // Left frame (X-)\n      {\n        position: [centerLon - (outerX - frameThickness) / 2, centerLat, centerAlt],\n        size: [frameThickness, innerY, innerZ]\n      },\n      \n      // Edge frames (12 edges)\n      // 4 vertical edges\n      {\n        position: [centerLon + (innerX) / 2, centerLat + (innerY) / 2, centerAlt],\n        size: [frameThickness, frameThickness, outerZ]\n      },\n      {\n        position: [centerLon - (innerX) / 2, centerLat + (innerY) / 2, centerAlt],\n        size: [frameThickness, frameThickness, outerZ]\n      },\n      {\n        position: [centerLon + (innerX) / 2, centerLat - (innerY) / 2, centerAlt],\n        size: [frameThickness, frameThickness, outerZ] \n      },\n      {\n        position: [centerLon - (innerX) / 2, centerLat - (innerY) / 2, centerAlt],\n        size: [frameThickness, frameThickness, outerZ]\n      },\n      \n      // 4 horizontal edges (top)\n      {\n        position: [centerLon, centerLat + (innerY) / 2, centerAlt + (innerZ) / 2],\n        size: [innerX, frameThickness, frameThickness]\n      },\n      {\n        position: [centerLon, centerLat - (innerY) / 2, centerAlt + (innerZ) / 2],\n        size: [innerX, frameThickness, frameThickness]\n      }\n    ];\n\n    frames.forEach((frame, index) => {\n      // Skip frames that are too small\n      if (frame.size[0] > 0.1 && frame.size[1] > 0.1 && frame.size[2] > 0.1) {\n        const frameEntity = this.entityFactory.createBoxEntity({\n          id: `thick-frame-${voxelKey}-${index}`,\n          position: Cesium.Cartesian3.fromDegrees(frame.position[0], frame.position[1], frame.position[2]),\n          dimensions: {\n            width: frame.size[0],\n            height: frame.size[1], \n            depth: frame.size[2]\n          },\n          color: frameColor,\n          opacity: 1.0,\n          outlineColor: undefined,\n          outlineWidth: 0,\n          wireframeOnly: false,\n          key: `thick-frame-${voxelKey}-${index}`\n        });\n\n        this.viewer.entities.add(frameEntity);\n        this.addEntity(frameEntity);\n        frameEntities.push(frameEntity);\n      }\n    });\n\n    return frameEntities;\n  }\n\n  /**\n   * Check if inset outline should be applied.\n   * \n   * @param {boolean} isTopN - Is TopN voxel / TopN\n   * @param {Object} options - Options / \n   * @returns {boolean} Whether to apply inset outline / \n   */\n  shouldApplyInsetOutline(isTopN, options) {\n    const mode = options.outlineInsetMode || 'all';\n    \n    switch (mode) {\n      case 'all':\n        return true;\n      case 'topn-only':\n        return isTopN;\n      case 'non-topn':\n        return !isTopN;\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Get statistics about managed entities.\n   * \n   * @returns {Object} Entity statistics / \n   */\n  getEntityStats() {\n    return {\n      totalEntities: this.voxelEntities.length,\n      activeEntities: this.voxelEntities.filter(entity => {\n        try {\n          const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;\n          return !isDestroyed;\n        } catch {\n          return false;\n        }\n      }).length\n    };\n  }\n}\n","/**\n * Class responsible for rendering 3D voxels.\n * 3D\n * ADR-0008 Phase 3: Refactored with modular architecture\n */\nimport { Logger } from '../utils/logger.js';\nimport { DensitySelectionStrategy } from './selection/DensitySelectionStrategy.js';\nimport { CoverageSelectionStrategy } from './selection/CoverageSelectionStrategy.js';\nimport { HybridSelectionStrategy } from './selection/HybridSelectionStrategy.js';\nimport { ColorMap } from './color/ColorMap.js';\nimport { DebugRenderer } from './voxel/DebugRenderer.js';\nimport { AdaptiveOutlineController } from './outline/AdaptiveOutlineController.js';\nimport { OutlineRenderer } from './outline/OutlineRenderer.js';\nimport { DescriptionBuilder } from './voxel/DescriptionBuilder.js';\nimport { VoxelRenderingEngine } from './voxel/VoxelRenderingEngine.js';\nimport { VoxelEntityManager } from './voxel/VoxelEntityManager.js';\n\n/**\n * Core class responsible for 3D voxel rendering and visualization management.\n * 3D\n * \n * This class orchestrates the rendering of 3D voxel-based heatmaps by coordinating\n * multiple specialized components: rendering engine, entity manager, outline controllers,\n * and description builders. It provides the main interface for voxel visualization\n * with support for advanced features like adaptive outlines, TopN highlighting,\n * and customizable rendering modes.\n * \n * \n * 3D\n * TopN\n * \n * \n * \n * @since v0.1.0\n * @version v0.1.10 - Refactored with modular architecture (ADR-0008)\n */\nexport class VoxelRenderer {\n  /**\n   * Initialize VoxelRenderer with comprehensive rendering capabilities.\n   * VoxelRenderer\n   * \n   * Creates a fully-featured voxel renderer with modular architecture including\n   * dedicated components for entity management, outline rendering, adaptive\n   * control systems, and description generation. Supports extensive customization\n   * through the options parameter.\n   * \n   * \n   * \n   * options\n   * \n   * \n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer instance for rendering / CesiumJS\n   * @param {Object} [options={}] - Comprehensive rendering configuration / \n   * @param {number[]} [options.minColor=[0,0,255]] - RGB color for minimum density / RGB\n   * @default [0, 0, 255]\n   * @param {number[]} [options.maxColor=[255,0,0]] - RGB color for maximum density / RGB  \n   * @default [255, 0, 0]\n   * @param {number} [options.opacity=0.8] - Base opacity for voxels (0-1) / 0-1\n   * @default 0.8\n   * @param {boolean} [options.showOutline=true] - Whether to show voxel outlines / \n   * @default true\n   * @param {boolean} [options.adaptiveOutlines=false] - Enable adaptive outline control / \n   * @default false\n   * @param {string} [options.outlineWidthPreset='uniform'] - Outline width preset ('uniform', 'adaptive-density', 'topn-focus') / \n   * @default 'uniform'\n   * @param {string} [options.outlineRenderMode='standard'] - Rendering mode ('standard', 'inset', 'emulation-only') / \n   * @default 'standard'\n   * @param {Object} [options.adaptiveParams] - Parameters for adaptive algorithms / \n   * \n   * @throws {Error} Throws if viewer is invalid or required dependencies fail to initialize / \n   * \n   * @example\n   * // Basic renderer setup / \n   * const renderer = new VoxelRenderer(viewer, {\n   *   opacity: 0.9,\n   *   showOutline: true,\n   *   minColor: [0, 0, 255],\n   *   maxColor: [255, 0, 0]\n   * });\n   * \n   * @example\n   * // Advanced setup with adaptive features / \n   * const renderer = new VoxelRenderer(viewer, {\n   *   adaptiveOutlines: true,\n   *   outlineWidthPreset: 'adaptive-density',\n   *   outlineRenderMode: 'inset',\n   *   adaptiveParams: {\n   *     neighborhoodRadius: 75,\n   *     densityThreshold: 10\n   *   }\n   * });\n   * \n   * @example\n   * // OutlineRenderMode patterns / \n   * \n   * // Pattern 1: Standard mode (default) / \n   * const standardRenderer = new VoxelRenderer(viewer, {\n   *   outlineRenderMode: 'standard',\n   *   showOutline: true,\n   *   outlineWidth: 2\n   * });\n   * \n   * // Pattern 2: Inset mode (cleaner overlaps) / \n   * const insetRenderer = new VoxelRenderer(viewer, {\n   *   outlineRenderMode: 'inset',\n   *   outlineInset: 0.1,          // 10% inset\n   *   outlineInsetMode: 'adaptive' //  'all'\n   * });\n   * \n   * // Pattern 3: Emulation-only mode / \n   * const emulationRenderer = new VoxelRenderer(viewer, {\n   *   outlineRenderMode: 'emulation-only',\n   *   adaptiveOutlines: true\n   * });\n   * \n   * @example \n   * // AdaptiveOutlines + OutlineWidthPreset patterns /  + \n   * \n   * // Pattern 1: Uniform width (default) / \n   * const uniformRenderer = new VoxelRenderer(viewer, {\n   *   adaptiveOutlines: false,\n   *   outlineWidthPreset: 'uniform'\n   * });\n   * \n   * // Pattern 2: Density-adaptive width / \n   * const densityRenderer = new VoxelRenderer(viewer, {\n   *   adaptiveOutlines: true,\n   *   outlineWidthPreset: 'adaptive-density',\n   *   adaptiveParams: {\n   *     minOutlineWidth: 1,\n   *     maxOutlineWidth: 4\n   *   }\n   * });\n   * \n   * // Pattern 3: TopN focused width / TopN\n   * const topnRenderer = new VoxelRenderer(viewer, {\n   *   adaptiveOutlines: true,\n   *   outlineWidthPreset: 'topn-focus',\n   *   highlightTopN: 20,\n   *   highlightStyle: {\n   *     outlineWidth: 5,\n   *     outlineOpacity: 1.0\n   *   }\n   * });\n   * \n   * @since v0.1.0\n   */\n  constructor(viewer, options = {}) {\n    this.viewer = viewer;\n    this.options = {\n      minColor: [0, 0, 255],\n      maxColor: [255, 0, 0],\n      opacity: 0.8,\n      emptyOpacity: 0.03,\n      showOutline: true,\n      showEmptyVoxels: false,\n      wireframeOnly: false,    // \n      heightBased: false,      // \n      outlineWidth: 2,         // \n      // v0.1.6.1: \n      outlineInset: 0,         // \n      outlineInsetMode: 'all', // \n      // v0.1.7: \n      outlineRenderMode: 'standard',\n      adaptiveOutlines: false,\n      outlineWidthPreset: 'uniform',\n      boxOpacityResolver: null,\n      outlineOpacityResolver: null,\n      adaptiveParams: {\n        neighborhoodRadius: 50,\n        densityThreshold: 5,\n        cameraDistanceFactor: 1.0,\n        overlapRiskFactor: 0.3\n      },\n      ...options\n    };\n    \n    // v0.1.10: Initialize selection strategies / \n    this._initializeSelectionStrategies();\n    \n    // ADR-0008 Phase 1: Initialize debug renderer / \n    this.debugRenderer = new DebugRenderer(viewer);\n    \n    // ADR-0008 Phase 2: Initialize outline components / \n    this.adaptiveOutlineController = new AdaptiveOutlineController(this.options.adaptiveParams);\n    this.outlineRenderer = new OutlineRenderer(viewer);\n    \n    // ADR-0008 Phase 3: Initialize description builder / \n    this.descriptionBuilder = new DescriptionBuilder();\n    \n    // ADR-0008 Phase 3: Initialize rendering engine and entity manager / \n    this.renderingEngine = new VoxelRenderingEngine(viewer);\n    this.entityManager = new VoxelEntityManager(viewer);\n    \n    Logger.debug('VoxelRenderer initialized with options:', this.options);\n  }\n\n  /**\n   * Initialize selection strategies (v0.1.10).\n   *  (v0.1.10)\n   * @private\n   */\n  _initializeSelectionStrategies() {\n    this._selectionStrategies = {\n      density: new DensitySelectionStrategy(),\n      coverage: new CoverageSelectionStrategy(),\n      hybrid: new HybridSelectionStrategy()\n    };\n  }\n\n  /**\n   * Compute adaptive outline parameters (v0.1.7).\n   *  (v0.1.7)\n   * @param {Object} voxelInfo - Voxel information / \n   * @param {boolean} isTopN - Is TopN voxel / TopN\n   * @param {Map} voxelData - Voxel data / \n   * @param {Object} statistics - Statistics / \n   * @returns {Object} Adaptive parameters / \n   * @private\n   */\n  _calculateAdaptiveParams(voxelInfo, isTopN, voxelData, statistics) {\n    return this.adaptiveOutlineController.calculateAdaptiveParams(\n      voxelInfo, \n      isTopN, \n      voxelData, \n      statistics, \n      this.viewer, \n      this.options\n    );\n  }\n\n  /**\n   * Render voxel data (simplified implementation using rendering engine).\n   * \n   * @param {Map} voxelData - Voxel data / \n   * @param {Object} bounds - Bounds info / \n   * @param {Object} grid - Grid info / \n   * @param {Object} statistics - Statistics / \n   * @returns {number} Number of rendered voxels / \n   */\n  render(voxelData, bounds, grid, statistics) {\n    this.clear();\n    Logger.debug('VoxelRenderer.render - Starting render with rendering engine', {\n      voxelDataSize: voxelData.size,\n      bounds,\n      grid,\n      statistics\n    });\n\n    // ADR-0008 Phase 1: DebugRenderer\n    this.debugRenderer.renderBoundingBox(bounds, this.options.debug);\n\n    // ADR-0008 Phase 3: Use rendering engine to process display voxels\n    const { displayVoxels, topNVoxels } = this.renderingEngine.processDisplayVoxels(\n      voxelData, bounds, grid, this.options, \n      this._selectVoxelsForRendering.bind(this)\n    );\n\n    // Update selection stats if applicable\n    if (this.options.maxRenderVoxels && voxelData.size > this.options.maxRenderVoxels) {\n      /**\n       * Internal selection statistics for debugging and performance monitoring.\n       * \n       * @private\n       * @type {Object}\n       */\n      this._selectionStats = this._selectionStats || {\n        strategy: 'none',\n        clippedNonEmpty: 0,\n        coverageRatio: 1.0\n      };\n    }\n\n    // ADR-0008 Phase 3: Use rendering engine to render voxels  \n    const entities = this.renderingEngine.renderVoxels(\n      displayVoxels, \n      topNVoxels, \n      bounds, \n      grid, \n      statistics, \n      {\n        ...this.options,\n        createVoxelDescription: this.descriptionBuilder.createVoxelDescription.bind(this.descriptionBuilder)\n      },\n      this._calculateAdaptiveParams.bind(this),\n      this.outlineRenderer,\n      this.adaptiveOutlineController\n    );\n\n    // Add entities to manager\n    entities.forEach(entity => this.entityManager.addEntity(entity));\n\n    Logger.info(`Successfully rendered ${entities.length} voxels`);\n    return entities.length;\n  }\n\n  /**\n   * Backward-compatible color interpolation API.\n   * APIPhase1I/F\n   * @param {number} normalizedDensity\n   * @param {number} [rawValue]\n   * @returns {Cesium.Color}\n   */\n  interpolateColor(normalizedDensity, rawValue = null) {\n    return ColorMap.interpolateColor(normalizedDensity, rawValue, this.options);\n  }\n\n  /**\n   * Backward-compatible debug bounds flag checker.\n   * _private I/F\n   * @returns {boolean}\n   * @private\n   */\n  _shouldShowBounds() {\n    return this.debugRenderer.shouldShowBounds(this.options?.debug);\n  }\n\n  /**\n   * \n   */\n  clear() {\n    // ADR-0008 Phase 3: Use entity manager for clearing\n    this.entityManager.clear();\n    \n    // ADR-0008 Phase 1: DebugRenderer\n    if (this.debugRenderer) {\n      this.debugRenderer.clear();\n    }\n  }\n\n  /**\n   * Toggle visibility.\n   * /\n   * @param {boolean} show - true= false=\n   */\n  setVisible(show) {\n    // ADR-0008 Phase 3: Use entity manager for visibility control\n    this.entityManager.setVisible(show);\n  }\n\n  /**\n   * Select voxels for rendering based on the specified strategy.\n   * \n   * @param {Array} allVoxels - All voxels / \n   * @param {number} maxCount - Maximum count / \n   * @param {Object} bounds - Bounds / \n   * @param {Object} grid - Grid / \n   * @returns {Object} Selection result / \n   * @private\n   */\n  _selectVoxelsForRendering(allVoxels, maxCount, bounds, grid) {\n    const strategy = this.options.voxelSelectionStrategy || 'density';\n    let selectedVoxels;\n    let clippedCount;\n    let coverageRatio;\n\n    // TopN\n    const topNVoxels = new Set();\n    if (this.options.highlightTopN && this.options.highlightTopN > 0) {\n      const sortedForTopN = [...allVoxels].sort((a, b) => b.info.count - a.info.count);\n      const topN = sortedForTopN.slice(0, this.options.highlightTopN);\n      topN.forEach(voxel => topNVoxels.add(voxel.key));\n    }\n    \n    switch (strategy) {\n      case 'coverage': {\n        const coverageResult = this._selectionStrategies.coverage.select(allVoxels, maxCount, grid, topNVoxels, this.options);\n        selectedVoxels = coverageResult.selected;\n        clippedCount = allVoxels.length - selectedVoxels.length;\n        break;\n      }\n      \n      case 'hybrid': {\n        const hybridResult = this._selectionStrategies.hybrid.select(allVoxels, maxCount, grid, topNVoxels, this.options);\n        selectedVoxels = hybridResult.selected;\n        clippedCount = allVoxels.length - selectedVoxels.length;\n        coverageRatio = hybridResult.metadata?.coverageRatio;\n        break;\n      }\n      \n      case 'density':\n      default: {\n        const densityStrategy = this._selectionStrategies.density;\n        const densityResult = densityStrategy.select(allVoxels, maxCount, grid, topNVoxels, this.options);\n        selectedVoxels = densityResult.selected;\n        clippedCount = densityResult.metadata.clippedCount;\n        break;\n      }\n    }\n    \n    return {\n      selectedVoxels,\n      strategy,\n      clippedNonEmpty: clippedCount,\n      coverageRatio\n    };\n  }\n\n  /**\n   * Get selection statistics.\n   * \n   * @returns {Object|null} Selection statistics / \n   */\n  getSelectionStats() {\n    return this._selectionStats || null;\n  }\n\n  /**\n   * Backward compatibility: Get voxel entities.\n   * : \n   * @returns {Array} Voxel entities / \n   */\n  get voxelEntities() {\n    return this.entityManager.voxelEntities || [];\n  }\n\n  /**\n   * Backward compatibility: Check if inset outline should be applied.\n   * : \n   * @param {boolean} isTopN - Is TopN voxel / TopN\n   * @returns {boolean} Whether to apply inset outline / \n   * @private\n   */\n  _shouldApplyInsetOutline(isTopN) {\n    const mode = this.options.outlineInsetMode || 'all';\n    if (mode === 'topn') return !!isTopN;\n    return true;\n  }\n}\n","/**\n * ViewFitter utility for optimal camera positioning.\n * ViewFitter\n */\nimport * as Cesium from 'cesium';\nimport { Logger } from './logger.js';\n\n/**\n * Utility class for fitting camera view to data bounds.\n * \n */\nexport class ViewFitter {\n  /**\n   * Fit camera view to data bounds with optimal positioning.\n   * \n   * \n   * @param {Cesium.Viewer} viewer - Cesium viewer instance / Cesium\n   * @param {Object} bounds - Data bounds / \n   * @param {Object} options - View fitting options / \n   * @returns {Promise} Promise that resolves when camera movement completes / Promise\n   */\n  static async fitToBounds(viewer, bounds, options = {}) {\n    try {\n      if (!viewer || !bounds) {\n        throw new Error('Viewer and bounds are required');\n      }\n      \n      // \n      if (!ViewFitter._isValidBounds(bounds)) {\n        Logger.warn('Invalid bounds provided to ViewFitter:', bounds);\n        return Promise.resolve();\n      }\n      \n      // \n      const fitOptions = {\n        paddingPercent: 0.1,\n        pitchDegrees: -45,\n        headingDegrees: 0,\n        duration: 2.0,\n        maximumHeight: 50000,\n        minimumHeight: 100,\n        ...options\n      };\n      \n      Logger.debug('ViewFitter: fitting to bounds', bounds, 'with options', fitOptions);\n      \n      // \n      const dataRange = ViewFitter._calculateDataRange(bounds);\n      const maxRange = Math.max(dataRange.x, dataRange.y, dataRange.z);\n      \n      if (maxRange < 10) {\n        return ViewFitter._handleMinimalDataRange(viewer, bounds, fitOptions);\n      }\n      \n      if (maxRange > 100000) {\n        return ViewFitter._handleLargeDataRange(viewer, bounds, fitOptions);\n      }\n      \n      // \n      return ViewFitter._executeStandardFit(viewer, bounds, fitOptions, maxRange);\n      \n    } catch (error) {\n      Logger.error('ViewFitter: Failed to fit view to bounds:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Calculate data range in meters from bounds.\n   * \n   * @param {Object} bounds - Data bounds / \n   * @returns {Object} Data range {x, y, z} in meters / \n   * @private\n   */\n  static _calculateDataRange(bounds) {\n    // \n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    const cosLat = Math.cos(centerLat * Math.PI / 180);\n    \n    const lonRangeMeters = (bounds.maxLon - bounds.minLon) * 111000 * cosLat;\n    const latRangeMeters = (bounds.maxLat - bounds.minLat) * 111000;\n    const altRangeMeters = Math.max(bounds.maxAlt - bounds.minAlt, 1);\n    \n    return {\n      x: Math.max(lonRangeMeters, 1),\n      y: Math.max(latRangeMeters, 1),\n      z: altRangeMeters\n    };\n  }\n  \n  /**\n   * Validate bounds object.\n   * \n   * @param {Object} bounds - Bounds to validate / \n   * @returns {boolean} True if valid / true\n   * @private\n   */\n  static _isValidBounds(bounds) {\n    if (!bounds) {\n      return false;\n    }\n    \n    return typeof bounds.minLon === 'number' && !isNaN(bounds.minLon) &&\n           typeof bounds.maxLon === 'number' && !isNaN(bounds.maxLon) &&\n           typeof bounds.minLat === 'number' && !isNaN(bounds.minLat) &&\n           typeof bounds.maxLat === 'number' && !isNaN(bounds.maxLat) &&\n           typeof bounds.minAlt === 'number' && !isNaN(bounds.minAlt) &&\n           typeof bounds.maxAlt === 'number' && !isNaN(bounds.maxAlt) &&\n           bounds.minLon <= bounds.maxLon &&\n           bounds.minLat <= bounds.maxLat &&\n           bounds.minAlt <= bounds.maxAlt;\n  }\n  \n  /**\n   * Handle minimal data range (very small datasets).\n   * \n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesium\n   * @param {Object} bounds - Data bounds / \n   * @param {Object} options - Fit options / \n   * @returns {Promise} Camera movement promise / Promise\n   * @private\n   */\n  static _handleMinimalDataRange(viewer, bounds, options) {\n    Logger.debug('ViewFitter: handling minimal data range');\n    \n    const centerLon = (bounds.minLon + bounds.maxLon) / 2;\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    \n    // \n    const fixedHeight = Math.max(options.minimumHeight, 500);\n    \n    return ViewFitter._executeCameraMovement(viewer, {\n      destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, fixedHeight),\n      orientation: {\n        heading: Cesium.Math.toRadians(options.headingDegrees),\n        pitch: Cesium.Math.toRadians(options.pitchDegrees),\n        roll: 0.0\n      },\n      duration: options.duration\n    });\n  }\n  \n  /**\n   * Handle large data range (very large datasets).\n   * \n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesium\n   * @param {Object} bounds - Data bounds / \n   * @param {Object} options - Fit options / \n   * @returns {Promise} Camera movement promise / Promise\n   * @private\n   */\n  static _handleLargeDataRange(viewer, bounds, options) {\n    Logger.debug('ViewFitter: handling large data range');\n    \n    // Rectangle\n    const rectangle = Cesium.Rectangle.fromDegrees(\n      bounds.minLon, bounds.minLat, bounds.maxLon, bounds.maxLat\n    );\n    \n    const cameraOptions = {\n      duration: options.duration,\n      maximumHeight: options.maximumHeight\n    };\n    \n    return new Promise((resolve, reject) => {\n      try {\n        viewer.camera.flyTo({\n          destination: rectangle,\n          ...cameraOptions,\n          complete: () => {\n            Logger.debug('ViewFitter: large data range fit completed');\n            resolve();\n          },\n          cancel: () => {\n            Logger.debug('ViewFitter: large data range fit cancelled');\n            resolve();\n          }\n        });\n      } catch (error) {\n        Logger.error('ViewFitter: large data range fit failed:', error);\n        reject(error);\n      }\n    });\n  }\n  \n  /**\n   * Execute standard camera fit for normal data ranges.\n   * \n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesium\n   * @param {Object} bounds - Data bounds / \n   * @param {Object} options - Fit options / \n   * @param {number} maxRange - Maximum data range / \n   * @returns {Promise} Camera movement promise / Promise\n   * @private\n   */\n  static _executeStandardFit(viewer, bounds, options, maxRange) {\n    const centerLon = (bounds.minLon + bounds.maxLon) / 2;\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    \n    // \n    const paddingPercent = Math.max(0.05, Math.min(0.5, options.paddingPercent));\n    const paddingMeters = paddingPercent * maxRange;\n    \n    // \n    const cameraHeight = ViewFitter._calculateOptimalCameraHeight(\n      maxRange, \n      paddingMeters, \n      options\n    );\n    \n    // \n    return ViewFitter._executeCameraMovement(viewer, {\n      destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, cameraHeight),\n      orientation: {\n        heading: Cesium.Math.toRadians(options.headingDegrees),\n        pitch: Cesium.Math.toRadians(options.pitchDegrees),\n        roll: 0.0\n      },\n      duration: options.duration\n    });\n  }\n  \n  /**\n   * Calculate optimal camera height based on data range and viewing parameters.\n   * \n   * @param {number} maxRange - Maximum data range / \n   * @param {number} paddingMeters - Padding in meters / \n   * @param {Object} options - Fit options / \n   * @returns {number} Optimal camera height / \n   * @private\n   */\n  static _calculateOptimalCameraHeight(maxRange, paddingMeters, options) {\n    // 60\n    const fovRadians = Math.PI / 3; // 60\n    const pitchRadians = Math.abs(Cesium.Math.toRadians(options.pitchDegrees));\n    \n    // \n    const effectiveRange = maxRange + (2 * paddingMeters);\n    const pitchFactor = Math.cos(pitchRadians);\n    \n    // \n    let cameraHeight = (effectiveRange / pitchFactor) / (2 * Math.tan(fovRadians / 2));\n    \n    // 20%\n    cameraHeight *= 1.2;\n    \n    // \n    cameraHeight = Math.max(options.minimumHeight, \n                          Math.min(options.maximumHeight, cameraHeight));\n    \n    return cameraHeight;\n  }\n  \n  /**\n   * Execute camera movement with proper promise handling.\n   * Promise\n   * @param {Cesium.Viewer} viewer - Cesium viewer / Cesium\n   * @param {Object} cameraOptions - Camera movement options / \n   * @returns {Promise} Camera movement promise / Promise\n   * @private\n   */\n  static _executeCameraMovement(viewer, cameraOptions) {\n    return new Promise((resolve, reject) => {\n      try {\n        const flyToOptions = {\n          ...cameraOptions,\n          complete: () => {\n            Logger.debug('ViewFitter: camera movement completed');\n            resolve();\n          },\n          cancel: () => {\n            Logger.debug('ViewFitter: camera movement cancelled');\n            resolve();\n          }\n        };\n        \n        viewer.camera.flyTo(flyToOptions);\n        \n      } catch (error) {\n        Logger.error('ViewFitter: camera movement failed:', error);\n        reject(error);\n      }\n    });\n  }\n  \n  /**\n   * Create a Rectangle from bounds for large datasets.\n   * Rectangle\n   * @param {Object} bounds - Data bounds / \n   * @returns {Cesium.Rectangle} Cesium Rectangle / CesiumRectangle\n   * @static\n   */\n  static createRectangleFromBounds(bounds) {\n    if (!ViewFitter._isValidBounds(bounds)) {\n      throw new Error('Invalid bounds provided');\n    }\n    \n    return Cesium.Rectangle.fromDegrees(\n      bounds.minLon, bounds.minLat, bounds.maxLon, bounds.maxLat\n    );\n  }\n  \n  /**\n   * Calculate camera position for specific viewing angle.\n   * \n   * @param {Object} bounds - Data bounds / \n   * @param {Object} viewOptions - View options / \n   * @returns {Object} Camera position and orientation / \n   * @static\n   */\n  static calculateCameraPosition(bounds, viewOptions = {}) {\n    if (!ViewFitter._isValidBounds(bounds)) {\n      throw new Error('Invalid bounds provided');\n    }\n    \n    const options = {\n      paddingPercent: 0.1,\n      pitchDegrees: -45,\n      headingDegrees: 0,\n      minimumHeight: 100,\n      maximumHeight: 50000,\n      ...viewOptions\n    };\n    \n    const centerLon = (bounds.minLon + bounds.maxLon) / 2;\n    const centerLat = (bounds.minLat + bounds.maxLat) / 2;\n    const dataRange = ViewFitter._calculateDataRange(bounds);\n    const maxRange = Math.max(dataRange.x, dataRange.y, dataRange.z);\n    \n    const paddingMeters = options.paddingPercent * maxRange;\n    const cameraHeight = ViewFitter._calculateOptimalCameraHeight(\n      maxRange, paddingMeters, options\n    );\n    \n    return {\n      position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, cameraHeight),\n      orientation: {\n        heading: Cesium.Math.toRadians(options.headingDegrees),\n        pitch: Cesium.Math.toRadians(options.pitchDegrees),\n        roll: 0.0\n      },\n      metadata: {\n        dataRange: maxRange,\n        cameraHeight,\n        paddingMeters\n      }\n    };\n  }\n}\n","/**\n * CesiumJS Heatbox - Main library entry point with comprehensive API exports.\n * CesiumJS Heatbox - API \n * \n * This module serves as the primary entry point for the CesiumJS Heatbox library,\n * providing all essential classes, utilities, and helper functions needed for \n * 3D voxel-based heatmap visualization. Includes both default and named exports\n * for maximum compatibility with different import styles.\n * \n *  CesiumJS Heatbox \n * 3D \n * \n * \n * \n * @fileoverview Main entry point for CesiumJS Heatbox library\n * @author cesium-heatbox team\n * @version 0.1.10-alpha.1\n * @since 0.1.0\n */\n\nimport { Heatbox } from './Heatbox.js';\nimport { Logger } from './utils/logger.js';\nimport { getAllEntities, generateTestEntities } from './utils/sampleData.js';\n\n// \nexport default Heatbox;\n\n// \nexport { Heatbox };\nexport { getAllEntities, generateTestEntities };\n\n// \nexport { Heatbox as CesiumHeatbox };\n\n/**\n * Library metadata.\n * \n */\nexport const VERSION = '0.1.9';\nexport const AUTHOR = 'hiro-nyon';\nexport const REPOSITORY = 'https://github.com/hiro-nyon/cesium-heatbox';\n\n/**\n * Convenient factory function for quick Heatbox instance creation.\n * Heatbox\n * \n * This helper function provides a streamlined way to create Heatbox instances\n * without needing to import the class directly. Ideal for quick prototyping\n * and simple use cases where minimal setup is desired.\n * \n * Heatbox\n * \n * \n * \n * @param {Cesium.Viewer} viewer - Initialized CesiumJS Viewer instance / CesiumJS\n * @param {Object} [options={}] - Heatbox configuration options / Heatbox\n * @returns {Heatbox} Fully configured Heatbox instance ready for use / Heatbox\n * \n * @example\n * // Quick setup with default options / \n * import { createHeatbox } from 'cesium-heatbox';\n * const heatbox = createHeatbox(viewer);\n * \n * @example\n * // With custom configuration / \n * const heatbox = createHeatbox(viewer, {\n *   voxelSize: 50,\n *   opacity: 0.8,\n *   colorMap: 'viridis'\n * });\n * \n * @since v0.1.0\n */\nexport function createHeatbox(viewer, options) {\n  return new Heatbox(viewer, options);\n}\n\n/**\n * Comprehensive environment detection and capability assessment.\n * \n * \n * This diagnostic function analyzes the current runtime environment to provide\n * detailed information about browser capabilities, CesiumJS version, WebGL support,\n * and other relevant technical details. Essential for troubleshooting and\n * ensuring optimal performance configuration.\n * \n * CesiumJS\n * WebGL\n * \n * \n * @returns {Object} Comprehensive environment information / \n * @returns {string} returns.version - Current library version / \n * @returns {string} returns.cesiumVersion - CesiumJS version if available / CesiumJS\n * @returns {string} returns.userAgent - Browser user agent string / \n * @returns {boolean} returns.webglSupport - Whether WebGL is supported / WebGL\n * @returns {string} returns.timestamp - ISO timestamp of assessment / ISO\n * \n * @example\n * // Environment diagnostics / \n * import { getEnvironmentInfo } from 'cesium-heatbox';\n * const env = getEnvironmentInfo();\n * console.log(`Running Heatbox v${env.version} with Cesium ${env.cesiumVersion}`);\n * \n * @example\n * // Check WebGL support before initialization / WebGL\n * const env = getEnvironmentInfo();\n * if (!env.webglSupport) {\n *   console.error('WebGL not supported - heatmap visualization unavailable');\n * }\n * \n * @since v0.1.0\n */\nexport function getEnvironmentInfo() {\n  // WebGL \n  let webglSupport = false;\n  try {\n    if (typeof WebGLRenderingContext !== 'undefined') {\n      const canvas = document.createElement('canvas');\n      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n      webglSupport = !!gl;\n    }\n  } catch (_e) {\n    webglSupport = false;\n  }\n  \n  return {\n    version: VERSION,\n    cesiumVersion: typeof Cesium !== 'undefined' ? Cesium.VERSION : 'N/A',\n    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'N/A',\n    webglSupport: webglSupport,\n    timestamp: new Date().toISOString()\n  };\n}\n\n// \nLogger.info(`CesiumJS Heatbox v${VERSION} loaded`);\n","/**\n * CesiumJS Heatbox - \n */\nimport * as Cesium from 'cesium';\nimport { DEFAULT_OPTIONS, ERROR_MESSAGES, PERFORMANCE_LIMITS } from './utils/constants.js';\nimport { \n  isValidViewer,\n  isValidEntities,\n  validateAndNormalizeOptions,\n  validateVoxelCount,\n  calculateDataRange\n} from './utils/validation.js';\nimport { DeviceTierDetector } from './utils/deviceTierDetector.js';\nimport { VoxelSizeEstimator } from './utils/voxelSizeEstimator.js';\nimport { Logger } from './utils/logger.js';\nimport { CoordinateTransformer } from './core/CoordinateTransformer.js';\nimport { VoxelGrid } from './core/VoxelGrid.js';\nimport { DataProcessor } from './core/DataProcessor.js';\nimport { VoxelRenderer } from './core/VoxelRenderer.js';\nimport { ViewFitter } from './utils/ViewFitter.js';\n\n/**\n * Main class of CesiumJS Heatbox.\n * Provides 3D voxel-based heatmap visualization in CesiumJS environments.\n *\n * CesiumJS Heatbox \n * CesiumJS  3D \n */\nexport class Heatbox {\n  /**\n   * Constructor\n   * @param {Cesium.Viewer} viewer - CesiumJS Viewer instance / CesiumJS Viewer \n   * @param {Object} options - Configuration options / \n   */\n  constructor(viewer, options = {}) {\n    if (!isValidViewer(viewer)) {\n      throw new Error(ERROR_MESSAGES.INVALID_VIEWER);\n    }\n    \n    this.viewer = viewer;\n    \n    // v0.1.9: Auto Render Budget\n    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n    this.options = validateAndNormalizeOptions(DeviceTierDetector.applyAutoRenderBudget(mergedOptions));\n    \n    // \n    Logger.setLogLevel(this.options);\n    this.renderer = new VoxelRenderer(this.viewer, this.options);\n    this.viewFitter = new ViewFitter(this.viewer);\n    \n    this._bounds = null;\n    this._grid = null;\n    this._voxelData = null;\n    this._statistics = null;\n    this._eventHandler = null;\n\n    this._initializeEventListeners();\n  }\n\n  /**\n   * Set heatmap data and render 3D voxel visualization.\n   * 3D\n   * \n   * This method processes the provided entity array, calculates optimal voxel grid,\n   * and renders 3D voxel-based heatmap visualization in the Cesium viewer.\n   * \n   * \n   * Cesium3D\n   * \n   * @param {Cesium.Entity[]} entities - Array of Cesium entities with position information / Cesium\n   * @throws {Error} Throws error if entities array is invalid / \n   * @returns {Promise<void>} Promise that resolves when rendering is complete / Promise\n   * \n   * @example\n   * // Basic usage / \n   * const entities = generateTestEntities(viewer, bounds, 1000);\n   * await heatbox.setData(entities);\n   * \n   * @example  \n   * // With error handling / \n   * try {\n   *   await heatbox.setData(entities);\n   *   console.log('Heatmap rendered successfully');\n   * } catch (error) {\n   *   console.error('Failed to render heatmap:', error);\n   * }\n   * \n   * @since v0.1.0\n   */\n  async setData(entities) {\n    if (!isValidEntities(entities)) {\n      this.clear();\n      return;\n    }\n    \n    try {\n      Logger.debug('Heatbox.setData - :', entities.length, '');\n      \n      // 1. \n      Logger.debug('Step 1: ');\n      this._bounds = CoordinateTransformer.calculateBounds(entities);\n      if (!this._bounds) {\n        Logger.error('');\n        this.clear();\n        return;\n      }\n      Logger.debug(':', this._bounds);\n\n      // v0.1.4+v0.1.9: \n      let finalVoxelSize = this.options.voxelSize || DEFAULT_OPTIONS.voxelSize;\n      let autoAdjustmentInfo = null;\n      \n      if (this.options.autoVoxelSize && !this.options.voxelSize) {\n        try {\n          Logger.debug('');\n          \n          // v0.1.9: \n          const sizeOptions = {\n            autoVoxelSizeMode: this.options.autoVoxelSizeMode,\n            autoVoxelTargetFill: this.options.autoVoxelTargetFill,\n            maxRenderVoxels: this.options.maxRenderVoxels\n          };\n          \n          const estimatedSize = VoxelSizeEstimator.estimate(entities, this._bounds, this.options.autoVoxelSizeMode, sizeOptions);\n          const tempGrid = VoxelGrid.createGrid(this._bounds, estimatedSize);\n          const validation = validateVoxelCount(tempGrid.totalVoxels, estimatedSize);\n          \n          if (!validation.valid && validation.recommendedSize) {\n            finalVoxelSize = validation.recommendedSize;\n            autoAdjustmentInfo = {\n              enabled: true,\n              mode: this.options.autoVoxelSizeMode,\n              originalSize: estimatedSize,\n              finalSize: finalVoxelSize,\n              adjusted: true,\n              reason: `Performance limit exceeded: ${tempGrid.totalVoxels} > ${PERFORMANCE_LIMITS.maxVoxels}`\n            };\n            Logger.info(`Auto-adjusted voxelSize: ${estimatedSize}m  ${finalVoxelSize}m (${tempGrid.totalVoxels} voxels)`);\n          } else {\n            finalVoxelSize = estimatedSize;\n            autoAdjustmentInfo = {\n              enabled: true,\n              mode: this.options.autoVoxelSizeMode,\n              originalSize: estimatedSize,\n              finalSize: finalVoxelSize,\n              adjusted: false,\n              reason: null\n            };\n            Logger.info(`Auto-determined voxelSize: ${finalVoxelSize}m`);\n          }\n        } catch (error) {\n          Logger.warn('Auto voxel size adjustment failed, using default:', error);\n          finalVoxelSize = DEFAULT_OPTIONS.voxelSize;\n          autoAdjustmentInfo = {\n            enabled: true,\n            adjusted: false,\n            reason: 'Estimation failed, using default size',\n            originalSize: null,\n            finalSize: finalVoxelSize\n          };\n        }\n      }\n\n      // 2. \n      Logger.debug('Step 2:  (:', finalVoxelSize, 'm)');\n      this._grid = VoxelGrid.createGrid(this._bounds, finalVoxelSize);\n      Logger.debug(':', this._grid);\n      \n      // 3. \n      Logger.debug('Step 3: ');\n      this._voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, this._bounds, this._grid);\n      Logger.debug(':', this._voxelData.size, '');\n      \n      // 4. \n      Logger.debug('Step 4: ');\n      this._statistics = DataProcessor.calculateStatistics(this._voxelData, this._grid);\n      Logger.debug(':', this._statistics);\n      \n      // \n      if (autoAdjustmentInfo) {\n        this._statistics.autoAdjusted = autoAdjustmentInfo.adjusted;\n        this._statistics.originalVoxelSize = autoAdjustmentInfo.originalSize;\n        this._statistics.finalVoxelSize = autoAdjustmentInfo.finalSize;\n        this._statistics.adjustmentReason = autoAdjustmentInfo.reason;\n      }\n      \n      // 5. \n      Logger.debug('Step 5: ');\n      const renderedVoxelCount = this.renderer.render(this._voxelData, this._bounds, this._grid, this._statistics);\n      \n      // \n      this._statistics.renderedVoxels = renderedVoxelCount;\n      Logger.info(' - :', renderedVoxelCount);\n      \n      // v0.1.9: \n      if (this.options.autoView) {\n        try {\n          Logger.debug('Auto view adjustment triggered');\n          await this.fitView();\n          Logger.debug('Auto view adjustment completed');\n        } catch (error) {\n          Logger.warn('Auto view adjustment failed:', error);\n          // \n        }\n      }\n      \n      Logger.debug('Heatbox.setData - ');\n      \n    } catch (error) {\n      Logger.error(':', error);\n      this.clear();\n      throw error;\n    }\n  }\n\n  /**\n   * Create heatmap from entities and return detailed statistics.\n   * \n   * \n   * This method is equivalent to calling setData() followed by getStatistics().\n   * It processes the entity array to create voxel-based heatmap visualization\n   * and returns comprehensive statistics about the rendered result.\n   * \n   *  setData()  getStatistics() \n   * \n   * \n   * \n   * @param {Cesium.Entity[]} entities - Array of Cesium entities to process / Cesium\n   * @returns {Promise<Object>} Detailed rendering statistics / \n   * @returns {Promise<number>} returns.totalVoxels - Total number of voxels in grid / \n   * @returns {Promise<number>} returns.renderedVoxels - Number of actually rendered voxels / \n   * @returns {Promise<number>} returns.nonEmptyVoxels - Number of voxels containing data / \n   * @returns {Promise<number>} returns.minCount - Minimum entity count in any voxel / \n   * @returns {Promise<number>} returns.maxCount - Maximum entity count in any voxel / \n   * @returns {Promise<number>} returns.averageCount - Average entity count per non-empty voxel / \n   * @throws {Error} Throws error if entities array is empty or invalid / \n   * \n   * @example\n   * // Create heatmap and get statistics / \n   * const entities = generateTestEntities(viewer, bounds, 1000);\n   * const stats = await heatbox.createFromEntities(entities);\n   * console.log(`Rendered ${stats.renderedVoxels} out of ${stats.totalVoxels} voxels`);\n   * \n   * @example\n   * // Error handling with statistics / \n   * try {\n   *   const stats = await heatbox.createFromEntities(entities);\n   *   if (stats.renderedVoxels === 0) {\n   *     console.warn('No voxels were rendered - check data distribution');\n   *   }\n   * } catch (error) {\n   *   console.error('Failed to create heatmap:', error);\n   * }\n   * \n   * @since v0.1.0\n   * @see {@link setData} For data processing without returning statistics\n   * @see {@link getStatistics} For retrieving statistics after rendering\n   */\n  async createFromEntities(entities) {\n    if (!isValidEntities(entities)) {\n      throw new Error(ERROR_MESSAGES.NO_ENTITIES);\n    }\n    await this.setData(entities);\n    return this.getStatistics();\n  }\n\n  /**\n   * Control heatmap visibility without clearing data or re-rendering.\n   * \n   * \n   * This method efficiently toggles the visibility of all rendered voxels\n   * by setting the 'show' property on Cesium entities. The underlying data\n   * and voxel grid remain intact, allowing for fast show/hide operations.\n   * \n   * Cesium'show'\n   * \n   * /\n   * \n   * @param {boolean} show - Whether to show the heatmap (true) or hide it (false) / truefalse\n   * @returns {void}\n   * \n   * @example\n   * // Show heatmap / \n   * heatbox.setVisible(true);\n   * \n   * @example\n   * // Hide heatmap temporarily / \n   * heatbox.setVisible(false);\n   * // ... other operations ...\n   * heatbox.setVisible(true); // Show again quickly\n   * \n   * @example\n   * // Toggle visibility based on user interaction / \n   * const toggleButton = document.getElementById('toggleHeatmap');\n   * let isVisible = true;\n   * toggleButton.onclick = () => {\n   *   isVisible = !isVisible;\n   *   heatbox.setVisible(isVisible);\n   *   toggleButton.textContent = isVisible ? 'Hide' : 'Show';\n   * };\n   * \n   * @since v0.1.0\n   * @see {@link clear} For permanently removing the heatmap\n   */\n  setVisible(show) {\n    this.renderer.setVisible(show);\n  }\n\n  /**\n   * Completely clear heatmap visualization and reset internal state.\n   * \n   * \n   * This method removes all rendered voxel entities from the Cesium viewer and\n   * resets all internal data structures (bounds, grid, voxel data, statistics).\n   * After calling this method, the Heatbox instance returns to its initial state\n   * and is ready to process new data.\n   * \n   * Cesium\n   * \n   * Heatbox\n   * \n   * @returns {void}\n   * \n   * @example\n   * // Clear current heatmap before loading new data / \n   * heatbox.clear();\n   * await heatbox.setData(newEntities);\n   * \n   * @example\n   * // Clean up when component is destroyed / \n   * const cleanup = () => {\n   *   heatbox.clear();\n   *   heatbox.destroy(); // Final cleanup\n   * };\n   * \n   * @example\n   * // Reset to initial state for reuse / \n   * heatbox.clear();\n   * console.log(heatbox.getBounds()); // null - no data loaded\n   * console.log(heatbox.getStatistics()); // null - no statistics available\n   * \n   * @since v0.1.0\n   * @see {@link setVisible} For temporary hiding without clearing data\n   * @see {@link destroy} For final cleanup including event handlers\n   */\n  clear() {\n    this.renderer.clear();\n    this._bounds = null;\n    this._grid = null;\n    this._voxelData = null;\n    this._statistics = null;\n  }\n\n  /**\n   * Destroy the instance and release event listeners.\n   * \n   */\n  destroy() {\n    this.clear();\n    if (this._eventHandler && !this._eventHandler.isDestroyed()) {\n      this._eventHandler.destroy();\n    }\n    this._eventHandler = null;\n  }\n\n  /**\n   * Alias for destroy() to match examples and tests.\n   * destroy() \n   */\n  dispose() {\n    this.destroy();\n  }\n\n  /**\n   * Get current options.\n   * \n   * @returns {Object} Options / \n   */\n  getOptions() {\n    return { ...this.options };\n  }\n\n  /**\n   * Update heatbox configuration options and automatically re-render if data exists.\n   * \n   * \n   * This method merges new options with existing configuration and triggers \n   * automatic re-rendering when data is already loaded. Options are validated\n   * and normalized before application.\n   * \n   * \n   * \n   * \n   * @param {Object} newOptions - Configuration options to update / \n   * @param {number} [newOptions.voxelSize] - Voxel size in meters / \n   * @param {number} [newOptions.opacity] - Base opacity (0-1) / 0-1\n   * @param {boolean} [newOptions.showOutline] - Whether to show voxel outlines / \n   * @param {string} [newOptions.colorMap] - Color map type ('custom', 'viridis', 'inferno') / \n   * @param {number} [newOptions.highlightTopN] - Number of top voxels to highlight / \n   * @param {boolean} [newOptions.adaptiveOutlines] - Enable adaptive outline control / \n   * @throws {Error} Throws error if options validation fails / \n   * @returns {void}\n   * \n   * @example\n   * // Update color settings / \n   * heatbox.updateOptions({\n   *   colorMap: 'viridis',\n   *   opacity: 0.9,\n   *   highlightTopN: 50\n   * });\n   * \n   * @example\n   * // Enable adaptive features / \n   * heatbox.updateOptions({\n   *   adaptiveOutlines: true,\n   *   outlineWidthPreset: 'adaptive-density'\n   * });\n   * \n   * @since v0.1.0\n   */\n  updateOptions(newOptions) {\n    this.options = validateAndNormalizeOptions({ ...this.options, ...newOptions });\n    this.renderer.options = this.options;\n    \n    // \n    if (this._voxelData) {\n      const renderedVoxelCount = this.renderer.render(this._voxelData, this._bounds, this._grid, this._statistics);\n      // \n      this._statistics.renderedVoxels = renderedVoxelCount;\n    }\n  }\n\n  /**\n   * Initialize internal event listeners.\n   * \n   * @private\n   */\n  _initializeEventListeners() {\n    this._eventHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);\n\n    // InfoBox\n    this._eventHandler.setInputAction(movement => {\n      const pickedObject = this.viewer.scene.pick(movement.position);\n      if (Cesium.defined(pickedObject) && pickedObject.id && \n          pickedObject.id.properties && \n          pickedObject.id.properties.type === 'voxel') {\n        // \n        const voxelKey = pickedObject.id.properties.key;\n        const voxelInfo = {\n          x: pickedObject.id.properties.x,\n          y: pickedObject.id.properties.y,\n          z: pickedObject.id.properties.z,\n          count: pickedObject.id.properties.count\n        };\n        \n        // InfoBox\n        const dummyEntity = new Cesium.Entity({\n          id: `voxel-${voxelKey}`,\n          description: this.renderer.createVoxelDescription(voxelInfo, voxelKey)\n        });\n        this.viewer.selectedEntity = dummyEntity;\n      }\n    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);\n  }\n\n  /**\n   * Get statistics information.\n   *  null\n   * @returns {Object|null} Statistics or null /   null\n   */\n  getStatistics() {\n    if (!this._statistics) {\n      return null;\n    }\n\n    // \n    const stats = { ...this._statistics };\n\n    // v0.1.9: \n    const selectionStats = this.renderer.getSelectionStats();\n    if (selectionStats) {\n      stats.selectionStrategy = selectionStats.strategy;\n      stats.clippedNonEmpty = selectionStats.clippedNonEmpty;\n      stats.coverageRatio = selectionStats.coverageRatio ?? 0;\n    }\n\n    // v0.1.9: Auto Render Budget\n    if (this.options._autoRenderBudget) {\n      stats.renderBudgetTier = this.options._autoRenderBudget.tier;\n      stats.autoMaxRenderVoxels = this.options._autoRenderBudget.autoMaxRenderVoxels;\n    }\n\n    // v0.1.9: occupancy ratio (rendered / budget) for diagnostics\n    if (typeof this.options.maxRenderVoxels === 'number' && this.options.maxRenderVoxels > 0) {\n      stats.occupancyRatio = Math.min(1, Math.max(0, (stats.renderedVoxels || 0) / this.options.maxRenderVoxels));\n    } else {\n      stats.occupancyRatio = null;\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get bounds info if available.\n   *  null\n   * @returns {Object|null} Bounds or null /   null\n   */\n  getBounds() {\n    return this._bounds;\n  }\n\n  /**\n   * Get debug information.\n   * \n   * @returns {Object} Debug info / \n   */\n  getDebugInfo() {\n    const baseInfo = {\n      options: { ...this.options },\n      bounds: this._bounds,\n      grid: this._grid,\n      statistics: this._statistics\n    };\n    \n    // v0.1.4: \n    if (this.options.autoVoxelSize) {\n      baseInfo.autoVoxelSizeInfo = {\n        enabled: this.options.autoVoxelSize,\n        originalSize: this._statistics?.originalVoxelSize,\n        finalSize: this._statistics?.finalVoxelSize,\n        adjusted: this._statistics?.autoAdjusted || false,\n        reason: this._statistics?.adjustmentReason,\n        dataRange: this._bounds ? calculateDataRange(this._bounds) : null,\n        estimatedDensity: this._bounds && this._statistics ? \n          this._statistics.totalEntities / (calculateDataRange(this._bounds).x * calculateDataRange(this._bounds).y * calculateDataRange(this._bounds).z) : null\n      };\n    }\n    \n    return baseInfo;\n  }\n\n  /**\n   * Automatically fit camera view to data bounds with intelligent positioning.\n   * \n   * \n   * This method calculates optimal camera position and orientation to view the entire\n   * heatmap data with appropriate padding and viewing angle. Uses smart algorithms to\n   * avoid extreme camera positions and ensure good visibility.\n   * \n   * \n   * \n   * \n   * \n   * @param {Object} [bounds] - Target bounds to fit to (uses current data bounds if omitted) / \n   * @param {number} bounds.minLon - Minimum longitude in degrees / \n   * @param {number} bounds.maxLon - Maximum longitude in degrees / \n   * @param {number} bounds.minLat - Minimum latitude in degrees / \n   * @param {number} bounds.maxLat - Maximum latitude in degrees / \n   * @param {number} bounds.minAlt - Minimum altitude in meters / \n   * @param {number} bounds.maxAlt - Maximum altitude in meters / \n   * @param {Object} [options={}] - Camera positioning options / \n   * @param {number} [options.paddingPercent=0.1] - Padding around data as percentage (0-1) / 0-1\n   * @param {number} [options.pitchDegrees=-45] - Camera pitch angle in degrees / \n   * @param {number} [options.headingDegrees=0] - Camera heading angle in degrees / \n   * @param {number} [options.duration=2.0] - Animation duration in seconds / \n   * @returns {Promise<void>} Promise that resolves when camera animation completes / Promise\n   * @throws {Error} Throws error if no bounds available for fitting / \n   * \n   * @example\n   * // Fit to current data bounds / \n   * await heatbox.fitView();\n   * \n   * @example\n   * // Custom camera angle and padding /   \n   * await heatbox.fitView(null, {\n   *   pitchDegrees: -60,      // 60\n   *   headingDegrees: 45,     // 45\n   *   paddingPercent: 0.2,    // 20%\n   *   duration: 3.0           // 3\n   * });\n   * \n   * @example\n   * // Typical fitViewOptions patterns / fitViewOptions\n   * \n   * // Pattern 1: Top-down view / \n   * await heatbox.fitView(bounds, {\n   *   pitchDegrees: -90,      // \n   *   headingDegrees: 0,      // \n   *   paddingPercent: 0.1\n   * });\n   * \n   * // Pattern 2: Diagonal overview / \n   * await heatbox.fitView(bounds, {\n   *   pitchDegrees: -45,      // 45\n   *   headingDegrees: 135,    // \n   *   paddingPercent: 0.15\n   * });\n   * \n   * // Pattern 3: Close inspection / \n   * await heatbox.fitView(bounds, {\n   *   pitchDegrees: -30,      // \n   *   headingDegrees: 0,\n   *   paddingPercent: 0.05,   // \n   *   duration: 1.0           // \n   * });\n   * \n   * @example\n   * // Fit to specific bounds / \n   * const customBounds = {\n   *   minLon: 139.7, maxLon: 139.8,\n   *   minLat: 35.6, maxLat: 35.7,\n   *   minAlt: 0, maxAlt: 100\n   * };\n   * await heatbox.fitView(customBounds);\n   * \n   * @since v0.1.9\n   */\n  async fitView(bounds = null, options = {}) {\n    try {\n      const targetBounds = bounds || this._bounds;\n      if (!targetBounds) {\n        Logger.warn('No bounds available for fitView');\n        return;\n      }\n\n      // Merge with default fit view options\n      const fitOptions = {\n        ...this.options.fitViewOptions,\n        ...options\n      };\n\n      Logger.debug('fitView called with bounds:', targetBounds, 'options:', fitOptions);\n\n      // Map option names and delegate to ViewFitter\n      const mapped = {\n        paddingPercent: fitOptions.paddingPercent,\n        pitchDegrees: fitOptions.pitch ?? fitOptions.pitchDegrees,\n        headingDegrees: fitOptions.heading ?? fitOptions.headingDegrees,\n        duration: fitOptions.duration,\n        maximumHeight: fitOptions.maximumHeight,\n        minimumHeight: fitOptions.minimumHeight\n      };\n      return await ViewFitter.fitToBounds(this.viewer, targetBounds, mapped);\n\n    } catch (error) {\n      Logger.error('fitView failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Filter entity array (utility static method).\n   * \n   * @param {Cesium.Entity[]} entities - Entity array / \n   * @param {Function} predicate - Predicate function / \n   * @returns {Cesium.Entity[]} Filtered array / \n   */\n  static filterEntities(entities, predicate) {\n    if (!Array.isArray(entities) || typeof predicate !== 'function') return [];\n    return entities.filter(predicate);\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE__50__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","DEFAULT_OPTIONS","voxelSize","opacity","emptyOpacity","showOutline","showEmptyVoxels","minColor","maxColor","maxRenderVoxels","batchMode","debug","autoVoxelSize","colorMap","diverging","divergingPivot","highlightTopN","highlightStyle","outlineWidth","boostOpacity","voxelGap","outlineOpacity","outlineInset","outlineInsetMode","enableThickFrames","outlineRenderMode","adaptiveOutlines","outlineWidthPreset","adaptiveParams","neighborhoodRadius","densityThreshold","cameraDistanceFactor","overlapRiskFactor","renderLimitStrategy","minCoverageRatio","coverageBinsXY","autoVoxelSizeMode","autoVoxelTargetFill","renderBudgetMode","autoView","fitViewOptions","paddingPercent","pitchDegrees","headingDegrees","altitudeStrategy","PERFORMANCE_LIMITS","ERROR_MESSAGES","Math","PI","currentLogLevel","process","env","DEBUG","Logger","error","args","console","warn","info","log","setLogLevel","options","VoxelSizeEstimator","estimate","data","bounds","mode","entityCount","length","estimateByOccupancy","estimateBasic","dataRange","calculateDataRange","volume","x","y","max","z","density","estimatedSize","min","sqrt","round","targetFill","currentSize","iteration","totalVoxels","ceil","expectedOccupied","exp","currentFill","toFixed","abs","pow","finalSize","minLon","west","maxLon","east","minLat","south","maxLat","north","minAlt","minimumHeight","maxAlt","maximumHeight","centerLat","lonRangeMeters","cos","latRangeMeters","altRangeMeters","getEstimationMetadata","densityCategory","isValidEntities","entities","Array","isArray","validateAndNormalizeOptions","normalized","isNaN","Error","map","c","floor","includes","parseFloat","v","inset","Boolean","n","parseInt","Number","isFinite","f","padding","pitch","heading","DEVICE_TIER_RANGES","low","mid","high","DeviceTierDetector","detect","webglInfo","_getWebGLInfo","deviceInfo","_getDeviceInfo","tier","detectionMethod","deviceMemory","hardwareConcurrency","adjustedScore","screenPixels","maxTextureSize","webgl2","range","metadata","tierRange","message","applyAutoRenderBudget","detection","updatedOptions","_autoRenderBudget","autoMaxRenderVoxels","document","createElement","maxRenderbufferSize","canvas","getContext","gl","getParameter","MAX_TEXTURE_SIZE","MAX_RENDERBUFFER_SIZE","remove","navigator","dpr","window","devicePixelRatio","width","screen","height","nav","userAgent","CoordinateTransformer","calculateBounds","Infinity","validCount","currentTime","Cesium","now","forEach","entity","index","position","getValue","cartographic","fromCartesian","lon","toDegrees","longitude","lat","latitude","alt","centerLon","centerAlt","voxelIndexToCoordinate","grid","numVoxelsX","numVoxelsY","numVoxelsZ","coordinateToCartesian3","fromDegrees","VoxelGrid","createGrid","voxelSizeMeters","cellSizeX","cellSizeY","cellSizeZ","getVoxelKey","parseVoxelKey","split","iterateAllVoxels","callback","DataProcessor","classifyEntitiesIntoVoxels","voxelData","Map","processedCount","skippedCount","lonDen","latDen","altDen","voxelX","voxelY","voxelZ","voxelKey","has","set","count","voxelInfo","push","size","calculateStatistics","renderedVoxels","nonEmptyVoxels","emptyVoxels","totalEntities","minCount","maxCount","averageCount","autoAdjusted","originalVoxelSize","finalVoxelSize","adjustmentReason","counts","from","values","voxel","reduce","sum","stats","getTopNVoxels","topN","sortedVoxels","sort","a","b","slice","SelectionStrategyInterface","select","allVoxels","_forceInclude","Set","_options","getStrategyName","validateOptions","DensitySelectionStrategy","forceInclude","sorted","selected","included","add","selectedCount","clippedCount","strategy","forceIncludedCount","densityRange","CoverageSelectionStrategy","_addForceIncludedVoxels","_createResult","remainingVoxels","filter","binsXY","_calculateOptimalBinCount","bins","_createSpatialBins","_selectFromBins","totalBins","targetCount","calculatedBins","voxels","maxX","maxY","binKey","binKeys","keys","binIndex","maxIterations","binVoxels","_selectBestVoxelFromBin","voxelIndex","indexOf","splice","delete","keyIndex","binSelectionMode","random","additionalMetadata","totalSelected","selectionRatio","HybridSelectionStrategy","constructor","super","densityStrategy","coverageStrategy","coverageRatio","_determineCoverageRatio","remainingCount","coverageCount","densityCount","actualCoverageCount","_executeCoverageSelection","actualDensityCount","_executeDensitySelection","availableVoxels","coverageOptions","hybridCoverageMode","coverageResult","addedCount","densityOptions","selectionMode","hybridDensityMode","densityResult","totalSelectionCount","coverageSelected","densitySelected","targetCoverageRatio","COLOR_MAPS","viridis","inferno","ColorMap","interpolateColor","normalizedDensity","rawValue","_interpolateDivergingColor","_interpolateFromColorMap","minR","minG","minB","maxR","maxG","maxB","r","g","fromBytes","normalizedValue","colorMapName","scaledValue","lowerIndex","upperIndex","fraction","lowerR","lowerG","lowerB","upperR","upperG","upperB","pivot","getAvailableColorMaps","hasColorMap","VoxelEntityFactory","createBoxEntity","config","dimensions","color","wireframe","outline","properties","description","entityConfig","box","show","outlineColor","WHITE","type","material","TRANSPARENT","fill","withAlpha","createPolylineEntity","positions","polyline","arcType","NONE","createBoxEdgePolylines","centerCart","sizeX","sizeY","sizeZ","halfX","halfY","halfZ","enu","eastNorthUpToFixedFrame","toWorld","dx","dy","dz","local","multiplyByPoint","corners","i","j","edgeType","createDebugBoundingBox","widthMeters","depthMeters","heightMeters","YELLOW","createInsetOutlinePolylines","insetAmount","insetSizeX","insetSizeY","insetSizeZ","DebugRenderer","viewer","debugEntities","shouldShowBounds","debugOptions","showBounds","renderBoundingBox","boundingBoxConfig","boundingBox","center","depth","renderGridLines","showGrid","renderedLines","gridLine","CYAN","direction","MAGENTA","renderStatsOverlay","showStats","renderTime","memoryUsage","clear","isDestroyed","getEntityCount","logDebugInfo","category","AdaptiveOutlineController","calculateAdaptiveParams","isTopN","statistics","baseOptions","boxOpacity","shouldUseEmulation","neighborDensity","_calculateNeighborhoodDensity","cameraFactor","_calculateCameraDistanceFactor","overlapRisk","_calculateOverlapRisk","_calculateOutlineWidth","_calculateBoxOpacity","_calculateOutlineOpacity","_shouldUseEmulation","result","radius","totalCount","voxelCount","neighbor","camera","voxelPosition","cameraPosition","distance","_viewer","adjacentCount","neighbors","nx","ny","nz","preset","baseWidth","baseOpacity","densityComponent","neighborComponent","cameraComponent","renderMode","updateOptions","newOptions","OutlineRenderer","renderOutline","outlineOptions","adaptive","_shouldApplyInsetOutline","_renderInsetOutline","_renderEmulationOutline","_renderStandardOutline","maxInsetX","maxInsetY","maxInsetZ","effInsetX","effInsetY","effInsetZ","boxEntity","parentKey","insetSize","emulationWidth","polylineEntities","_createInsetVoxelInfo","insetValue","insetMode","insetVoxelInfo","original","offset","shouldRenderOutline","getOutlineColor","DescriptionBuilder","fontFamily","containerPadding","headerMargin","tableWidth","createVoxelDescription","createExtendedVoxelDescription","baseDescription","statsSection","percentile","rank","total","replace","createCustomVoxelDescription","customFields","customRows","field","label","value","join","VoxelGeometry","calculateVoxelCenter","altitude","calculateVoxelPosition","calculateVoxelSizes","baseCellSizeZ","calculateAdjustedHeight","baseSizeZ","heightBased","calculateVoxelDimensions","sizes","adjustedHeight","calculateBoundsCenter","calculateBoundsCenterPosition","VoxelRenderingEngine","entityFactory","renderVoxels","displayVoxels","topNVoxels","outlineRenderer","_adaptiveOutlineController","LIGHTGRAY","boxOpacityResolver","resolverCtx","resolverOpacity","e","dims","adjustedAlt","outlineWidthResolver","resolverWidth","wireframeOnly","id","voxelInfoWithPosition","processDisplayVoxels","selectVoxelsForRendering","maxVoxels","entries","selectionResult","selectedVoxels","clippedNonEmpty","VoxelEntityManager","voxelEntities","addEntity","setVisible","createInsetOutline","baseSizeX","baseSizeY","actualInset","insetX","insetY","insetZ","finalInsetX","finalInsetY","finalInsetZ","insetDimensions","insetEntity","createThickOutlineFrames","outerX","outerY","outerZ","innerX","innerY","innerZ","frameColor","frameEntities","frameThickness","frame","frameEntity","shouldApplyInsetOutline","getEntityStats","activeEntities","VoxelRenderer","outlineOpacityResolver","_initializeSelectionStrategies","debugRenderer","adaptiveOutlineController","descriptionBuilder","renderingEngine","entityManager","_selectionStrategies","coverage","hybrid","_calculateAdaptiveParams","render","voxelDataSize","_selectVoxelsForRendering","bind","_selectionStats","_shouldShowBounds","voxelSelectionStrategy","hybridResult","getSelectionStats","ViewFitter","fitToBounds","_isValidBounds","Promise","resolve","fitOptions","duration","_calculateDataRange","maxRange","_handleMinimalDataRange","_handleLargeDataRange","_executeStandardFit","cosLat","fixedHeight","_executeCameraMovement","destination","orientation","toRadians","roll","rectangle","cameraOptions","reject","flyTo","complete","cancel","paddingMeters","cameraHeight","_calculateOptimalCameraHeight","fovRadians","pitchRadians","tan","flyToOptions","createRectangleFromBounds","calculateCameraPosition","viewOptions","scene","isValidViewer","mergedOptions","renderer","viewFitter","_bounds","_grid","_voxelData","_statistics","_eventHandler","_initializeEventListeners","setData","autoAdjustmentInfo","sizeOptions","tempGrid","validation","valid","warning","recommendedSize","validateVoxelCount","enabled","originalSize","adjusted","reason","renderedVoxelCount","fitView","createFromEntities","getStatistics","destroy","dispose","getOptions","setInputAction","movement","pickedObject","pick","dummyEntity","selectedEntity","LEFT_CLICK","selectionStats","selectionStrategy","renderBudgetTier","occupancyRatio","getBounds","getDebugInfo","baseInfo","autoVoxelSizeInfo","estimatedDensity","targetBounds","mapped","filterEntities","predicate"],"sourceRoot":""}