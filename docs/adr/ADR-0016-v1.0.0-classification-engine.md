# ADR-0016: v1.0.0 基本分類エンジンと統計ライブラリ方針

## Status
Proposed — 2025-11-18

## Context

### v1.0.0 における分類スコープ
ROADMAP に示されているとおり、v1.0.0 では「最小の分類エンジン」を導入し、対象は **color のみ** に限定する。

- 対応スキーム（v1.0.0 時点）
  - `linear`（既定）
  - `log`
  - `equal-interval`
  - `quantize`
  - `threshold`
- v1.1.0 以降に拡張予定のスキーム
  - `quantile`
  - `jenks`
- 対象プロパティ
  - v1.0.0: `classificationTargets` のうち `color` のみ有効
  - v1.1.0: `opacity` / `width` への拡張と凡例連携を予定

実装場所は ROADMAP の方針どおり `src/utils/classification.js` とし、`AdaptiveController` から利用可能な純粋関数ベースのユーティリティとして提供する。

### 既存の挙動と互換性要件
- 現行 0.1 系では色は主に「統計 + カラーマップ」の組み合わせで制御されており、分類は明示的な API としては提供されていない。
- `boxOpacityResolver` / `outlineOpacityResolver` / `outlineWidthResolver` などの Resolver 群は存続が明示されており、**少なくとも v1.1.0 の AdaptiveController 拡張が安定するまで削除しない** 方針となっている。
- v1.0.0 の分類エンジン導入にあたっても、既存のデフォルト色表現に視覚的な退行がないこと（±10% 程度の差異に収まること）が Acceptance Criteria として定義されている。

このため、v1.0.0 では以下を満たす必要がある。

1. 既存のデフォルト設定に対して分類を無効または「従来と同等」の挙動とし、破壊的変更を避ける。
2. v1.1.0 で `classificationTargets.opacity/width` を拡張しても API の破壊的変更を行わずに済むよう、設計段階で拡張性を確保する。
3. 将来の `quantile` / `jenks` / `gamma` / `easing` などの追加に耐えられるモジュール構造とする。

### 統計・分類ライブラリ利用の検討背景
ROADMAP では v1.1.0 で `quantile` と `jenks` を追加することが明記されている。これらは単純な線形変換や等間隔分割よりも実装・性能ともに負荷が高く、以下の観点から **既存の統計ライブラリを活用する選択肢** が有力である。

- `quantile`:
  - ソート済み配列を前提としたパーセンタイル計算ロジックが必要。
  - 外れ値・NaN の扱いなどで設計判断が伴う。
- `jenks`（Jenks natural breaks / ckmeans）:
  - 動的計画法ベースのアルゴリズムが一般的であり、自前実装はバグリスクとメンテコストが高い。
  - データサイズによってはパフォーマンスへの配慮が必要。

一方で、v1.0.0 のスコープ（linear/log/equal-interval/quantize/threshold）は比較的単純であり、**自前実装でも安全かつ軽量に実現可能** である。

本 ADR では、以下を整理する。

1. v1.0.0 での分類エンジンの構造と、採用する統計ライブラリ。
2. v1.1.0 以降で `quantile` / `jenks` を実装する際の拡張方針。
3. それらを見越した API/実装の拡張性確保。

## Decision

### 1. v1.0.0 から `simple-statistics` を「内部バックエンド」として採用する
v1.0.0 では、分類 API の表面仕様は ROADMAP のとおり最小スキームに限定しつつ、内部実装として **`simple-statistics` を統計バックエンドとして採用** する。

- 採用理由（`simple-statistics`）
  - ISC ライセンスであり、商用利用を含めて扱いやすい（MIT 相当の緩やかな許諾条件）。
  - quantile 系・分布系・クラスタリング（ckmeans）および Jenks アルゴリズムなど、v1.1.0 以降で必要になる統計処理が一通り揃っている。
  - 依存関係が少なく、ライブラリ自体も比較的軽量である。
  - モジュール単位のインポートに対応しており、将来的な tree-shaking との相性も良い。

ただし、v1.0.0 のスコープでは ROADMAP に従い `quantile` / `jenks` を **API としては解放しない**。  
`simple-statistics` は以下のような用途で利用する。

- 値配列からの基本統計（min/max/平均など）の計算。
- 内部的な分布特性把握（後続バージョンでの quantile/jenks 対応の布石）。
- 将来の v1.1.0 で quantile/jenks を有効化した際のバックエンドとして、そのまま再利用可能な構造。

v1.0.0 における分類スキーム（`linear`, `log`, `equal-interval`, `quantize`, `threshold`）自体のロジックは、次の理由から **基本的には自前実装** とする。

- アルゴリズムが単純であり、明示的な数式をコードに残しておく方が挙動を把握しやすい。
- 「v1.0.0 の時点では simple-statistics に依存しなくとも成立する」状態を維持することで、将来ライブラリを差し替える際の自由度を確保する。

このため、`src/utils/classification.js` では以下のような構造を採用する。

```js
// 擬似インターフェイス（型イメージ）
/**
 * @typedef {Object} ClassificationOptions
 * @property {'linear'|'log'|'equal-interval'|'quantize'|'threshold'|'quantile'|'jenks'} scheme
 * @property {number[]} [values]   // 生データ（必要に応じて）
 * @property {number[]} [domain]   // [min, max]。未指定時は values から算出
 * @property {number}   [classes]  // クラス数（quantize/equal-interval/quantile/jenks など）
 * @property {number[]} [thresholds] // threshold 用の境界配列
 */

/**
 * 分類コンテキストを構築し、値→クラスの対応を表現する
 * @param {ClassificationOptions} options
 * @returns {{ classify: (value: number) => number, breaks: number[], domain: [number,number] }}
 */
export function createClassifier (options) { /* ... */ }
```

- `createClassifier` は指定されたスキームに応じて内部で適切な分割点（`breaks`）を計算し、`classify(value)` でクラスインデックスを返す。
- v1.0.0 時点では `quantile` / `jenks` は **スキームとしては予約するが未実装** とし、利用時には明示的なエラーまたはフォールバック（例: `linear`）とする。
- `AdaptiveController` は color の補間において `createClassifier` を利用し、得られたクラスインデックスや正規化値をカラーマップに変換する。

### 2. 「統計バックエンド」インターフェイスを用意し、外部ライブラリを差し替え可能にする
v1.0.0 の段階で、`src/utils/classification.js` には以下のような「統計バックエンド」インターフェイスを導入し、将来のライブラリ差し替えを容易にする。

```js
// classification.js 内で使用するバックエンドの型イメージ
/**
 * @typedef {Object} ClassificationStatsBackend
 * @property {(values: number[], p: number) => number} quantile
 * @property {(values: number[], k: number) => number[]} jenksBreaks
 */

// v1.0.0 時点のバックエンド初期化イメージ
import * as ss from 'simple-statistics';

let backend = {
  quantile (values, p) {
    return ss.quantileSorted([...values].sort((a, b) => a - b), p);
  },
  jenksBreaks (values, k) {
    // v1.0.0ではまだ公開スキームとして利用しないが、
    // v1.1.0での jenks 実装のために内部的に利用可能にしておく。
    return ss.ckmeans(values, k).map(cluster => cluster[0]);
  }
};

export function setClassificationBackend (nextBackend) {
  backend = { ...backend, ...nextBackend };
}
```

- v1.0.0:
  - `quantile` / `jenks` スキームは **API としては未解放** とし、`createClassifier` からは選択できない。
  - ただし、バックエンドとして `simple-statistics` をすでに導入しておき、バンドル構成や依存関係を早期に安定させる。
- v1.1.0:
  - `createClassifier` に `quantile` / `jenks` を追加し、上記バックエンドを直接利用する。
  - 将来、別の統計ライブラリに切り替える場合は `setClassificationBackend` でアダプタを差し替えるだけで済む。

### 3. AdaptiveController との連携方針
- v1.0.0:
  - `AdaptiveController` は color に対してのみ `classification` 設定を尊重する。
  - `normalizedDensity` から得た値を `createClassifier` に渡し、クラスインデックスまたは [0, 1] の正規化値としてカラーマップに変換する。
  - `opacity` / `width` については、既存の Resolver と `adaptiveParams.*Range` は **クランプと基礎設定のみ** を担い、分類とは連動させない。
- v1.1.0:
  - `AdaptiveController` が color/opacity/width を共通の classification ユーティリティで補間するように拡張する（別 ADR で詳細定義）。

## Alternatives considered（検討した代替案）

### d3-array（+ d3-scale 等）
- 利点
  - `d3-array` は quantile / quantileSorted / bin（旧 histogram）など、分位点・ヒストグラム周りのユーティリティが充実している。
  - D3 エコシステムとして長期的にメンテナンスされており、品質と安定性には定評がある。
- 採用しなかった理由
  - コアの `d3-array` 自体には Jenks natural breaks や ckmeans が含まれておらず、natural breaks を実現するには別ライブラリや自前実装が必要になる。
  - 現状の Heatbox では D3 への依存がなく、「分類エンジンのためだけに D3 系依存を追加する」ことは依存コストに見合わないと判断した。

### geostats.js 系（GIS 向け分類ライブラリ）
- 利点
  - quantile / equal-interval / standard deviation / Jenks（natural breaks）など、地理統計でよく使われる分類スキームを 1 パッケージで提供している。
- 採用しなかった理由
  - 主な利用形態が `<script src="...">` によるグローバルオブジェクト（`geostats`）であり、モダンな ESM / tree-shaking 前提のバンドル構成とは相性が良くない。
  - npm パッケージとしても利用可能ではあるが、ESM / 型情報 / ツリーシェイク前提で「そのまま import して使う」には追加のラッパーや設定調整が必要になり、メンテコストが増えると判断した。

## Consequences

### メリット
- v1.0.0:
  - `simple-statistics` を早期に導入することで、将来の quantile/jenks 実装に必要な統計計算基盤を先に安定させられる。
  - シンプルなスキームは自前実装で十分に安全・高速であり、バンドルサイズへの影響も小さい。
  - `createClassifier` / `setClassificationBackend` の導入により、将来の `quantile` / `jenks` / `gamma` / `easing` 拡張に備えた柔軟な構造になる。
- v1.1.0 以降:
  - quantile/jenks のような高度スキームは、実績のある統計ライブラリ（simple-statistics）に委譲することで、実装負荷とバグリスクを低減できる。
  - バックエンド差し替え型の設計により、将来別ライブラリへ切り替えたくなった場合も ADR 1 枚で再定義しやすい。

### デメリット・トレードオフ
- v1.0.0 時点では quantile/jenks が利用できず、ユーザーは linear/log/equal-interval/quantize/threshold のみを使用することになる（ROADMAP 準拠）。
- 統計バックエンドを抽象化することで、実装がやや間接的になり、理解コストが少し上がる。
- `simple-statistics` を導入する分だけバンドルサイズが増加するが、v1.1.0 以降で必須となるコストを前倒しで支払う形になる。

### マイグレーション・互換性への影響
- 0.1 系 → v1.0.0:
  - デフォルト設定では分類が導入されても挙動はほぼ従来どおりとなるように設計するため、破壊的変更は発生しない想定。
  - 新しい `classification` オプションを明示的に設定した場合のみ、新機能としての分類が有効になる。
- v1.0.0 → v1.1.0:
  - `classificationTargets.opacity/width` を有効化しない限り動作は変わらない。
  - quantile/jenks を追加しても `createClassifier` の外部 API は維持する。
  - 実装詳細として、バックエンドに外部ライブラリを導入した場合でも、パブリック API は変更しない。

以上により、v1.0.0 では **最小限かつ拡張可能な分類エンジン** を自前実装で提供し、v1.1.0 以降で quantile / jenks を含む高度スキームについて **既存統計ライブラリを活用する前提** を明示する。
