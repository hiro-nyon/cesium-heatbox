# ADR-0016: v1.0.0 基本分類エンジンと統計ライブラリ方針

## Status
Proposed — 2025-11-18

## Context

### v1.0.0 における分類スコープ
ROADMAP に示されているとおり、v1.0.0 では「最小の分類エンジン」を導入し、対象は **color のみ** に限定する。

- 対応スキーム（v1.0.0 時点）
  - `linear`（既定）
  - `log`
  - `equal-interval`
  - `quantize`
  - `threshold`
- v1.1.0 以降に拡張予定のスキーム
  - `quantile`
  - `jenks`
- 対象プロパティ
  - v1.0.0: `classificationTargets` のうち `color` のみ有効
  - v1.1.0: `opacity` / `width` への拡張と凡例連携を予定

実装場所は ROADMAP の方針どおり `src/utils/classification.js` とし、`AdaptiveController` から利用可能な純粋関数ベースのユーティリティとして提供する。

### 既存の挙動と互換性要件
- 現行 0.1 系では色は主に「統計 + カラーマップ」の組み合わせで制御されており、分類は明示的な API としては提供されていない。
- `boxOpacityResolver` / `outlineOpacityResolver` / `outlineWidthResolver` などの Resolver 群は存続が明示されており、**少なくとも v1.1.0 の AdaptiveController 拡張が安定するまで削除しない** 方針となっている。
- v1.0.0 の分類エンジン導入にあたっても、既存のデフォルト色表現に視覚的な退行がないこと（±10% 程度の差異に収まること）が Acceptance Criteria として定義されている。

このため、v1.0.0 では以下を満たす必要がある。

1. 既存のデフォルト設定に対して分類を無効または「従来と同等」の挙動とし、破壊的変更を避ける。
2. v1.1.0 で `classificationTargets.opacity/width` を拡張しても API の破壊的変更を行わずに済むよう、設計段階で拡張性を確保する。
3. 将来の `quantile` / `jenks` / `gamma` / `easing` などの追加に耐えられるモジュール構造とする。

### 統計・分類ライブラリ利用の検討背景
ROADMAP では v1.1.0 で `quantile` と `jenks` を追加することが明記されている。これらは単純な線形変換や等間隔分割よりも実装・性能ともに負荷が高く、以下の観点から **既存の統計ライブラリを活用する選択肢** が有力である。

- `quantile`:
  - ソート済み配列を前提としたパーセンタイル計算ロジックが必要。
  - 外れ値・NaN の扱いなどで設計判断が伴う。
- `jenks`（Jenks natural breaks / ckmeans）:
  - 動的計画法ベースのアルゴリズムが一般的であり、自前実装はバグリスクとメンテコストが高い。
  - データサイズによってはパフォーマンスへの配慮が必要。

一方で、v1.0.0 のスコープ（linear/log/equal-interval/quantize/threshold）は比較的単純であり、**自前実装でも安全かつ軽量に実現可能** である。

本 ADR では、以下を整理する。

1. v1.0.0 での分類エンジンの構造と、自前実装にする部分。
2. v1.1.0 以降で `quantile` / `jenks` を実装する際のライブラリ活用方針（候補と選定基準）。
3. それらを見越した API/実装の拡張性確保。

なお、実行環境ではインターネット検索が制限されているため、ライブラリ候補の具体例は 2024-10 時点で一般的な JavaScript エコシステムの知見に基づく。

## Decision

### 1. v1.0.0 では「軽量な自前実装 + 拡張可能な設計」を採用する
v1.0.0 における分類スキーム（`linear`, `log`, `equal-interval`, `quantize`, `threshold`）は、次の理由から **自前実装** とする。

- アルゴリズムが単純であり、数十行〜数百行程度の範囲で安全に実装可能。
- ランタイム依存を追加せずに済み、バンドルサイズや依存関係の複雑性を抑えられる。
- 将来、外部ライブラリに切り替える場合でも、分類ユーティリティを薄いファサードとしておけば内部実装を差し替えやすい。

このため、`src/utils/classification.js` では以下のような構造を採用する。

```js
// 擬似インターフェイス（型イメージ）
/**
 * @typedef {Object} ClassificationOptions
 * @property {'linear'|'log'|'equal-interval'|'quantize'|'threshold'|'quantile'|'jenks'} scheme
 * @property {number[]} [values]   // 生データ（必要に応じて）
 * @property {number[]} [domain]   // [min, max]。未指定時は values から算出
 * @property {number}   [classes]  // クラス数（quantize/equal-interval/quantile/jenks など）
 * @property {number[]} [thresholds] // threshold 用の境界配列
 */

/**
 * 分類コンテキストを構築し、値→クラスの対応を表現する
 * @param {ClassificationOptions} options
 * @returns {{ classify: (value: number) => number, breaks: number[], domain: [number,number] }}
 */
export function createClassifier (options) { /* ... */ }
```

- `createClassifier` は指定されたスキームに応じて内部で適切な分割点（`breaks`）を計算し、`classify(value)` でクラスインデックスを返す。
- v1.0.0 時点では `quantile` / `jenks` は **スキームとしては予約するが未実装** とし、利用時には明示的なエラーまたはフォールバック（例: `linear`）とする。
- `AdaptiveController` は color の補間において `createClassifier` を利用し、得られたクラスインデックスや正規化値をカラーマップに変換する。

### 2. v1.1.0 での `quantile` / `jenks` 追加時には既存ライブラリの活用を前提とする
`quantile` / `jenks` については、v1.1.0 での実装にあたり **既存の統計ライブラリを積極的に活用する** 方針とする。

ここでは、具体的なライブラリ名を最終決定するのではなく、**選定基準と候補クラス** を定めておく。

#### 選定基準
- ライセンス: MIT / BSD / Apache 2.0 等の OSS ライセンスであること。
- モジュール性:
  - ESM 対応、もしくは bundler（webpack）で問題なく利用可能。
  - 必要な関数のみをインポートでき、tree-shaking が効く構造であること。
- 機能:
  - `quantile(values, p)`（もしくは同等のパーセンタイル API）が提供されている。
  - Jenks natural breaks（動的計画法ベースの ckmeans 相当）が提供されている、または実装例がある。
- 性能:
  - 数千〜数万件程度の値に対して、インタラクティブな可視化のフレームレートを維持できる性能であること。
  - 不要な依存を引き込まず、バンドルサイズの増加を最小限に抑えられること。

#### 代表的な候補クラス（2024-10 頃のエコシステム知見に基づく）
- `simple-statistics`
  - 多様な統計関数を提供する軽量ライブラリで、quantile や ckmeans ベースのクラスタリング実装が存在する。
  - モジュール単位でのインポートが可能で、tree-shaking による不要コードの削減が期待できる。
- `d3-array` / `d3-scale`
  - D3 エコシステムの一部として、quantile / threshold / histogram 等の計算を提供。
  - 必要なサブモジュールのみをインポートする運用であれば、全体としてのバンドルサイズも許容範囲に抑えやすい。
- その他の GIS/統計系ライブラリ（例: geostats.js 系）
  - GIS 向けの分類機能（quantile/jenks 等）を持つが、グローバル汚染や古いビルド形式など、モダンなバンドル環境との相性を個別に評価する必要がある。

実際にどのライブラリを採用するかは、v1.1.0 時点での **具体的なバンドルサイズ・性能・保守性の評価** に基づき、別途 ADR（または PREP-ADR）で確定させる。

### 3. 「統計バックエンド」インターフェイスを用意し、外部ライブラリを差し替え可能にする
v1.0.0 の段階で、`src/utils/classification.js` には以下のような「統計バックエンド」インターフェイスを導入し、将来のライブラリ差し替えを容易にする。

```js
// classification.js 内で使用するバックエンドの型イメージ
/**
 * @typedef {Object} ClassificationStatsBackend
 * @property {(values: number[], p: number) => number} quantile
 * @property {(values: number[], k: number) => number[]} jenksBreaks
 */

// デフォルトバックエンド（v1.0.0 時点）
const defaultBackend = {
  quantile (values, p) {
    throw new Error('quantile scheme is not available in v1.0.0');
  },
  jenksBreaks (values, k) {
    throw new Error('jenks scheme is not available in v1.0.0');
  }
};

let backend = defaultBackend;

export function setClassificationBackend (nextBackend) {
  backend = { ...backend, ...nextBackend };
}
```

- v1.0.0:
  - `quantile` / `jenks` スキームはエラーとし、API としては予約のみ行う。
  - `setClassificationBackend` は実質 no-op に近いが、テストや将来のプレリリースでの実験に利用可能。
- v1.1.0:
  - `simple-statistics` や `d3-array` 等を利用するアダプタを実装し、`setClassificationBackend` 経由で登録する。
  - これにより `createClassifier` の外側の API は変更せずに高度な分類スキームを導入できる。

### 4. AdaptiveController との連携方針
- v1.0.0:
  - `AdaptiveController` は color に対してのみ `classification` 設定を尊重する。
  - `normalizedDensity` から得た値を `createClassifier` に渡し、クラスインデックスまたは [0, 1] の正規化値としてカラーマップに変換する。
  - `opacity` / `width` については、既存の Resolver と `adaptiveParams.*Range` は **クランプと基礎設定のみ** を担い、分類とは連動させない。
- v1.1.0:
  - `AdaptiveController` が color/opacity/width を共通の classification ユーティリティで補間するように拡張する（別 ADR で詳細定義）。

## Consequences

### メリット
- v1.0.0:
  - 依存ライブラリを増やさずに最小分類機能を提供できる。
  - シンプルなスキームは自前実装で十分に安全・高速であり、バンドルサイズへの影響も小さい。
  - `createClassifier` / `setClassificationBackend` の導入により、将来の `quantile` / `jenks` / `gamma` / `easing` 拡張に備えた柔軟な構造になる。
- v1.1.0 以降:
  - quantile/jenks のような高度スキームは、実績のある統計ライブラリに委譲することで、実装負荷とバグリスクを低減できる。
  - バックエンド差し替え型の設計により、ライブラリ選定を変えたくなった場合も ADR 1 枚で再定義しやすい。

### デメリット・トレードオフ
- v1.0.0 時点では quantile/jenks が利用できず、ユーザーは linear/log/equal-interval/quantize/threshold のみを使用することになる。
- 統計バックエンドを抽象化することで、実装がやや間接的になり、理解コストが少し上がる。
- ライブラリ選定を v1.1.0 に先送りするため、その時点で改めてパフォーマンス・バンドルサイズ評価を行う工数が必要になる。

### マイグレーション・互換性への影響
- 0.1 系 → v1.0.0:
  - デフォルト設定では分類が導入されても挙動はほぼ従来どおりとなるように設計するため、破壊的変更は発生しない想定。
  - 新しい `classification` オプションを明示的に設定した場合のみ、新機能としての分類が有効になる。
- v1.0.0 → v1.1.0:
  - `classificationTargets.opacity/width` を有効化しない限り動作は変わらない。
  - quantile/jenks を追加しても `createClassifier` の外部 API は維持する。
  - 実装詳細として、バックエンドに外部ライブラリを導入した場合でも、パブリック API は変更しない。

以上により、v1.0.0 では **最小限かつ拡張可能な分類エンジン** を自前実装で提供し、v1.1.0 以降で quantile / jenks を含む高度スキームについて **既存統計ライブラリを活用する前提** を明示する。

