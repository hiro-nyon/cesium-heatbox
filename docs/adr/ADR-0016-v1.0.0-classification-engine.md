# ADR-0016: v1.0.0 基本分類エンジンと統計ライブラリ方針

**Status**: Proposed  
**Date**: 2025-11-18  
**Author**: hiro-nyon  
**Target Version**: v1.0.0  
**Related**: ROADMAP v1.0.0, ADR-0014 (Layer Aggregation), ADR-0015 (Spatial ID QA)

## Context / 背景

### Problem Statement / 問題提起

現行の Heatbox 0.1 系では、ボクセルの色は主に以下の組み合わせで制御されています:

1. **統計ベースの正規化**: `normalizedDensity` を計算し、`[0, 1]` の値に変換
2. **カラーマップの適用**: Cesium の `Color.lerp` または線形補間でグラデーションを生成
3. **カスタム色解決**: ユーザー定義の `colorResolver` 関数（オプショナル）

この仕組みは単純なグラデーション表現には十分ですが、以下のような **データ可視化で一般的な分類表現** には対応していません:

#### Use Case 1: 対数スケールでの色分類（地震・人口密度）

```javascript
// 現状: 線形補間のみ → 外れ値に引きずられ、大半が同色に
// 期待: 対数スケールで低密度〜高密度を均等に色分け
const heatbox = new Heatbox(viewer, {
  classification: {
    scheme: 'log',
    colorMap: ['blue', 'yellow', 'red']
  }
});
```

**問題**: 東京の人口密度データを可視化した場合、最大値（新宿: 19,000 人/km²）が色スケールを支配し、大半の地域（1,000–5,000 人/km²）が同じ青色になってしまう。対数スケールを使えば、低密度〜中密度〜高密度を均等に色分けできる。

#### Use Case 2: 等間隔・分位数での分類（GIS標準）

```javascript
// 等間隔（equal-interval）: 0–10, 10–20, 20–30, ... で色を変える
const heatbox = new Heatbox(viewer, {
  classification: {
    scheme: 'equal-interval',
    classes: 5,
    colorMap: ['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15']
  }
});

// 分位数（quantile, v1.1.0+）: データを5等分し、各グループで色を変える
const heatbox = new Heatbox(viewer, {
  classification: {
    scheme: 'quantile',
    classes: 5,
    colorMap: ['#ffffcc', '#c2e699', '#78c679', '#31a354', '#006837']
  }
});
```

**問題**: QGIS や ArcGIS では、等間隔・分位数・Jenks などが標準機能として提供されており、これらのツールと同じ色分類を Heatbox でも再現したいという要望が多い。

#### Use Case 3: 閾値ベースの警告表示（災害リスク）

```javascript
// しきい値を超えた箇所を赤で強調
const heatbox = new Heatbox(viewer, {
  classification: {
    scheme: 'threshold',
    thresholds: [10, 50, 100],  // 0–10, 10–50, 50–100, 100+
    colorMap: ['green', 'yellow', 'orange', 'red']
  }
});
```

**問題**: 洪水リスクや地震リスクのような「安全/注意/警告/危険」の段階的表示には、固定閾値に基づく離散的な色分けが必要。現行の連続グラデーションでは、境界が曖昧で警告表示に適さない。

#### Use Case 4: レイヤごとの色分け（v0.1.18 Layer Aggregation 連携）

```javascript
// ADR-0014 で導入されたレイヤ集約と組み合わせた分類
const heatbox = new Heatbox(viewer, {
  aggregation: {
    enabled: true,
    byProperty: 'buildingType'
  },
  classification: {
    scheme: 'layer-dominant',  // v1.1.0+ で予定
    layerColorMap: {
      'residential': 'blue',
      'commercial': 'red',
      'industrial': 'gray'
    }
  }
});
```

**問題**: v0.1.18 でレイヤ集約が導入されたが、レイヤごとの色分けは `colorResolver` での全面カスタマイズが必要で、API として統合されていない。

### 現状の制限と課題

#### 1. スケール変換の不在

- 現行の `normalizedDensity` は線形正規化 `(value - min) / (max - min)` のみ。
- 対数スケール・累乗スケール・階級区分などの変換ロジックが存在しない。
- ユーザーが独自に実装するには、内部統計（min/max/distribution）へのアクセスが必要だが、現行の `getStatistics()` には含まれていない。

**具体例**: 
```javascript
// 現行の回避策: colorResolver で対数変換を手動実装
colorResolver: (voxelInfo) => {
  const value = voxelInfo.count;
  const logValue = Math.log(value + 1);
  const logMax = Math.log(maxCount + 1);  // maxCount はどこから取得？
  const normalized = logValue / logMax;
  return Cesium.Color.lerp(Cesium.Color.BLUE, Cesium.Color.RED, normalized);
}
```

この回避策には以下の問題があります:
- `maxCount` を取得する公式 API が存在しない（`getStatistics().maxDensity` は存在するが、`count` の最大値ではない）。
- データ更新時に `colorResolver` を再定義する必要があり、状態管理が煩雑。
- 分類ロジックとカラーマップが混在し、再利用性が低い。

#### 2. カラーマップの単純性

- 現行は2色間の線形補間（`Color.lerp`）または `colorResolver` の全面カスタマイズのみ。
- 多色グラデーション（3色以上）は未対応。
- 離散的な色階級（categorical classification）は `colorResolver` での分岐処理が必要。

**具体例**: 
```javascript
// 3色グラデーション（青→黄→赤）の現行回避策
colorResolver: (voxelInfo) => {
  const normalized = /* 正規化処理 */;
  if (normalized < 0.5) {
    return Cesium.Color.lerp(Cesium.Color.BLUE, Cesium.Color.YELLOW, normalized * 2);
  } else {
    return Cesium.Color.lerp(Cesium.Color.YELLOW, Cesium.Color.RED, (normalized - 0.5) * 2);
  }
}
```

#### 3. 統計情報の不足

- 分類に必要な統計量（分位点・Jenks breaks・ヒストグラム）が計算されていない。
- `getStatistics()` は基本的なカウント（`voxelCount`, `entityCount`, `minDensity`, `maxDensity`）のみ。
- 分位数・標準偏差・外れ値などの高度な統計は取得不可。

#### 4. GIS標準との乖離

- **QGIS**: `quantile`, `jenks`, `equal-interval`, `standard-deviation`, `pretty-breaks` などが標準機能。
- **ArcGIS**: `natural-breaks`, `quantile`, `equal-interval`, `standard-deviation`, `geometric-interval` などが標準。
- **D3.js**: `d3.scaleQuantize`, `d3.scaleQuantile`, `d3.scaleThreshold`, `d3.scaleLog` など豊富なスケール関数。

Heatbox がこれらに対応していないと、GIS ユーザーにとって学習コストが高く、他ツールとの互換性も低い。

#### 5. 既存 API との整合性

現行の 0.1 系では、以下の色関連 API が混在しています:

- `baseColor: Cesium.Color` — 単色ベース
- `highlightColor: Cesium.Color` — TopN 強調色
- `colorResolver: (voxelInfo) => Cesium.Color` — 完全カスタム
- `normalizedDensity` — 内部的な正規化値（非公開）

v1.0.0 で分類エンジンを導入するにあたり、以下を満たす必要があります:

1. **既存のデフォルト設定に対して視覚的な退行がないこと** — 分類を無効にした場合、0.1 系と同等の色表現になる（±10% 程度の差異に収まる）。
2. **`colorResolver` との優先順位が明確であること** — 分類と `colorResolver` を併用した場合の挙動を定義。
3. **v1.1.0 で `opacity` / `width` に拡張しても破壊的変更を避けること** — 設計段階で拡張性を確保。

### v1.0.0 における分類スコープ

ROADMAP に示されているとおり、v1.0.0 では「最小の分類エンジン」を導入し、対象は **color のみ** に限定します:

- **対応スキーム（v1.0.0 時点）**
  - `linear`（既定・後方互換）
  - `log`（対数スケール）
  - `equal-interval`（等間隔）
  - `quantize`（量子化）
  - `threshold`（閾値ベース）

- **v1.1.0 以降に拡張予定のスキーム**
  - `quantile`（分位数）
  - `jenks`（Jenks natural breaks / ckmeans）
  - `gamma`（ガンマ補正、任意）
  - `easing`（イージング関数、任意）

- **対象プロパティ**
  - v1.0.0: `classificationTargets` のうち `color` のみ有効
  - v1.1.0: `opacity` / `width` への拡張と凡例連携を予定

実装場所は ROADMAP の方針どおり `src/utils/classification.js` とし、`AdaptiveController` および `VoxelRenderer` から利用可能な純粋関数ベースのユーティリティとして提供します。

### 既存の挙動と互換性要件

- 現行 0.1 系では色は主に「統計 + カラーマップ」の組み合わせで制御されており、分類は明示的な API としては提供されていない。
- `boxOpacityResolver` / `outlineOpacityResolver` / `outlineWidthResolver` などの Resolver 群は存続が明示されており、**少なくとも v1.1.0 の AdaptiveController 拡張が安定するまで削除しない** 方針となっている（ADR-0013/0014 参照）。
- v1.0.0 の分類エンジン導入にあたっても、既存のデフォルト色表現に視覚的な退行がないこと（±10% 程度の差異に収まること）が Acceptance Criteria として定義されている。

このため、v1.0.0 では以下を満たす必要があります:

1. 既存のデフォルト設定に対して分類を無効または「従来と同等」の挙動とし、破壊的変更を避ける。
2. v1.1.0 で `classificationTargets.opacity/width` を拡張しても API の破壊的変更を行わずに済むよう、設計段階で拡張性を確保する。
3. 将来の `quantile` / `jenks` / `gamma` / `easing` などの追加に耐えられるモジュール構造とする。

### 統計・分類ライブラリ利用の検討背景

ROADMAP では v1.1.0 で `quantile` と `jenks` を追加することが明記されています。これらは単純な線形変換や等間隔分割よりも実装・性能ともに負荷が高く、以下の観点から **既存の統計ライブラリを活用する選択肢** が有力です。

- **`quantile`**:
  - ソート済み配列を前提としたパーセンタイル計算ロジックが必要。
  - 外れ値・NaN の扱いなどで設計判断が伴う。
  - 線形補間（R-7, R-8 方式）など、標準的な実装を提供する必要がある。

- **`jenks`**（Jenks natural breaks / ckmeans）:
  - 動的計画法ベースのアルゴリズムが一般的であり、自前実装はバグリスクとメンテコストが高い。
  - データサイズによってはパフォーマンスへの配慮が必要（O(n² k) の計算量）。
  - GIS 標準として広く使われており、実績のあるライブラリ実装に委譲するのが安全。

一方で、v1.0.0 のスコープ（linear/log/equal-interval/quantize/threshold）は比較的単純であり、**自前実装でも安全かつ軽量に実現可能** です。

本 ADR では、以下を整理します:

1. v1.0.0 での分類エンジンの構造と、採用する統計ライブラリ。
2. v1.1.0 以降で `quantile` / `jenks` を実装する際の拡張方針。
3. それらを見越した API/実装の拡張性確保。

## Decision / 決定事項

### 1. v1.0.0 から `simple-statistics` を「内部バックエンド」として採用する

v1.0.0 では、分類 API の表面仕様は ROADMAP のとおり最小スキームに限定しつつ、内部実装として **`simple-statistics` を統計バックエンドとして採用** します。

#### 採用理由（`simple-statistics`）

- **ライセンス**: ISC ライセンスであり、商用利用を含めて扱いやすい（MIT 相当の緩やかな許諾条件）。
- **機能網羅性**: quantile 系・分布系・クラスタリング（ckmeans）および Jenks アルゴリズムなど、v1.1.0 以降で必要になる統計処理が一通り揃っている。
- **依存関係**: 外部依存がなく、ライブラリ自体も比較的軽量（約 50KB minified）。
- **Tree-shaking 対応**: モジュール単位のインポートに対応しており、将来的な tree-shaking との相性も良い。
- **実績**: npm で週 100 万ダウンロード以上、GIS・統計系プロジェクトでの採用実績が豊富。

#### v1.0.0 での利用方針

ただし、v1.0.0 のスコープでは ROADMAP に従い `quantile` / `jenks` を **API としては解放しない**。  
`simple-statistics` は以下のような用途で利用します:

- 値配列からの基本統計（min/max/mean/stddev など）の計算。
- 内部的な分布特性把握（後続バージョンでの quantile/jenks 対応の布石）。
- 将来の v1.1.0 で quantile/jenks を有効化した際のバックエンドとして、そのまま再利用可能な構造。

v1.0.0 における分類スキーム（`linear`, `log`, `equal-interval`, `quantize`, `threshold`）自体のロジックは、次の理由から **基本的には自前実装** とします:

- アルゴリズムが単純であり、明示的な数式をコードに残しておく方が挙動を把握しやすい。
- 「v1.0.0 の時点では simple-statistics に依存しなくとも成立する」状態を維持することで、将来ライブラリを差し替える際の自由度を確保する。
- パフォーマンス: 単純なスケール変換は自前実装の方が軽量（関数呼び出しオーバーヘッドを削減）。

このため、`src/utils/classification.js` では以下のような構造を採用します。

### 2. 分類エンジンの API 設計

#### 基本構造

```javascript
// 擬似インターフェイス（型イメージ）

/**
 * @typedef {Object} ClassificationOptions
 * @property {'linear'|'log'|'equal-interval'|'quantize'|'threshold'|'quantile'|'jenks'} scheme
 * @property {number[]} [values]   // 生データ（必要に応じて）
 * @property {number[]} [domain]   // [min, max]。未指定時は values から算出
 * @property {number}   [classes]  // クラス数（quantize/equal-interval/quantile/jenks など）
 * @property {number[]} [thresholds] // threshold 用の境界配列
 * @property {string[]} [colorMap]  // 色配列（Cesium.Color または CSS color string）
 */

/**
 * 分類コンテキストを構築し、値→クラスの対応を表現する
 * @param {ClassificationOptions} options
 * @returns {ClassificationContext}
 */
export function createClassifier(options) { /* ... */ }

/**
 * @typedef {Object} ClassificationContext
 * @property {(value: number) => number} classify - 値をクラスインデックス [0, classes-1] にマッピング
 * @property {(value: number) => number} normalize - 値を [0, 1] に正規化（連続スケール用）
 * @property {(normalized: number) => Cesium.Color} getColor - 正規化値から色を取得
 * @property {number[]} breaks - 分類境界値（離散分類の場合）
 * @property {[number, number]} domain - 実際の値域 [min, max]
 * @property {string} scheme - 使用された分類スキーム
 * @property {number} classes - クラス数（離散分類の場合）
 */
```

#### 使用例

```javascript
// 対数スケール + 3色グラデーション
const classifier = createClassifier({
  scheme: 'log',
  domain: [1, 10000],  // 最小値 1（log(0) を避ける）、最大値 10000
  colorMap: ['blue', 'yellow', 'red']
});

// ボクセルごとに色を取得
voxels.forEach(voxel => {
  const normalized = classifier.normalize(voxel.count);
  voxel.color = classifier.getColor(normalized);
});

// 等間隔分類（5階級）
const classifier = createClassifier({
  scheme: 'equal-interval',
  domain: [0, 100],
  classes: 5,
  colorMap: ['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15']
});

console.log(classifier.breaks);  // [0, 20, 40, 60, 80, 100]

// 閾値ベース（固定境界）
const classifier = createClassifier({
  scheme: 'threshold',
  thresholds: [10, 50, 100],
  colorMap: ['green', 'yellow', 'orange', 'red']
});

const classIndex = classifier.classify(75);  // 2 (orange)
const color = classifier.getColor(classifier.normalize(75));  // orange
```

#### AdaptiveController / VoxelRenderer との連携

```javascript
// VoxelRenderer.js（イメージ）
import { createClassifier } from '../utils/classification.js';

class VoxelRenderer {
  _prepareClassifier(voxelData) {
    if (!this.options.classification?.enabled) {
      // デフォルト: 線形分類（既存挙動と同等）
      this._classifier = createClassifier({
        scheme: 'linear',
        domain: [this.stats.minDensity, this.stats.maxDensity],
        colorMap: [this.options.baseColor, this.options.highlightColor]
      });
      return;
    }

    const classOpts = this.options.classification;
    this._classifier = createClassifier({
      scheme: classOpts.scheme || 'linear',
      domain: classOpts.domain || [this.stats.minDensity, this.stats.maxDensity],
      classes: classOpts.classes,
      thresholds: classOpts.thresholds,
      colorMap: classOpts.colorMap || [this.options.baseColor, this.options.highlightColor]
    });
  }

  _applyColor(voxelInfo) {
    // 優先順位: colorResolver > classifier
    if (this.options.colorResolver) {
      return this.options.colorResolver(voxelInfo);
    }

    const value = voxelInfo.count;  // または normalizedDensity
    const normalized = this._classifier.normalize(value);
    return this._classifier.getColor(normalized);
  }
}
```

### 3. 「統計バックエンド」インターフェイスを用意し、外部ライブラリを差し替え可能にする

v1.0.0 の段階で、`src/utils/classification.js` には以下のような「統計バックエンド」インターフェイスを導入し、将来のライブラリ差し替えを容易にします。

```javascript
// classification.js 内で使用するバックエンドの型イメージ

/**
 * @typedef {Object} ClassificationStatsBackend
 * @property {(values: number[], p: number) => number} quantile
 * @property {(values: number[], k: number) => number[][]} ckmeans
 * @property {(values: number[]) => {min: number, max: number, mean: number, stddev: number}} summary
 */

// v1.0.0 時点のバックエンド初期化イメージ
import * as ss from 'simple-statistics';

let backend = {
  quantile(values, p) {
    return ss.quantileSorted([...values].sort((a, b) => a - b), p);
  },
  ckmeans(values, k) {
    // v1.0.0ではまだ公開スキームとして利用しないが、
    // v1.1.0での jenks 実装のために内部的に利用可能にしておく。
    return ss.ckmeans(values, k);
  },
  summary(values) {
    return {
      min: ss.min(values),
      max: ss.max(values),
      mean: ss.mean(values),
      stddev: ss.standardDeviation(values)
    };
  }
};

/**
 * テスト・プラグイン用に統計バックエンドを差し替え可能にする
 * @param {Partial<ClassificationStatsBackend>} nextBackend
 */
export function setClassificationBackend(nextBackend) {
  backend = { ...backend, ...nextBackend };
}

/**
 * 内部用: 統計バックエンドを取得
 * @returns {ClassificationStatsBackend}
 */
export function getBackend() {
  return backend;
}
```

#### 拡張方針

- **v1.0.0**:
  - `quantile` / `jenks` スキームは **API としては未解放** とし、`createClassifier` からは選択できない（エラーまたはフォールバック）。
  - ただし、バックエンドとして `simple-statistics` をすでに導入しておき、バンドル構成や依存関係を早期に安定させる。
  
- **v1.1.0**:
  - `createClassifier` に `quantile` / `jenks` を追加し、上記バックエンドを直接利用する。
  - 将来、別の統計ライブラリに切り替える場合は `setClassificationBackend` でアダプタを差し替えるだけで済む。

### 4. AdaptiveController との連携方針

- **v1.0.0**:
  - `AdaptiveController` は color に対してのみ `classification` 設定を尊重する。
  - `normalizedDensity` から得た値を `createClassifier` に渡し、クラスインデックスまたは [0, 1] の正規化値としてカラーマップに変換する。
  - `opacity` / `width` については、既存の Resolver と `adaptiveParams.*Range` は **クランプと基礎設定のみ** を担い、分類とは連動させない。
  
- **v1.1.0**:
  - `AdaptiveController` が color/opacity/width を共通の classification ユーティリティで補間するように拡張する（別 ADR で詳細定義）。

### 5. 既存 API との優先順位

分類エンジン導入に伴い、以下の優先順位を明確化します:

1. **`colorResolver`（最優先）**: ユーザー定義の関数が存在する場合、分類エンジンは無視される。
2. **`classification`**: 分類が有効な場合、統一的なスケール変換とカラーマップを適用。
3. **`baseColor` / `highlightColor`（フォールバック）**: 分類が無効な場合、既存の線形補間を維持（後方互換）。

```javascript
// 優先順位の実装イメージ
_getVoxelColor(voxelInfo) {
  // 1. colorResolver が最優先
  if (this.options.colorResolver) {
    return this.options.colorResolver(voxelInfo);
  }

  // 2. classification が有効な場合
  if (this._classifier) {
    const value = this._getClassificationValue(voxelInfo);
    const normalized = this._classifier.normalize(value);
    return this._classifier.getColor(normalized);
  }

  // 3. 既存の線形補間（後方互換）
  return Cesium.Color.lerp(
    this.options.baseColor,
    this.options.highlightColor,
    voxelInfo.normalizedDensity
  );
}
```

## Architecture / アーキテクチャ

### Component Structure / コンポーネント構造

```
src/
  utils/
    classification.js              # NEW: 分類エンジン本体
    classificationBackend.js       # NEW: 統計バックエンド（simple-statistics ラッパー）
    colorMap.js                    # NEW: カラーマップ補間（多色グラデーション）
    validation.js                  # UPDATE: classification オプションの検証
    constants.js                   # UPDATE: DEFAULT_OPTIONS.classification
  core/
    VoxelRenderer.js               # UPDATE: _prepareClassifier / _applyColor
    DataProcessor.js               # UPDATE: 統計情報の拡張（分位点など）
  Heatbox.js                       # UPDATE: classification オプションの受け渡し
```

### DataFlow / データフロー

```
1. ユーザーがオプション指定
   ↓
   { classification: { scheme: 'log', colorMap: [...] } }
   ↓
2. Heatbox.js が validation.js で検証・正規化
   ↓
3. DataProcessor.js が統計情報を計算
   ↓
   { minDensity, maxDensity, quantiles: [Q1, Q2, Q3], ... }
   ↓
4. VoxelRenderer._prepareClassifier()
   ↓
   createClassifier({ scheme, domain, colorMap })
   ↓
5. VoxelRenderer._applyColor(voxelInfo)
   ↓
   classifier.normalize(value) → getColor(normalized) → Cesium.Color
   ↓
6. GeometryRenderer.createVoxelBox({ color })
```

### 統計情報の拡張

現行の `getStatistics()` に以下を追加:

```javascript
// DataProcessor.js
getStatistics() {
  return {
    // 既存フィールド
    voxelCount: this._voxelData.size,
    entityCount: this._totalEntities,
    minDensity: this._stats.min,
    maxDensity: this._stats.max,
    
    // NEW: 分類用統計
    classification: {
      enabled: !!this.options.classification?.enabled,
      scheme: this.options.classification?.scheme || 'linear',
      domain: [this._stats.min, this._stats.max],
      quantiles: this._stats.quantiles || null,  // [Q1, Q2, Q3] (v1.1.0+)
      jenksBreaks: this._stats.jenksBreaks || null,  // (v1.1.0+)
      histogram: this._stats.histogram || null  // { bins: [...], counts: [...] }
    }
  };
}
```

### カラーマップの実装

多色グラデーション（3色以上）の補間を `src/utils/colorMap.js` で実装:

```javascript
// colorMap.js

/**
 * 多色グラデーションを生成
 * @param {string[]|Cesium.Color[]} colors - 色配列
 * @param {number} normalized - [0, 1] の正規化値
 * @returns {Cesium.Color}
 */
export function interpolateColorMap(colors, normalized) {
  if (colors.length === 0) {
    return Cesium.Color.WHITE.clone();
  }
  if (colors.length === 1) {
    return parseColor(colors[0]);
  }

  // 正規化値を [0, colors.length - 1] にマッピング
  const index = normalized * (colors.length - 1);
  const lowerIndex = Math.floor(index);
  const upperIndex = Math.ceil(index);
  
  if (lowerIndex === upperIndex) {
    return parseColor(colors[lowerIndex]);
  }

  const t = index - lowerIndex;
  const lowerColor = parseColor(colors[lowerIndex]);
  const upperColor = parseColor(colors[upperIndex]);
  
  return Cesium.Color.lerp(lowerColor, upperColor, t, new Cesium.Color());
}

/**
 * CSS color string または Cesium.Color を Cesium.Color に変換
 * @param {string|Cesium.Color} color
 * @returns {Cesium.Color}
 */
function parseColor(color) {
  if (color instanceof Cesium.Color) {
    return color.clone();
  }
  // CSS color string をパース（'#RRGGBB', 'rgba(...)', 'blue' など）
  return Cesium.Color.fromCssColorString(color);
}
```

## Detailed Design / 詳細設計

### 1. createClassifier の実装

```javascript
// src/utils/classification.js

import { interpolateColorMap } from './colorMap.js';
import { getBackend } from './classificationBackend.js';

/**
 * 分類コンテキストを生成
 * @param {ClassificationOptions} options
 * @returns {ClassificationContext}
 */
export function createClassifier(options) {
  const {
    scheme = 'linear',
    values = null,
    domain = null,
    classes = 5,
    thresholds = null,
    colorMap = null
  } = options;

  // domain の決定
  let [min, max] = domain || [0, 1];
  if (values && !domain) {
    const backend = getBackend();
    const stats = backend.summary(values);
    min = stats.min;
    max = stats.max;
  }

  // スキームごとの分類関数を生成
  let normalize, breaks;
  
  switch (scheme) {
    case 'linear':
      normalize = (value) => (value - min) / (max - min);
      breaks = [min, max];
      break;
      
    case 'log':
      // 対数スケール（min > 0 を前提）
      if (min <= 0) {
        console.warn('log scale requires min > 0, adjusting to 1');
        min = 1;
      }
      const logMin = Math.log(min);
      const logMax = Math.log(max);
      normalize = (value) => {
        if (value <= 0) return 0;
        return (Math.log(value) - logMin) / (logMax - logMin);
      };
      breaks = [min, max];
      break;
      
    case 'equal-interval':
      // 等間隔分類
      breaks = [];
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (max - min) * (i / classes));
      }
      normalize = (value) => {
        for (let i = 0; i < breaks.length - 1; i++) {
          if (value <= breaks[i + 1]) {
            return (i + (value - breaks[i]) / (breaks[i + 1] - breaks[i])) / classes;
          }
        }
        return 1;
      };
      break;
      
    case 'quantize':
      // 量子化（equal-interval と同様だが、離散的なクラスインデックスを返す）
      breaks = [];
      for (let i = 0; i <= classes; i++) {
        breaks.push(min + (max - min) * (i / classes));
      }
      normalize = (value) => {
        for (let i = 0; i < breaks.length - 1; i++) {
          if (value <= breaks[i + 1]) {
            return i / (classes - 1);  // 離散的
          }
        }
        return 1;
      };
      break;
      
    case 'threshold':
      // 閾値ベース
      if (!thresholds || thresholds.length === 0) {
        throw new Error('threshold scheme requires thresholds array');
      }
      breaks = [min, ...thresholds, max];
      normalize = (value) => {
        for (let i = 0; i < breaks.length - 1; i++) {
          if (value <= breaks[i + 1]) {
            return i / (breaks.length - 2);
          }
        }
        return 1;
      };
      break;
      
    case 'quantile':
    case 'jenks':
      // v1.0.0 では未サポート
      throw new Error(`scheme '${scheme}' is not supported in v1.0.0 (planned for v1.1.0)`);
      
    default:
      throw new Error(`unknown classification scheme: ${scheme}`);
  }

  // カラーマップ関数
  const getColor = colorMap
    ? (normalized) => interpolateColorMap(colorMap, Math.max(0, Math.min(1, normalized)))
    : (normalized) => Cesium.Color.lerp(Cesium.Color.BLUE, Cesium.Color.RED, normalized, new Cesium.Color());

  // クラスインデックスを取得
  const classify = (value) => {
    const norm = normalize(value);
    return Math.floor(norm * classes);
  };

  return {
    scheme,
    domain: [min, max],
    breaks,
    classes,
    normalize,
    getColor,
    classify
  };
}
```

### 2. classificationBackend の実装

```javascript
// src/utils/classificationBackend.js

import * as ss from 'simple-statistics';

let backend = {
  /**
   * 分位数を計算
   * @param {number[]} values
   * @param {number} p - 分位点 (0–1)
   * @returns {number}
   */
  quantile(values, p) {
    if (!values || values.length === 0) return 0;
    const sorted = [...values].sort((a, b) => a - b);
    return ss.quantileSorted(sorted, p);
  },

  /**
   * ckmeans（Jenks natural breaks）
   * @param {number[]} values
   * @param {number} k - クラス数
   * @returns {number[][]} - クラスタ配列
   */
  ckmeans(values, k) {
    if (!values || values.length === 0) return [];
    return ss.ckmeans(values, k);
  },

  /**
   * 基本統計サマリ
   * @param {number[]} values
   * @returns {{min: number, max: number, mean: number, stddev: number}}
   */
  summary(values) {
    if (!values || values.length === 0) {
      return { min: 0, max: 0, mean: 0, stddev: 0 };
    }
    return {
      min: ss.min(values),
      max: ss.max(values),
      mean: ss.mean(values),
      stddev: ss.standardDeviation(values)
    };
  }
};

/**
 * テスト・プラグイン用に統計バックエンドを差し替え
 * @param {Partial<typeof backend>} nextBackend
 */
export function setClassificationBackend(nextBackend) {
  backend = { ...backend, ...nextBackend };
}

/**
 * 内部用: 統計バックエンドを取得
 * @returns {typeof backend}
 */
export function getBackend() {
  return backend;
}
```

### 3. VoxelRenderer の統合

```javascript
// src/core/VoxelRenderer.js（更新イメージ）

import { createClassifier } from '../utils/classification.js';

class VoxelRenderer {
  constructor(options) {
    this.options = options;
    this._classifier = null;
  }

  render(voxelData, stats) {
    this.stats = stats;
    this._prepareClassifier(voxelData);
    
    voxelData.forEach(voxelInfo => {
      const color = this._getVoxelColor(voxelInfo);
      this._createVoxelBox(voxelInfo, color);
    });
  }

  _prepareClassifier(voxelData) {
    const classOpts = this.options.classification;
    
    if (!classOpts || !classOpts.enabled) {
      // デフォルト: 線形分類（後方互換）
      this._classifier = createClassifier({
        scheme: 'linear',
        domain: [this.stats.minDensity, this.stats.maxDensity],
        colorMap: [this.options.baseColor, this.options.highlightColor]
      });
      return;
    }

    // 分類が有効な場合
    this._classifier = createClassifier({
      scheme: classOpts.scheme || 'linear',
      domain: classOpts.domain || [this.stats.minDensity, this.stats.maxDensity],
      classes: classOpts.classes || 5,
      thresholds: classOpts.thresholds,
      colorMap: classOpts.colorMap || [this.options.baseColor, this.options.highlightColor]
    });
  }

  _getVoxelColor(voxelInfo) {
    // 優先順位: colorResolver > classifier > 既存の線形補間
    if (this.options.colorResolver) {
      return this.options.colorResolver(voxelInfo);
    }

    if (this._classifier) {
      const value = this._getClassificationValue(voxelInfo);
      const normalized = this._classifier.normalize(value);
      return this._classifier.getColor(normalized);
    }

    // フォールバック（後方互換）
    return Cesium.Color.lerp(
      this.options.baseColor,
      this.options.highlightColor,
      voxelInfo.normalizedDensity,
      new Cesium.Color()
    );
  }

  _getClassificationValue(voxelInfo) {
    // 分類対象の値を取得（count / normalizedDensity / カスタムプロパティ）
    if (this.options.classification?.valueProperty) {
      return voxelInfo[this.options.classification.valueProperty];
    }
    return voxelInfo.count;  // デフォルトは count
  }
}
```

### 4. validation.js の拡張

```javascript
// src/utils/validation.js（追加部分）

/**
 * classification オプションを検証・正規化
 * @param {Object} classification
 * @returns {Object}
 */
function validateClassification(classification) {
  if (!classification || typeof classification !== 'object') {
    return null;
  }

  const normalized = {
    enabled: !!classification.enabled,
    scheme: classification.scheme || 'linear',
    domain: classification.domain || null,
    classes: classification.classes || 5,
    thresholds: classification.thresholds || null,
    colorMap: classification.colorMap || null,
    valueProperty: classification.valueProperty || 'count'
  };

  // スキームの検証
  const validSchemes = ['linear', 'log', 'equal-interval', 'quantize', 'threshold'];
  if (!validSchemes.includes(normalized.scheme)) {
    console.warn(`Invalid classification scheme: ${normalized.scheme}, falling back to 'linear'`);
    normalized.scheme = 'linear';
  }

  // threshold スキームの検証
  if (normalized.scheme === 'threshold') {
    if (!Array.isArray(normalized.thresholds) || normalized.thresholds.length === 0) {
      throw new Error('threshold scheme requires non-empty thresholds array');
    }
  }

  // classes の検証
  if (normalized.classes < 2 || normalized.classes > 20) {
    console.warn(`classes should be between 2 and 20, got ${normalized.classes}, clamping`);
    normalized.classes = Math.max(2, Math.min(20, normalized.classes));
  }

  return normalized;
}
```

## Implementation Plan / 実装計画

### Phase 0: 準備（Day 0）

- [ ] ADR-0016（本ドキュメント）の最終化とレビュー完了
- [ ] ROADMAP v1.0.0 の Acceptance Criteria と本 ADR の受け入れ基準をすり合わせ
- [ ] `simple-statistics` の依存関係を package.json に追加: `npm install --save simple-statistics`

### Phase 1: 基盤実装（Days 1-3）

- [ ] `src/utils/classificationBackend.js` を実装
  - `simple-statistics` のラッパー関数（quantile, ckmeans, summary）
  - `setClassificationBackend` / `getBackend` の実装
- [ ] `src/utils/colorMap.js` を実装
  - `interpolateColorMap` 関数（多色グラデーション）
  - `parseColor` 関数（CSS color string → Cesium.Color）
- [ ] 単体テスト: `test/utils/classificationBackend.test.js`
- [ ] 単体テスト: `test/utils/colorMap.test.js`

### Phase 2: 分類エンジン実装（Days 4-6）

- [ ] `src/utils/classification.js` に `createClassifier` を実装
  - `linear`, `log`, `equal-interval`, `quantize`, `threshold` の5スキーム
  - `normalize`, `getColor`, `classify` メソッド
- [ ] 単体テスト: `test/utils/classification.test.js`
  - 各スキームの正規化値・色・クラスインデックスを検証
  - エッジケース（min=max, negative values, log(0) など）

### Phase 3: VoxelRenderer 統合（Days 7-9）

- [ ] `VoxelRenderer._prepareClassifier` の実装
- [ ] `VoxelRenderer._getVoxelColor` の更新（優先順位: colorResolver > classifier）
- [ ] `validation.js` に `validateClassification` を追加
- [ ] `constants.js` に `DEFAULT_OPTIONS.classification` を追加
- [ ] 統合テスト: `test/integration/classification.test.js`
  - 既存の線形補間との互換性確認（±10% 以内の色差）
  - 各スキームでの動作確認

### Phase 4: DataProcessor 統計拡張（Days 10-11）

- [ ] `DataProcessor.getStatistics()` に `classification` フィールドを追加
- [ ] 分位数・ヒストグラムの計算（v1.1.0 の布石）
- [ ] 単体テスト: `test/core/DataProcessor.test.js` の更新

### Phase 5: Examples & Documentation（Days 12-14）

- [ ] `examples/advanced/classification-demo.html` を作成
  - 5つのスキーム（linear/log/equal-interval/quantize/threshold）の比較
  - 同じデータセットで視覚的差異を確認できる UI
- [ ] README の Classification セクションを追加
- [ ] API.md の更新（`classification` オプション）
- [ ] Migration Guide の追加（0.1 → v1.0.0）

### Phase 6: Performance & QA（Days 15-16）

- [ ] パフォーマンステスト: 1k–5k ボクセルでの分類処理時間
  - 目標: 既存の線形補間と比較して ≤ +15% のオーバーヘッド
- [ ] メモリテスト: メモリ使用量の増加 ≤ +10%
- [ ] ビジュアル回帰テスト: 既存 examples の視覚的退行がないことを確認
- [ ] Lint & Type Check: `npm run lint && npm run type-check`

### Phase 7: CI & Release Preparation（Days 17-18）

- [ ] CI でのテスト実行（全テストグリーン）
- [ ] `package.json` のバージョンを `1.0.0-alpha.1` に更新
- [ ] `src/index.js` の `VERSION` を同期
- [ ] CHANGELOG.md の更新
- [ ] タグ作成 & GitHub Actions での npm publish

## Testing Strategy / テスト戦略

### Unit Tests / 単体テスト

#### 1. classificationBackend.test.js

```javascript
import { getBackend, setClassificationBackend } from '../../src/utils/classificationBackend.js';

describe('classificationBackend', () => {
  it('should calculate quantiles', () => {
    const backend = getBackend();
    const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    
    expect(backend.quantile(values, 0.5)).toBeCloseTo(5.5, 1);  // median
    expect(backend.quantile(values, 0.25)).toBeCloseTo(3.25, 1);  // Q1
    expect(backend.quantile(values, 0.75)).toBeCloseTo(7.75, 1);  // Q3
  });

  it('should calculate summary statistics', () => {
    const backend = getBackend();
    const values = [1, 2, 3, 4, 5];
    const stats = backend.summary(values);
    
    expect(stats.min).toBe(1);
    expect(stats.max).toBe(5);
    expect(stats.mean).toBe(3);
    expect(stats.stddev).toBeCloseTo(1.414, 2);
  });

  it('should allow backend replacement', () => {
    const mockBackend = {
      quantile: jest.fn(() => 42)
    };
    
    setClassificationBackend(mockBackend);
    const backend = getBackend();
    
    expect(backend.quantile([1, 2, 3], 0.5)).toBe(42);
    expect(mockBackend.quantile).toHaveBeenCalled();
  });
});
```

#### 2. colorMap.test.js

```javascript
import { interpolateColorMap, parseColor } from '../../src/utils/colorMap.js';
import * as Cesium from 'cesium';

describe('colorMap', () => {
  it('should interpolate 2-color gradient', () => {
    const colors = [Cesium.Color.BLUE, Cesium.Color.RED];
    
    const color0 = interpolateColorMap(colors, 0);
    const color1 = interpolateColorMap(colors, 1);
    const colorMid = interpolateColorMap(colors, 0.5);
    
    expect(color0.equals(Cesium.Color.BLUE)).toBe(true);
    expect(color1.equals(Cesium.Color.RED)).toBe(true);
    expect(colorMid.red).toBeCloseTo(0.5, 1);
    expect(colorMid.blue).toBeCloseTo(0.5, 1);
  });

  it('should interpolate 3-color gradient', () => {
    const colors = ['blue', 'yellow', 'red'];
    
    const color0 = interpolateColorMap(colors, 0);    // blue
    const color50 = interpolateColorMap(colors, 0.5); // yellow
    const color100 = interpolateColorMap(colors, 1);  // red
    
    expect(color0.blue).toBeCloseTo(1, 1);
    expect(color50.red).toBeCloseTo(1, 1);
    expect(color50.green).toBeCloseTo(1, 1);
    expect(color100.red).toBeCloseTo(1, 1);
  });

  it('should parse CSS color strings', () => {
    const color1 = parseColor('#ff0000');
    const color2 = parseColor('rgba(0, 255, 0, 0.5)');
    const color3 = parseColor('blue');
    
    expect(color1.red).toBeCloseTo(1, 1);
    expect(color2.green).toBeCloseTo(1, 1);
    expect(color2.alpha).toBeCloseTo(0.5, 1);
    expect(color3.blue).toBeCloseTo(1, 1);
  });
});
```

#### 3. classification.test.js

```javascript
import { createClassifier } from '../../src/utils/classification.js';
import * as Cesium from 'cesium';

describe('classification', () => {
  describe('linear scheme', () => {
    it('should normalize values linearly', () => {
      const classifier = createClassifier({
        scheme: 'linear',
        domain: [0, 100]
      });
      
      expect(classifier.normalize(0)).toBe(0);
      expect(classifier.normalize(50)).toBe(0.5);
      expect(classifier.normalize(100)).toBe(1);
    });
  });

  describe('log scheme', () => {
    it('should normalize values logarithmically', () => {
      const classifier = createClassifier({
        scheme: 'log',
        domain: [1, 100]
      });
      
      expect(classifier.normalize(1)).toBeCloseTo(0, 2);
      expect(classifier.normalize(10)).toBeCloseTo(0.5, 2);
      expect(classifier.normalize(100)).toBeCloseTo(1, 2);
    });

    it('should handle min <= 0 by adjusting to 1', () => {
      const classifier = createClassifier({
        scheme: 'log',
        domain: [0, 100]
      });
      
      expect(classifier.domain[0]).toBe(1);  // adjusted
    });
  });

  describe('equal-interval scheme', () => {
    it('should create equal intervals', () => {
      const classifier = createClassifier({
        scheme: 'equal-interval',
        domain: [0, 100],
        classes: 5
      });
      
      expect(classifier.breaks).toEqual([0, 20, 40, 60, 80, 100]);
      expect(classifier.classify(15)).toBe(0);
      expect(classifier.classify(35)).toBe(1);
      expect(classifier.classify(95)).toBe(4);
    });
  });

  describe('quantize scheme', () => {
    it('should quantize values into discrete classes', () => {
      const classifier = createClassifier({
        scheme: 'quantize',
        domain: [0, 100],
        classes: 4
      });
      
      expect(classifier.classify(12)).toBe(0);
      expect(classifier.classify(37)).toBe(1);
      expect(classifier.classify(62)).toBe(2);
      expect(classifier.classify(87)).toBe(3);
    });
  });

  describe('threshold scheme', () => {
    it('should classify by thresholds', () => {
      const classifier = createClassifier({
        scheme: 'threshold',
        domain: [0, 100],
        thresholds: [25, 50, 75],
        colorMap: ['green', 'yellow', 'orange', 'red']
      });
      
      expect(classifier.breaks).toEqual([0, 25, 50, 75, 100]);
      expect(classifier.classify(10)).toBe(0);  // green
      expect(classifier.classify(40)).toBe(1);  // yellow
      expect(classifier.classify(60)).toBe(2);  // orange
      expect(classifier.classify(90)).toBe(3);  // red
    });
  });

  describe('unsupported schemes', () => {
    it('should throw error for quantile in v1.0.0', () => {
      expect(() => {
        createClassifier({ scheme: 'quantile' });
      }).toThrow(/not supported in v1.0.0/);
    });

    it('should throw error for jenks in v1.0.0', () => {
      expect(() => {
        createClassifier({ scheme: 'jenks' });
      }).toThrow(/not supported in v1.0.0/);
    });
  });
});
```

### Integration Tests / 統合テスト

#### classification-integration.test.js

```javascript
import { Heatbox } from '../../src/Heatbox.js';
import { createMockViewer, generateTestEntities } from '../helpers.js';

describe('Classification Integration', () => {
  let viewer, heatbox;

  beforeEach(() => {
    viewer = createMockViewer();
  });

  afterEach(() => {
    heatbox?.destroy();
  });

  it('should apply log classification to voxel colors', async () => {
    const entities = generateTestEntities(100, { densityRange: [1, 1000] });
    
    heatbox = new Heatbox(viewer, {
      classification: {
        enabled: true,
        scheme: 'log',
        colorMap: ['blue', 'yellow', 'red']
      }
    });
    
    await heatbox.createFromEntities(entities);
    
    const stats = heatbox.getStatistics();
    expect(stats.classification.enabled).toBe(true);
    expect(stats.classification.scheme).toBe('log');
    
    // ボクセルの色が対数スケールで分布していることを検証
    const voxels = Array.from(heatbox._voxelData.values());
    const colors = voxels.map(v => v.color);
    
    // 低密度ボクセルが青系、高密度ボクセルが赤系になっていることを確認
    const lowDensityVoxel = voxels.find(v => v.count < 10);
    const highDensityVoxel = voxels.find(v => v.count > 100);
    
    expect(lowDensityVoxel.color.blue).toBeGreaterThan(0.5);
    expect(highDensityVoxel.color.red).toBeGreaterThan(0.5);
  });

  it('should maintain backward compatibility when classification is disabled', async () => {
    const entities = generateTestEntities(100);
    
    // 分類を無効にした場合、既存の線形補間と同等の挙動
    heatbox = new Heatbox(viewer, {
      baseColor: Cesium.Color.BLUE,
      highlightColor: Cesium.Color.RED,
      classification: { enabled: false }
    });
    
    await heatbox.createFromEntities(entities);
    
    const stats = heatbox.getStatistics();
    expect(stats.classification.enabled).toBe(false);
    
    // 色が線形補間されていることを確認（既存の挙動と同等）
    // ... 検証ロジック
  });

  it('should prioritize colorResolver over classification', async () => {
    const entities = generateTestEntities(100);
    
    const customResolver = jest.fn(() => Cesium.Color.GREEN);
    
    heatbox = new Heatbox(viewer, {
      colorResolver: customResolver,
      classification: {
        enabled: true,
        scheme: 'log',
        colorMap: ['blue', 'red']
      }
    });
    
    await heatbox.createFromEntities(entities);
    
    // colorResolver が優先され、分類は無視される
    expect(customResolver).toHaveBeenCalled();
    
    const voxels = Array.from(heatbox._voxelData.values());
    voxels.forEach(v => {
      expect(v.color.equals(Cesium.Color.GREEN)).toBe(true);
    });
  });
});
```

### Performance Tests / パフォーマンステスト

```javascript
describe('Classification Performance', () => {
  it('should have ≤ +15% overhead vs linear interpolation', async () => {
    const entities = generateTestEntities(5000);
    
    // Baseline: 既存の線形補間
    const start1 = performance.now();
    const heatbox1 = new Heatbox(viewer, { classification: { enabled: false } });
    await heatbox1.createFromEntities(entities);
    const baselineTime = performance.now() - start1;
    
    // 分類エンジン有効
    const start2 = performance.now();
    const heatbox2 = new Heatbox(viewer, {
      classification: { enabled: true, scheme: 'log', colorMap: ['blue', 'red'] }
    });
    await heatbox2.createFromEntities(entities);
    const classificationTime = performance.now() - start2;
    
    const overhead = (classificationTime - baselineTime) / baselineTime;
    expect(overhead).toBeLessThanOrEqual(0.15);  // ≤ +15%
    
    heatbox1.destroy();
    heatbox2.destroy();
  });

  it('should have ≤ +10% memory overhead', async () => {
    const entities = generateTestEntities(5000);
    
    // Baseline
    const mem1 = process.memoryUsage().heapUsed;
    const heatbox1 = new Heatbox(viewer, { classification: { enabled: false } });
    await heatbox1.createFromEntities(entities);
    const baselineMem = process.memoryUsage().heapUsed - mem1;
    
    // 分類エンジン有効
    const mem2 = process.memoryUsage().heapUsed;
    const heatbox2 = new Heatbox(viewer, {
      classification: { enabled: true, scheme: 'log', colorMap: ['blue', 'red'] }
    });
    await heatbox2.createFromEntities(entities);
    const classificationMem = process.memoryUsage().heapUsed - mem2;
    
    const overhead = (classificationMem - baselineMem) / baselineMem;
    expect(overhead).toBeLessThanOrEqual(0.10);  // ≤ +10%
    
    heatbox1.destroy();
    heatbox2.destroy();
  });
});
```

## Alternatives Considered / 検討した代替案

### 1. D3.js スケール関数の利用

#### 利点
- `d3-scale` は分類・スケール変換の業界標準。
- `d3.scaleLog`, `d3.scaleQuantize`, `d3.scaleThreshold` など豊富なスケール関数。
- D3 エコシステムとして長期的にメンテナンスされており、品質と安定性には定評がある。

#### 採用しなかった理由
- **バンドルサイズ**: `d3-scale` 単体でも約 50KB（minified）。さらに `d3-array`, `d3-color`, `d3-interpolate` などの依存が必要。
- **Cesium との色形式の不整合**: D3 は RGB 文字列や配列を返すが、Cesium は `Cesium.Color` オブジェクトを要求。変換コストが発生。
- **オーバーエンジニアリング**: v1.0.0 のスコープ（linear/log/equal-interval/quantize/threshold）は単純なアルゴリズムであり、D3 の高度な機能（time scales, band scales など）は不要。
- **現状の依存関係**: Heatbox は現在 D3 に依存しておらず、「分類エンジンのためだけに D3 系依存を追加する」ことは依存コストに見合わないと判断。

### 2. geostats.js 系（GIS 向け分類ライブラリ）

#### 利点
- quantile / equal-interval / standard deviation / Jenks（natural breaks）など、地理統計でよく使われる分類スキームを 1 パッケージで提供。
- GIS ユーザーには馴染み深い API。

#### 採用しなかった理由
- **モジュール形式**: 主な利用形態が `<script src="...">` によるグローバルオブジェクト（`geostats`）であり、モダンな ESM / tree-shaking 前提のバンドル構成とは相性が良くない。
- **npm パッケージとしても利用可能ではあるが、ESM / 型情報 / ツリーシェイク前提で「そのまま import して使う」には追加のラッパーや設定調整が必要になり、メンテコストが増えると判断**。
- **更新頻度**: 最終更新が数年前であり、長期的なメンテナンスに不安がある。

### 3. 自前実装のみ（統計ライブラリを使わない）

#### 利点
- バンドルサイズを最小化できる。
- 依存関係を増やさない。
- 実装の完全な制御が可能。

#### 採用しなかった理由
- **v1.1.0 での quantile/jenks 実装の負荷**: quantile は線形補間方式（R-7, R-8 など）の選択が必要で、jenks は動的計画法の実装が複雑。自前実装はバグリスクとメンテコストが高い。
- **実績のあるライブラリの利用**: `simple-statistics` は十分に軽量（約 50KB minified）であり、GIS・統計系プロジェクトでの採用実績が豊富。車輪の再発明を避けるべき。

### 4. ColorBrewer / Chroma.js（カラーパレット専用）

#### 利点
- ColorBrewer は GIS で標準的なカラーパレット。
- Chroma.js は色補間・操作に特化。

#### 採用しなかった理由
- **スコープ外**: カラーパレット自体はユーザー定義（`colorMap` 配列）で十分。
- **分類ロジックは含まれない**: これらのライブラリは色の補間・変換のみで、値の分類ロジック（linear/log/quantile など）は提供しない。
- **Cesium.Color との統合**: Cesium の色形式に変換するコストが発生し、メリットが薄い。

## Consequences / 影響

### Positive / 利点

#### 1. GIS 標準への対応
- QGIS や ArcGIS と同等の分類スキーム（linear/log/equal-interval/quantize/threshold）を v1.0.0 で提供。
- v1.1.0 で quantile/jenks を追加すれば、GIS ツール間でのデータ可視化の互換性が大幅に向上。

#### 2. ユーザビリティの向上
- 現行の `colorResolver` では全面カスタマイズが必要だったが、分類エンジンにより**宣言的な設定だけで高度な色分類**が可能に。
- 多色グラデーション（3色以上）が標準サポートされ、視覚的表現力が向上。

#### 3. 拡張性の確保
- v1.1.0 での `opacity` / `width` への拡張を見越した設計。
- 統計バックエンドの抽象化により、将来的なライブラリ差し替えや独自スキーム追加が容易。

#### 4. パフォーマンス
- v1.0.0 のスコープ（linear/log/equal-interval/quantize/threshold）は軽量な自前実装。
- 目標: 既存の線形補間と比較して ≤ +15% の処理時間、≤ +10% のメモリ使用量。

#### 5. テスタビリティ
- `createClassifier` / `interpolateColorMap` / `classificationBackend` など、純粋関数ベースのモジュール分割により単体テストが容易。
- 統計バックエンドをモックに差し替えることで、テスト時の依存関係を制御可能。

### Negative / トレードオフ

#### 1. 依存関係の増加
- `simple-statistics` を追加することで、バンドルサイズが約 50KB（minified）増加。
- v1.0.0 時点では quantile/jenks を API として公開しないため、「将来の機能のための依存」を先行導入する形になる。

#### 2. API 複雑度の増加
- `classification` オプションの追加により、設定項目が増える。
- `colorResolver` との優先順位や、`classification.enabled` の有無による挙動の違いを理解する必要がある。

#### 3. 既存ユーザーへの学習コスト
- 0.1 系ユーザーは `baseColor` / `highlightColor` / `colorResolver` に慣れており、新しい `classification` API を学ぶ必要がある。
- Migration Guide とサンプルコードで緩和する必要がある。

#### 4. v1.0.0 では quantile/jenks が未サポート
- ROADMAP 準拠により、v1.0.0 では quantile/jenks は API として公開しない。
- GIS ユーザーからの「なぜ quantile が使えないのか」という質問が予想される → ドキュメントで明示的に説明。

### Risks & Mitigations / リスク & 緩和策

#### Risk 1: 既存の色表現との視覚的退行

現行の 0.1 系ユーザーが v1.0.0 にアップグレードした際、デフォルト設定での色表現が大きく変わると混乱を招く。

**Mitigation**:
- `classification.enabled` のデフォルトを `false` とし、明示的に有効化した場合のみ新しい分類エンジンを使用。
- `enabled: false` の場合、既存の線形補間と同等の挙動を維持する（Acceptance Criteria: ±10% 以内の色差）。
- ビジュアル回帰テストで既存 examples の視覚的退行がないことを検証。

#### Risk 2: `simple-statistics` のバージョンアップによる破壊的変更

将来、`simple-statistics` が破壊的変更を含むアップデートをリリースした場合、Heatbox の挙動に影響が出る可能性がある。

**Mitigation**:
- `classificationBackend.js` で `simple-statistics` をラップすることで、ライブラリの API 変更を吸収。
- バージョンをピン留め（`package.json` で `~` ではなく固定バージョンを指定）し、アップデート時には必ずテストを実行。
- 将来、別のライブラリに切り替える場合も `setClassificationBackend` で対応可能。

#### Risk 3: パフォーマンスの退行

分類エンジン導入により、ボクセルの色計算が複雑化し、描画パフォーマンスが低下する可能性がある。

**Mitigation**:
- v1.0.0 のスコープ（linear/log/equal-interval/quantize/threshold）は単純なアルゴリズムであり、計算コストは低い。
- パフォーマンステストで「既存の線形補間と比較して ≤ +15% のオーバーヘッド」を目標とし、超過した場合は最適化。
- 分類コンテキスト（`ClassificationContext`）を事前に生成し、ボクセルごとの計算を軽量化（`normalize` / `getColor` は O(1) で動作）。

#### Risk 4: カラーマップの解釈の曖昧さ

ユーザーが指定した `colorMap` 配列が、どのように分類に適用されるかが直感的でない可能性がある。

**Mitigation**:
- ドキュメントとサンプルコードで、各スキームにおける `colorMap` の解釈を明示。
  - `linear` / `log`: 連続グラデーション（多色補間）
  - `equal-interval` / `quantize`: 離散的な色階級（各クラスに1色）
  - `threshold`: 閾値区間ごとに1色
- Examples で視覚的に確認できる UI を提供（`classification-demo.html`）。

## Acceptance Criteria / 受け入れ基準

### Functional / 機能面

- [ ] `classification.enabled=true` で分類エンジンが有効化される
- [ ] `linear`, `log`, `equal-interval`, `quantize`, `threshold` の5スキームが動作する
- [ ] 多色グラデーション（3色以上）が正しく補間される
- [ ] `colorResolver` が存在する場合、分類エンジンより優先される
- [ ] `classification.enabled=false` の場合、既存の線形補間と同等の挙動（±10% 以内の色差）
- [ ] `getStatistics()` に `classification` フィールドが追加され、スキーム・domain・breaks が取得できる

### Non-functional / 非機能面

- [ ] 処理時間: 既存の線形補間と比較して ≤ +15% のオーバーヘッド（1k–5k ボクセル）
- [ ] メモリ使用量: ≤ +10% の増加
- [ ] バンドルサイズ: `simple-statistics` 追加により約 50KB 増加（許容範囲内）
- [ ] Lint 0 errors, Type Check 通過
- [ ] 既存の全テストがグリーン（回帰なし）

### Documentation / ドキュメント

- [ ] README に Classification セクションを追加（各スキームの説明・使用例）
- [ ] API.md に `classification` オプションの詳細を追加
- [ ] Migration Guide（0.1 → v1.0.0）を作成
- [ ] `examples/advanced/classification-demo.html` を作成（5スキームの視覚的比較）
- [ ] JSDoc が主要関数に付与されている（`createClassifier`, `interpolateColorMap` など）

### Testing / テスト

- [ ] 単体テスト: `classificationBackend.test.js`, `colorMap.test.js`, `classification.test.js`
- [ ] 統合テスト: `classification-integration.test.js`（各スキームの動作確認、優先順位、後方互換性）
- [ ] パフォーマンステスト: 処理時間・メモリのオーバーヘッド検証
- [ ] ビジュアル回帰テスト: 既存 examples の視覚的退行がないことを確認
- [ ] CI で全テスト通過

## Migration Guide / 移行ガイド

### For Existing Users (0.1 → v1.0.0) / 既存ユーザー向け

#### 破壊的変更なし（後方互換）

v1.0.0 の分類エンジンはオプトイン式であり、既存コードは変更なしで動作します:

```javascript
// v0.1 系の既存コード（v1.0.0 でもそのまま動作）
const heatbox = new Heatbox(viewer, {
  baseColor: Cesium.Color.BLUE,
  highlightColor: Cesium.Color.RED
});
```

#### 分類エンジンの有効化

新しい分類機能を使用する場合は、`classification` オプションを追加します:

```javascript
// v1.0.0: 対数スケール + 3色グラデーション
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'log',
    colorMap: ['blue', 'yellow', 'red']
  }
});
```

#### colorResolver との併用

`colorResolver` が存在する場合、分類エンジンより優先されます:

```javascript
// colorResolver が優先され、classification は無視される
const heatbox = new Heatbox(viewer, {
  colorResolver: (voxelInfo) => {
    return voxelInfo.count > 50 ? Cesium.Color.RED : Cesium.Color.BLUE;
  },
  classification: {
    enabled: true,
    scheme: 'log'
  }  // ← 無視される
});
```

分類エンジンと `colorResolver` を併用したい場合は、`colorResolver` 内で分類を参照します（高度な使い方）。

## Future Work / 今後の作業

### v1.1.0: quantile / jenks の追加

```javascript
// 分位数（quantile）
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'quantile',
    classes: 5,
    colorMap: ['#ffffcc', '#c2e699', '#78c679', '#31a354', '#006837']
  }
});

// Jenks natural breaks
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'jenks',
    classes: 5,
    colorMap: ['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15']
  }
});
```

### v1.1.0: opacity / width への拡張

```javascript
// 色だけでなく、不透明度・太さも分類に基づいて制御
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'log',
    targets: ['color', 'opacity', 'width'],  // NEW
    colorMap: ['blue', 'red'],
    opacityRange: [0.2, 1.0],
    widthRange: [1, 5]
  }
});
```

### v1.2.0: レイヤベース分類（ADR-0014 連携）

```javascript
// レイヤごとの色分け（v0.1.18 Layer Aggregation との連携）
const heatbox = new Heatbox(viewer, {
  aggregation: {
    enabled: true,
    byProperty: 'buildingType'
  },
  classification: {
    enabled: true,
    scheme: 'layer-dominant',  // NEW
    layerColorMap: {
      'residential': 'blue',
      'commercial': 'red',
      'industrial': 'gray'
    }
  }
});
```

### v2.x: 凡例・インタラクティブ調整

```javascript
// 凡例の自動生成
const legend = heatbox.createLegend({
  position: 'bottom-right',
  labels: ['Low', 'Medium', 'High']
});

// インタラクティブな分類調整（UI から分類境界を編集）
heatbox.updateClassification({
  thresholds: [10, 50, 100]  // ユーザーがスライダーで調整
});
```

## References / 参照

- **ROADMAP v1.0.0**: Lines 200–350（分類エンジンの最小スコープ）
- **ADR-0014**: Voxel Layer Aggregation（レイヤ集約との将来的な連携）
- **ADR-0015**: Global Spatial ID QA（統計情報の拡張方針）
- **simple-statistics**: https://github.com/simple-statistics/simple-statistics
- **QGIS Classification**: https://docs.qgis.org/3.28/en/docs/user_manual/working_with_vector/vector_properties.html#graduated-renderer
- **ColorBrewer**: https://colorbrewer2.org/

---

**Approval**: Pending review  
**Implementation Target**: v1.0.0-alpha.1 (2025-12-15)
