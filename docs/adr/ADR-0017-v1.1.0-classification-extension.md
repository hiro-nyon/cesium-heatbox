# ADR-0017: v1.1.0 分類エンジン拡張（opacity/width + quantile/jenks）

**Status**: Proposed  
**Date**: 2025-11-18  
**Author**: hiro-nyon  
**Target Version**: v1.1.0  
**Related**: ROADMAP v1.1.0, ADR-0016 (v1.0.0 Classification Engine), ADR-0014 (Layer Aggregation)

## Context / 背景

### Problem Statement / 問題提起

v1.0.0 で導入した分類エンジン（ADR-0016）は、**color のみ**を対象とした基本的な分類スキーム（linear/log/equal-interval/quantize/threshold）を提供しました。しかし、データ可視化においては **色だけでなく、透明度や線の太さも重要な視覚変数** であり、これらを統一的に制御できないことが大きな制限となっています。

また、GIS 標準で広く使われている **quantile（分位数）** と **jenks（Jenks natural breaks）** が v1.0.0 では未実装のため、QGIS や ArcGIS などの既存ツールとの互換性が不十分です。

#### Use Case 1: 密度に応じた透明度制御（重なり視認性の向上）

```javascript
// 問題: 高密度領域でボクセルが重なり、内部が見えない
// 現状の回避策: boxOpacityResolver で手動実装
const heatbox = new Heatbox(viewer, {
  boxOpacityResolver: (voxelInfo) => {
    const density = voxelInfo.normalizedDensity;
    return 0.3 + density * 0.7;  // 低密度: 0.3, 高密度: 1.0
  }
});

// 期待: 分類エンジンで宣言的に設定
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'log',
    classificationTargets: {
      color: true,
      opacity: true  // NEW in v1.1.0
    }
  },
  adaptiveParams: {
    boxOpacityRange: [0.3, 1.0]  // 分類と同期
  }
});
```

**問題**: 現行の `boxOpacityResolver` は関数ベースのカスタマイズであり、以下の課題があります：
- 分類スキーム（log/quantile など）との統合が不可能
- パフォーマンス: 全ボクセルに対して関数呼び出しが発生
- UI 連携: プリセットや凡例との同期が困難
- デバッグ: どのような補間が適用されているか外部から観測できない

#### Use Case 2: 枠線の太さによる密度表現

```javascript
// 問題: 枠線の太さが固定で、密度の違いが分かりにくい
// 現状の回避策: outlineWidthResolver で手動実装
const heatbox = new Heatbox(viewer, {
  outlineWidthResolver: (voxelInfo) => {
    const density = voxelInfo.normalizedDensity;
    return 1 + density * 4;  // 低密度: 1px, 高密度: 5px
  }
});

// 期待: adaptiveParams での宣言的設定
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'quantize',
    classes: 5,
    classificationTargets: {
      color: true,
      width: true  // NEW in v1.1.0
    }
  },
  adaptiveParams: {
    outlineWidthRange: [1, 5]  // 分類と同期
  }
});
```

**問題**: 枠線の太さは視覚的な強調に有効ですが、現行の `outlineWidthResolver` では：
- TopN 強調（`highlightTopN`）との合成ルールが不明確
- 分類による離散的な太さ変化（5段階など）が実装困難
- `outlineRenderMode: 'emulation-only'` 時の適用方法が未定義

#### Use Case 3: 分位数による公平な色分け

```javascript
// 問題: linear スケールでは外れ値に引きずられ、大半のデータが同色になる
// 期待: quantile（分位数）で均等に色分け
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'quantile',  // NEW in v1.1.0
    classes: 5,  // 5分位（各20%ずつ）
    colorMap: ['#ffffcc', '#c2e699', '#78c679', '#31a354', '#006837']
  }
});
```

**問題**: v1.0.0 では quantile が未実装のため、データ分布に偏りがある場合に適切な色分けができません。特に：
- 人口密度データ（ロングテール分布）
- センサー値（正規分布からの外れ値を含む）
- 時系列データ（季節変動やイベント時の急増）

これらのデータでは、quantile による分位点ベースの分類が GIS 標準となっています。

#### Use Case 4: Jenks natural breaks による自然な階級区分

```javascript
// 問題: 等間隔分類では、データの自然なクラスタを無視してしまう
// 期待: jenks（Jenks natural breaks）で最適な境界を自動決定
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'jenks',  // NEW in v1.1.0
    classes: 5,
    colorMap: ['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15']
  }
});
```

**問題**: Jenks natural breaks は、クラス内分散を最小化し、クラス間分散を最大化する最適化アルゴリズムであり、QGIS や ArcGIS では標準機能です。v1.0.0 では未実装のため：
- データの自然なグルーピングを反映できない
- GIS ユーザーが期待する「自動最適化」が利用不可
- 地理統計の標準手法との乖離

#### Use Case 5: エミュレーション時の透明度・太さ適用

```javascript
// 問題: outlineRenderMode: 'emulation-only' 時、opacity/width が適用されない
// 現状: Playground で後処理を手動実装
viewer.scene.postRender.addEventListener(() => {
  polylineEntities.forEach(polyline => {
    polyline.polyline.material.color.alpha = /* 手動計算 */;
    polyline.polyline.width = /* 手動計算 */;
  });
});

// 期待: ライブラリ側で自動適用
const heatbox = new Heatbox(viewer, {
  outlineRenderMode: 'emulation-only',
  classification: {
    enabled: true,
    scheme: 'log',
    classificationTargets: {
      color: true,
      opacity: true,
      width: true
    }
  },
  adaptiveParams: {
    outlineOpacityRange: [0.5, 1.0],
    outlineWidthRange: [1, 3]
  }
  // → エミュレーションポリラインに自動適用
});
```

**問題**: v0.1 系で導入された `outlineRenderMode: 'emulation-only'` は、Box の面に重なる枠線をポリラインで描画する機能ですが、opacity/width の適用が未実装です。Playground では後処理で手動実装していますが：
- ボイラープレート化しており、ライブラリに統合すべき
- `AdaptiveController` の計算結果との同期が手動
- エミュレーション対象（全 outline / inset のみ）の制御が曖昧

### 現状の制限と課題

#### 1. color 以外への分類適用が不可能

v1.0.0 の分類エンジンは `color` のみを対象としており、`opacity` や `width` には適用できません。これにより：
- 多変量可視化（色 + 透明度、色 + 太さ）が実現不可
- 視覚変数の統一的な制御ができず、設定が煩雑化
- GIS 標準（複数視覚変数の同期）との乖離

#### 2. Resolver API の存続による技術的負債

v1.0.0 時点で、`boxOpacityResolver` / `outlineOpacityResolver` / `outlineWidthResolver` は非推奨ながら存続しています（ADR-0013/0014 の方針により、代替実装が安定するまで削除不可）。これにより：
- 新旧 API の混在による混乱
- パフォーマンス: Resolver は全ボクセルに対して関数呼び出し
- 拡張性: Resolver では分類スキームとの統合が困難

v1.1.0 では、**Resolver の機能を `adaptiveParams.*Range` + `classification.classificationTargets` で完全に再現**し、段階的な移行パスを提供する必要があります。

#### 3. quantile / jenks の未実装による GIS 互換性の不足

- **QGIS**: quantile, jenks が標準機能
- **ArcGIS**: quantile（Equal Count）, jenks（Natural Breaks）が標準
- **D3.js**: `d3.scaleQuantile`, ckmeans による jenks 実装

v1.0.0 では、これらの高度スキームが未実装のため、GIS ユーザーにとって学習コストが高く、既存ツールとの互換性が低い状態です。

#### 4. 凡例との連携不足

v1.0.0 では分類境界値（breaks）は計算されますが、UI としての凡例は未実装です。これにより：
- ユーザーは分類の内訳を把握できない
- 色だけでなく、opacity/width の範囲も凡例に表示すべき
- 連続スケール vs 離散スケールで凡例の表現が異なる

### v1.1.0 における拡張スコープ

ROADMAP に示されているとおり、v1.1.0 では以下を実装します:

- **分類対象の拡張**
  - `classificationTargets: { color: boolean, opacity: boolean, width: boolean }`
  - v1.0.0 の `color` に加え、`opacity` と `width` を追加

- **高度スキームの追加**
  - `quantile`（分位数）
  - `jenks`（Jenks natural breaks / ckmeans）
  - これらは **simple-statistics ライブラリ**を利用して実装

- **AdaptiveController との統合**
  - `adaptiveParams.boxOpacityRange: [min, max]`
  - `adaptiveParams.outlineOpacityRange: [min, max]`
  - `adaptiveParams.outlineWidthRange: [min, max]`（新設）
  - これらが分類スキームと同期して補間される

- **エミュレーション連携**
  - `outlineRenderMode: 'emulation-only'` 時、opacity/width をポリラインに自動適用

- **凡例 UI**
  - 連続/離散に応じた凡例表示
  - 色 + 透明度 + 太さの範囲を視覚化

### 既存の挙動と互換性要件

- v1.0.0 との後方互換性を維持
- `classificationTargets` が未指定の場合、デフォルトは `{ color: true }` のみ（v1.0.0 と同じ）
- Resolver API は**引き続き存続**（非推奨警告のみ）
  - **削除は v1.1.0 の Adaptive 実装が安定し、MIGRATION.md / RELEASE_NOTES.md が揃った後**
  - **少なくとも2リリース以上のグレイス期間**を設ける
- 既存のデフォルト設定に対して視覚的な退行がないこと（±10% 以内の差異）

## Decision / 決定事項

### 1. classificationTargets の導入による多変量分類

v1.1.0 では、分類を適用する視覚変数を明示的に指定できる `classificationTargets` オプションを導入します。

```javascript
/**
 * @typedef {Object} ClassificationTargets
 * @property {boolean} [color=true] - 色に分類を適用
 * @property {boolean} [opacity=false] - 透明度に分類を適用（v1.1.0+）
 * @property {boolean} [width=false] - 線の太さに分類を適用（v1.1.0+）
 */

/**
 * @typedef {Object} ClassificationOptions
 * @property {boolean} [enabled=false] - 分類を有効化
 * @property {'linear'|'log'|'equal-interval'|'quantize'|'threshold'|'quantile'|'jenks'} scheme
 * @property {ClassificationTargets} [classificationTargets] - 分類対象の視覚変数
 * @property {number} [classes=5] - クラス数
 * @property {number[]} [thresholds] - threshold 用の境界配列
 * @property {string[]} [colorMap] - 色配列
 * @property {[number, number]} [domain] - 分類に使用する値の範囲（任意）
 */

// 実装上は後方互換性のため `classification.targets` もエイリアスとして受け付け、
// validation.js で `classificationTargets` にマージする。公開API名としては
// `classificationTargets` を正とする。
```

#### 使用例

```javascript
// 色 + 透明度 + 太さを同時に制御
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'quantile',
    classes: 5,
    classificationTargets: {
      color: true,
      opacity: true,
      width: true
    },
    colorMap: ['#ffffcc', '#c2e699', '#78c679', '#31a354', '#006837']
  },
  adaptiveParams: {
    boxOpacityRange: [0.3, 1.0],
    outlineWidthRange: [1, 5]
  }
});

// 色のみ（v1.0.0 と同じ）
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'log',
    classificationTargets: { color: true }  // または省略時のデフォルト
  }
});
```

### 2. quantile / jenks の simple-statistics による実装

v1.1.0 では、ADR-0016 で準備した `simple-statistics` バックエンドを利用して、quantile と jenks を実装します。

#### quantile の実装

```javascript
// src/utils/classification.js（追加部分）

case 'quantile':
  // 分位数による分類
  if (!values || values.length === 0) {
    throw new Error('quantile scheme requires values array');
  }
  
  const backend = getBackend();
  breaks = [min];
  
  for (let i = 1; i < classes; i++) {
    const p = i / classes;
    breaks.push(backend.quantile(values, p));
  }
  breaks.push(max);
  
  normalize = (value) => {
    for (let i = 0; i < breaks.length - 1; i++) {
      if (value <= breaks[i + 1]) {
        // 離散的なクラスインデックス
        return i / (classes - 1);
      }
    }
    return 1;
  };
  break;
```

#### jenks の実装

```javascript
case 'jenks':
  // Jenks natural breaks
  if (!values || values.length === 0) {
    throw new Error('jenks scheme requires values array');
  }
  
  const backend = getBackend();
  const jenksBreaks = backend.jenksBreaks(values, classes);
  
  // backend からの境界値をドメインに合わせて整形
  breaks = [min];
  if (Array.isArray(jenksBreaks)) {
    for (const b of jenksBreaks) {
      if (Number.isFinite(b) && b > min && b < max) {
        breaks.push(b);
      }
    }
  }
  breaks.push(max);
  
  normalize = (value) => {
    for (let i = 0; i < breaks.length - 1; i++) {
      if (value <= breaks[i + 1]) {
        return i / (classes - 1);
      }
    }
    return 1;
  };
  break;
```

### 3. AdaptiveController での統合補間

`AdaptiveController` は、分類エンジンと `adaptiveParams.*Range` を統合し、color/opacity/width を同期して補間します。

※ 実装上のメソッドシグネチャは既存コードと同様に  
`calculateAdaptiveParams(voxelInfo, isTopN, voxelData, statistics, renderOptions, grid)` をベースとし、ここでは
分類エンジンと `adaptiveParams.*Range` を統合するロジックのみを簡略化して示します。

```javascript
// src/core/adaptive/AdaptiveController.js（概念イメージ）

class AdaptiveController {
  calculateAdaptiveParams(voxelInfo, isTopN, voxelData, statistics, renderOptions, grid) {
    const classification = renderOptions.classification;
    const classifier = renderOptions._classifier; // 実装では VoxelRenderer から注入される想定
    
    // 分類が無効な場合は既存の密度ベースロジックのみ適用
    if (!classifier || !classification?.enabled) {
      return this._calculateLegacyAdaptiveParams(voxelInfo, isTopN, voxelData, statistics, renderOptions, grid);
    }

    const value = voxelInfo.count;  // または normalizedDensity / 任意のプロパティ
    const normalized = classifier.normalize(value);
    const classIndex = classifier.classify(value);
    
    const targets = classification.classificationTargets || { color: true };
    const result = {
      normalizedDensity: normalized,
      classIndex
    };
    
    // 色
    if (targets.color) {
      result.color = classifier.getColor(normalized);
    }
    
    // 透明度
    if (targets.opacity) {
      const [minOpacity, maxOpacity] = renderOptions.adaptiveParams?.boxOpacityRange || [0, 1];
      result.boxOpacity = minOpacity + normalized * (maxOpacity - minOpacity);
      
      const [minOutlineOpacity, maxOutlineOpacity] = 
        renderOptions.adaptiveParams?.outlineOpacityRange || [0, 1];
      result.outlineOpacity = minOutlineOpacity + normalized * (maxOutlineOpacity - minOutlineOpacity);
    }
    
    // 太さ
    if (targets.width) {
      const [minWidth, maxWidth] = renderOptions.adaptiveParams?.outlineWidthRange || [1, 5];
      result.outlineWidth = minWidth + normalized * (maxWidth - minWidth);
      
      // TopN ブーストとの合成
      if (isTopN && renderOptions.highlightTopN) {
        result.outlineWidth += renderOptions.highlightTopNWidthBoost || 2;
      }
    }
    
    return result;
  }
}
```

### 4. エミュレーション時の自動適用

`outlineRenderMode: 'emulation-only'` 時、計算された opacity/width をポリラインエンティティに自動適用します。

```javascript
// src/core/geometry/GeometryRenderer.js（エミュレーション処理）

_applyEmulationOutline(voxelInfo, adaptiveParams) {
  if (this.options.outlineRenderMode !== 'emulation-only') return;
  
  const polylineEntity = /* ポリラインエンティティを取得 */;
  
  // 透明度の適用
  if (adaptiveParams.outlineOpacity !== undefined) {
    const color = polylineEntity.polyline.material.color.getValue();
    color.alpha = adaptiveParams.outlineOpacity;
    polylineEntity.polyline.material.color = color;
  }
  
  // 太さの適用
  if (adaptiveParams.outlineWidth !== undefined) {
    polylineEntity.polyline.width = adaptiveParams.outlineWidth;
  }
}
```

### 5. 凡例 UI の実装

分類境界値と視覚変数の範囲を表示する凡例コンポーネントを提供します。

```javascript
// 凡例の生成
const legend = heatbox.createLegend({
  position: 'bottom-right',  // 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'
  style: 'continuous' | 'discrete',  // スキームに応じて自動決定
  showLabels: true,
  showBreaks: true  // 境界値を表示
});

// 凡例の内容（イメージ）
// 連続スケール（linear/log）: グラデーションバー + min/max
// 離散スケール（quantile/jenks）: 階級ごとの色ブロック + 境界値
```

### 6. Resolver API との優先順位（明確化）

v1.1.0 でも、Resolver API は引き続き最優先として扱います:

```javascript
// 優先順位（確定）
1. *Resolver（最優先） - ユーザー定義の関数
2. classification.targets + adaptiveParams.*Range - 新 API
3. baseColor / highlightColor - フォールバック

// 実装イメージ
_getVoxelOpacity(voxelInfo, adaptiveParams) {
  // 1. boxOpacityResolver が最優先
  if (this.options.boxOpacityResolver) {
    return this.options.boxOpacityResolver(voxelInfo);
  }
  
  // 2. classification + adaptiveParams
  if (adaptiveParams.boxOpacity !== undefined) {
    return adaptiveParams.boxOpacity;
  }
  
  // 3. 既存のデフォルト
  return this.options.opacity || 0.8;
}
```

## Architecture / アーキテクチャ

### Component Structure / コンポーネント構造

```
src/
  utils/
    classification.js              # UPDATE: quantile/jenks 追加
    classificationBackend.js       # UPDATE: 統計関数の拡張
    validation.js                  # UPDATE: classificationTargets の検証
    constants.js                   # UPDATE: DEFAULT_OPTIONS 更新
  core/
    adaptive/
      AdaptiveController.js        # UPDATE: opacity/width 補間の実装
    geometry/
      GeometryRenderer.js          # UPDATE: エミュレーション時の適用
    VoxelRenderer.js               # UPDATE: 統合された adaptiveParams の利用
  ui/
    Legend.js                      # NEW: 凡例コンポーネント
  Heatbox.js                       # UPDATE: createLegend API の追加
```

### DataFlow / データフロー

```
1. ユーザーがオプション指定
   ↓
   { 
     classification: { 
       scheme: 'quantile', 
       classificationTargets: { color: true, opacity: true, width: true }
     },
     adaptiveParams: {
       boxOpacityRange: [0.3, 1.0],
       outlineWidthRange: [1, 5]
     }
   }
   ↓
2. validation.js が検証・正規化
   - classificationTargets のデフォルト設定
   - adaptiveParams.*Range の妥当性チェック
   ↓
3. DataProcessor.js が統計情報を計算
   - values 配列の収集
   - quantile 用の分位点計算
   - jenks 用のクラスタリング
   ↓
4. VoxelRenderer._prepareClassifier()
   - createClassifier({ scheme, values, ... })
   - simple-statistics を利用して breaks 計算
   ↓
5. AdaptiveController.calculateAdaptiveParams()
   - classifier.normalize(value)
   - classificationTargets に応じて color/opacity/width を補間
   ↓
6. GeometryRenderer.createVoxelBox()
   - adaptiveParams から color/opacity/width を取得
   - エミュレーション時はポリラインにも適用
   ↓
7. Legend.update()
   - classifier.breaks と classificationTargets から凡例を生成
```

### 統計情報の拡張

```javascript
// DataProcessor.js
getStatistics() {
  return {
    // 既存フィールド
    voxelCount: this._voxelData.size,
    
    // v1.0.0 の分類統計
    classification: {
      enabled: !!this.options.classification?.enabled,
      scheme: this.options.classification?.scheme || 'linear',
      domain: [this._stats.min, this._stats.max],
      
      // v1.1.0: 拡張
      classificationTargets: this.options.classification?.classificationTargets || { color: true },
      quantiles: this._stats.quantiles || null,        // [Q1, Q2, Q3, Q4]
      jenksBreaks: this._stats.jenksBreaks || null,    // [b1, b2, ..., bn]
      ckmeansClusters: this._stats.ckmeansClusters || null  // クラスタ詳細
    },
    
    // v1.1.0: adaptiveParams の実効値
    adaptiveRanges: {
      boxOpacity: this.options.adaptiveParams?.boxOpacityRange || [0, 1],
      outlineOpacity: this.options.adaptiveParams?.outlineOpacityRange || [0, 1],
      outlineWidth: this.options.adaptiveParams?.outlineWidthRange || [1, 5]
    }
  };
}
```

## Detailed Design / 詳細設計

### 1. quantile 実装の詳細

```javascript
// src/utils/classification.js

/**
 * 分位数による分類を生成
 * @param {number[]} values - データ配列
 * @param {number} classes - クラス数
 * @returns {{ breaks: number[], normalize: Function }}
 */
function createQuantileClassifier(values, classes) {
  const backend = getBackend();
  const min = Math.min(...values);
  const max = Math.max(...values);
  
  // 分位点を計算
  const breaks = [min];
  for (let i = 1; i < classes; i++) {
    const p = i / classes;
    const quantileValue = backend.quantile(values, p);
    breaks.push(quantileValue);
  }
  breaks.push(max);
  
  // 正規化関数
  const normalize = (value) => {
    // どのクラスに属するか判定
    for (let i = 0; i < breaks.length - 1; i++) {
      if (value <= breaks[i + 1]) {
        // 離散的なクラスインデックスを [0, 1] に正規化
        return i / (classes - 1);
      }
    }
    return 1;
  };
  
  // クラス分類関数
  const classify = (value) => {
    for (let i = 0; i < breaks.length - 1; i++) {
      if (value <= breaks[i + 1]) {
        return i;
      }
    }
    return classes - 1;
  };
  
  return { breaks, normalize, classify };
}
```

### 2. jenks 実装の詳細

```javascript
/**
 * Jenks natural breaks による分類を生成
 * @param {number[]} values - データ配列
 * @param {number} classes - クラス数
 * @returns {{ breaks: number[], normalize: Function, classify: Function }}
 */
function createJenksClassifier(values, classes) {
  const backend = getBackend();
  
  // backend から Jenks 境界値を取得
  const min = Math.min(...values);
  const max = Math.max(...values);
  const jenksBreaks = backend.jenksBreaks(values, classes);
  
  // 各クラスタの境界値を計算（ドメイン外の値は除外）
  const breaks = [min];
  if (Array.isArray(jenksBreaks)) {
    for (const b of jenksBreaks) {
      if (Number.isFinite(b) && b > min && b < max) {
        breaks.push(b);
      }
    }
  }
  breaks.push(max);
  
  // 正規化関数
  const normalize = (value) => {
    for (let i = 0; i < breaks.length - 1; i++) {
      if (value <= breaks[i + 1]) {
        return i / (classes - 1);
      }
    }
    return 1;
  };
  
  const classify = (value) => {
    for (let i = 0; i < breaks.length - 1; i++) {
      if (value <= breaks[i + 1]) {
        return i;
      }
    }
    return classes - 1;
  };
  
  return { breaks, normalize, classify };
}
```

### 3. AdaptiveController の opacity/width 補間

```javascript
// src/core/adaptive/AdaptiveController.js

class AdaptiveController {
  /**
   * ボクセルごとの適応パラメータを計算
   * @param {Object} voxelInfo
   * @param {boolean} isTopN
   * @param {Map} voxelData
   * @param {Object} statistics
   * @param {Object} options
   * @returns {Object} adaptiveParams
   */
  calculateAdaptiveParams(voxelInfo, isTopN, voxelData, statistics, options, grid) {
    const classifier = options._classifier;
    const value = this._getClassificationValue(voxelInfo, options);
    const normalized = classifier ? classifier.normalize(value) : 0;
    const classIndex = classifier ? classifier.classify(value) : 0;
    
    const targets = options.classification?.classificationTargets || { color: true };
    const result = {
      normalizedDensity: normalized,
      classIndex: classIndex
    };
    
    // 色の補間
    if (targets.color) {
      result.color = classifier.getColor(normalized);
    }
    
    // 透明度の補間
    if (targets.opacity) {
      result.boxOpacity = this._interpolateOpacity(
        normalized,
        options.adaptiveParams?.boxOpacityRange || [0, 1]
      );
      
      result.outlineOpacity = this._interpolateOpacity(
        normalized,
        options.adaptiveParams?.outlineOpacityRange || [0, 1]
      );
    }
    
    // 太さの補間
    if (targets.width) {
      result.outlineWidth = this._interpolateWidth(
        normalized,
        options.adaptiveParams?.outlineWidthRange || [1, 5],
        voxelInfo.isTopN,
        options.highlightTopNWidthBoost || 0
      );
    }
    
    return result;
  }
  
  _interpolateOpacity(normalized, range) {
    const [min, max] = range;
    return Math.max(0, Math.min(1, min + normalized * (max - min)));
  }
  
  _interpolateWidth(normalized, range, isTopN, boost) {
    const [min, max] = range;
    let width = min + normalized * (max - min);
    
    // TopN ブーストの加算
    if (isTopN && boost > 0) {
      width += boost;
    }
    
    return Math.max(0.1, width);  // 最小値のクランプ
  }
  
  _getClassificationValue(voxelInfo, options) {
    // 分類に使用する値を取得
    const valueProperty = options.classification?.valueProperty || 'count';
    return voxelInfo[valueProperty] || voxelInfo.count;
  }
}
```

### 4. エミュレーション連携の詳細

```javascript
// src/core/geometry/GeometryRenderer.js

class GeometryRenderer {
  /**
   * ボクセルボックスを作成し、エミュレーション時は枠線も処理
   */
  createVoxelBox(voxelInfo, adaptiveParams) {
    // Box エンティティの作成
    const boxEntity = this._createBoxEntity(voxelInfo, adaptiveParams);
    
    // エミュレーション時の処理
    if (this.options.outlineRenderMode === 'emulation-only') {
      this._createEmulationOutline(voxelInfo, adaptiveParams);
    }
    
    return boxEntity;
  }
  
  /**
   * エミュレーション用のポリラインを作成し、opacity/width を適用
   */
  _createEmulationOutline(voxelInfo, adaptiveParams) {
    const { center, dimensions } = voxelInfo.bounds;
    
    // ボックスの12辺をポリラインで描画
    const edges = this._computeBoxEdges(center, dimensions);
    
    edges.forEach(edge => {
      const polylineEntity = this.viewer.entities.add({
        polyline: {
          positions: edge,
          width: adaptiveParams.outlineWidth || this.options.outlineWidth || 2,
          material: new Cesium.Color.fromCssColorString(
            this.options.outlineColor || '#ffffff'
          )
        }
      });
      
      // 透明度の適用
      if (adaptiveParams.outlineOpacity !== undefined) {
        const color = polylineEntity.polyline.material.color.getValue();
        color.alpha = adaptiveParams.outlineOpacity;
        polylineEntity.polyline.material.color = color;
      }
      
      // エミュレーション対象として追跡
      this._emulationEntities.push(polylineEntity);
    });
  }
  
  /**
   * ボックスの12辺の座標を計算
   */
  _computeBoxEdges(center, dimensions) {
    const { width, height, depth } = dimensions;
    const halfW = width / 2;
    const halfH = height / 2;
    const halfD = depth / 2;
    
    // 8頂点
    const vertices = [
      Cesium.Cartesian3.add(center, new Cesium.Cartesian3(-halfW, -halfH, -halfD), new Cesium.Cartesian3()),
      // ... 残り7頂点
    ];
    
    // 12辺（各辺は2頂点の配列）
    return [
      [vertices[0], vertices[1]],
      [vertices[1], vertices[2]],
      // ... 残り10辺
    ];
  }
}
```

### 5. 凡例コンポーネントの実装

```javascript
// src/ui/Legend.js（新規）

/**
 * 分類凡例を生成・管理するクラス
 */
export class Legend {
  constructor(viewer, classifier, options) {
    this.viewer = viewer;
    this.classifier = classifier;
    this.options = options;
    this.container = null;
  }
  
  /**
   * 凡例を生成して DOM に追加
   */
  create() {
    this.container = document.createElement('div');
    this.container.className = 'heatbox-legend';
    this.container.style.position = 'absolute';
    this.container.style.cssText = this._getPositionStyle();
    
    // 連続 vs 離散で表示を切り替え
    if (this._isContinuousScheme()) {
      this._renderContinuousLegend();
    } else {
      this._renderDiscreteLegend();
    }
    
    this.viewer.container.appendChild(this.container);
  }
  
  /**
   * 連続スケール用の凡例（グラデーションバー）
   */
  _renderContinuousLegend() {
    const { breaks, scheme } = this.classifier;
    const [min, max] = [breaks[0], breaks[breaks.length - 1]];
    
    // グラデーションバーの生成
    const bar = document.createElement('div');
    bar.style.width = '200px';
    bar.style.height = '20px';
    bar.style.background = this._createGradientCSS();
    
    // ラベル（min/max）
    const labelMin = document.createElement('span');
    labelMin.textContent = min.toFixed(2);
    const labelMax = document.createElement('span');
    labelMax.textContent = max.toFixed(2);
    
    this.container.appendChild(labelMin);
    this.container.appendChild(bar);
    this.container.appendChild(labelMax);
  }
  
  /**
   * 離散スケール用の凡例（階級ブロック）
   */
  _renderDiscreteLegend() {
    const { breaks } = this.classifier;
    
    for (let i = 0; i < breaks.length - 1; i++) {
      const classBlock = document.createElement('div');
      classBlock.style.display = 'flex';
      classBlock.style.alignItems = 'center';
      classBlock.style.marginBottom = '4px';
      
      // 色ブロック
      const colorBox = document.createElement('div');
      colorBox.style.width = '30px';
      colorBox.style.height = '20px';
      const normalized = i / (breaks.length - 2);
      colorBox.style.backgroundColor = this.classifier.getColor(normalized).toCssColorString();
      
      // 範囲ラベル
      const label = document.createElement('span');
      label.style.marginLeft = '8px';
      label.textContent = `${breaks[i].toFixed(2)} – ${breaks[i + 1].toFixed(2)}`;
      
      classBlock.appendChild(colorBox);
      classBlock.appendChild(label);
      this.container.appendChild(classBlock);
    }
  }
  
  _isContinuousScheme() {
    return ['linear', 'log'].includes(this.classifier.scheme);
  }
  
  _createGradientCSS() {
    const colorStops = [];
    for (let i = 0; i <= 10; i++) {
      const normalized = i / 10;
      const color = this.classifier.getColor(normalized).toCssColorString();
      colorStops.push(`${color} ${i * 10}%`);
    }
    return `linear-gradient(to right, ${colorStops.join(', ')})`;
  }
  
  _getPositionStyle() {
    const position = this.options.position || 'bottom-right';
    const styles = {
      'top-left': 'top: 10px; left: 10px;',
      'top-right': 'top: 10px; right: 10px;',
      'bottom-left': 'bottom: 10px; left: 10px;',
      'bottom-right': 'bottom: 10px; right: 10px;'
    };
    return styles[position] || styles['bottom-right'];
  }
  
  /**
   * 凡例を更新（分類パラメータ変更時）
   */
  update(newClassifier, newOptions) {
    this.classifier = newClassifier;
    this.options = { ...this.options, ...newOptions };
    
    if (this.container) {
      this.container.innerHTML = '';
      if (this._isContinuousScheme()) {
        this._renderContinuousLegend();
      } else {
        this._renderDiscreteLegend();
      }
    }
  }
  
  /**
   * 凡例を削除
   */
  destroy() {
    if (this.container && this.container.parentNode) {
      this.container.parentNode.removeChild(this.container);
    }
    this.container = null;
  }
}
```

### 6. Heatbox.createLegend API

```javascript
// src/Heatbox.js（追加）

/**
 * 凡例を生成
 * @param {Object} options - 凡例オプション
 * @returns {Legend} 凡例インスタンス
 */
createLegend(options = {}) {
  if (!this._classifier) {
    throw new Error('Classification must be enabled to create legend');
  }
  
  const legend = new Legend(this.viewer, this._classifier, options);
  legend.create();
  
  // Heatbox インスタンスに保持
  this._legend = legend;
  
  return legend;
}

/**
 * 凡例を更新（分類パラメータ変更時に自動呼び出し）
 */
_updateLegend() {
  if (this._legend && this._classifier) {
    this._legend.update(this._classifier, this.options.classification);
  }
}

/**
 * 凡例を削除
 */
destroyLegend() {
  if (this._legend) {
    this._legend.destroy();
    this._legend = null;
  }
}
```

## Implementation Plan / 実装計画

### Phase 0: 準備（Day 0）

- [ ] ADR-0017（本ドキュメント）の最終化とレビュー完了
- [ ] ROADMAP v1.1.0 の Acceptance Criteria と本 ADR の受け入れ基準をすり合わせ
- [ ] ADR-0016 (v1.0.0) の実装状況を確認し、v1.1.0 の前提条件を満たしているか検証

### Phase 1: quantile / jenks の実装（Days 1-3）

- [ ] `src/utils/classification.js` に `quantile` スキームを追加
  - `createQuantileClassifier` 関数の実装
  - simple-statistics の `quantile` 関数の利用
- [ ] `src/utils/classification.js` に `jenks` スキームを追加
  - `createJenksClassifier` 関数の実装
  - simple-statistics の `ckmeans` 関数の利用
- [ ] 単体テスト: `test/utils/classification.test.js` に quantile/jenks のテストを追加
  - 分位点の正確性（既知データでの検証）
  - jenks の境界値が最適化されていることを確認

### Phase 2: classificationTargets の実装（Days 4-6）

- [ ] `validation.js` に `classificationTargets` の検証ロジックを追加
  - デフォルト: `{ color: true }`
  - `opacity` / `width` の boolean 検証
- [ ] `constants.js` の `DEFAULT_OPTIONS.classification` を更新
- [ ] `src/utils/classification.js` の `createClassifier` を更新
  - `quantile` / `jenks` スキームとの連携を確認
- [ ] 単体テスト: `test/utils/classification.test.js` に classificationTargets/スキームのテストを追加

### Phase 3: AdaptiveController の opacity/width 補間（Days 7-10）

- [ ] `src/core/adaptive/AdaptiveController.js` を実装
  - `calculateAdaptiveParams` メソッドの実装
  - `_interpolateOpacity` / `_interpolateWidth` ヘルパーの実装
  - TopN ブーストとの合成ロジック
- [ ] `src/core/VoxelRenderer.js` を更新
  - `AdaptiveController` から取得した `adaptiveParams` を利用
  - Resolver との優先順位の実装
- [ ] 単体テスト: `test/core/adaptive/AdaptiveController.test.js`（新規）
  - opacity/width の補間が正しいことを検証
  - TopN ブーストの加算を検証
- [ ] 統合テスト: `test/integration/classification-targets.test.js`（新規）
  - color + opacity + width の同時適用を検証

### Phase 4: エミュレーション連携（Days 11-13）

- [ ] `src/core/geometry/GeometryRenderer.js` を更新
  - `_createEmulationOutline` メソッドの実装
  - `_computeBoxEdges` ヘルパーの実装
  - opacity/width のポリラインへの適用
- [ ] エミュレーション対象の制御
  - `emulationScope: 'all' | 'inset-only'` オプションの追加
- [ ] 単体テスト: `test/core/geometry/GeometryRenderer.test.js` の更新
  - エミュレーション時の opacity/width 適用を検証
- [ ] 統合テスト: `test/integration/emulation.test.js`（新規）
  - `outlineRenderMode: 'emulation-only'` での動作確認

### Phase 5: 凡例 UI の実装（Days 14-16）

- [ ] `src/ui/Legend.js` を新規作成
  - `Legend` クラスの実装
  - 連続/離散スケールの表示切り替え
- [ ] `src/Heatbox.js` に `createLegend` API を追加
  - 凡例の生成・更新・削除
- [ ] CSS スタイルの追加（`dist/heatbox.css` または inline）
- [ ] 単体テスト: `test/ui/Legend.test.js`（新規）
  - 凡例の DOM 生成を検証
- [ ] 統合テスト: `test/integration/legend.test.js`（新規）
  - Heatbox との連携を検証

### Phase 6: DataProcessor 統計拡張（Days 17-18）

- [ ] `src/core/DataProcessor.js` を更新
  - values 配列の収集（quantile/jenks 用）
  - 分位点・クラスタ情報の計算
  - `getStatistics()` に `quantiles` / `jenksBreaks` / `ckmeansClusters` を追加
- [ ] 単体テスト: `test/core/DataProcessor.test.js` の更新
  - 統計情報の正確性を検証

### Phase 7: Examples & Documentation（Days 19-22）

- [ ] `examples/advanced/classification-extension-demo.html` を作成
  - quantile/jenks のデモ
  - color + opacity + width の同時制御
  - 凡例の表示
- [ ] `examples/advanced/emulation-opacity-demo.html` を作成
  - エミュレーション時の opacity/width 適用デモ
- [ ] README の Classification セクションを更新
- [ ] API.md の更新（`classificationTargets`, `adaptiveParams.*Range`, `createLegend`）
- [ ] MIGRATION.md の作成
  - Resolver → adaptiveParams の移行例
  - 視覚的パリティの比較スクリーンショット

### Phase 8: Performance & QA（Days 23-25）

- [ ] パフォーマンステスト: 1k–5k ボクセルでの処理時間
  - 目標: v1.0.0 と比較して ≤ +15% のオーバーヘッド
- [ ] メモリテスト: メモリ使用量の増加 ≤ +10%
- [ ] ビジュアル回帰テスト: Resolver を使った既存 examples との視覚的パリティ
- [ ] Lint & Type Check: `npm run lint && npm run type-check`

### Phase 9: CI & Release Preparation（Days 26-28）

- [ ] CI でのテスト実行（全テストグリーン）
- [ ] `package.json` のバージョンを `1.1.0-alpha.1` に更新
- [ ] `src/index.js` の `VERSION` を同期
- [ ] CHANGELOG.md の更新
- [ ] タグ作成 & GitHub Actions での npm publish

## Testing Strategy / テスト戦略

### Unit Tests / 単体テスト

#### 1. quantile / jenks のテスト

```javascript
// test/utils/classification.test.js

describe('classification - quantile', () => {
  it('should create correct quantile breaks', () => {
    const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const classifier = createClassifier({
      scheme: 'quantile',
      values: values,
      classes: 4  // 4分位
    });
    
    // 期待される分位点: [1, 3.25, 5.5, 7.75, 10]
    expect(classifier.breaks.length).toBe(5);
    expect(classifier.breaks[0]).toBe(1);
    expect(classifier.breaks[1]).toBeCloseTo(3.25, 1);
    expect(classifier.breaks[2]).toBeCloseTo(5.5, 1);
    expect(classifier.breaks[3]).toBeCloseTo(7.75, 1);
    expect(classifier.breaks[4]).toBe(10);
  });
  
  it('should classify values into correct quantiles', () => {
    const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const classifier = createClassifier({
      scheme: 'quantile',
      values: values,
      classes: 4
    });
    
    expect(classifier.classify(2)).toBe(0);    // 第1四分位
    expect(classifier.classify(4)).toBe(1);    // 第2四分位
    expect(classifier.classify(6)).toBe(2);    // 第3四分位
    expect(classifier.classify(9)).toBe(3);    // 第4四分位
  });
});

describe('classification - jenks', () => {
  it('should create optimal jenks breaks', () => {
    // 既知のクラスタを持つデータ
    const values = [1, 2, 3, 10, 11, 12, 20, 21, 22];
    const classifier = createClassifier({
      scheme: 'jenks',
      values: values,
      classes: 3
    });
    
    // 期待: [1, 10, 20] 付近でクラスタが分かれる
    expect(classifier.breaks.length).toBe(4);
    expect(classifier.breaks[1]).toBeGreaterThanOrEqual(3);
    expect(classifier.breaks[1]).toBeLessThanOrEqual(10);
    expect(classifier.breaks[2]).toBeGreaterThanOrEqual(12);
    expect(classifier.breaks[2]).toBeLessThanOrEqual(20);
  });
  
  it('should minimize within-cluster variance', () => {
    const values = [1, 2, 3, 10, 11, 12, 20, 21, 22];
    const classifier = createClassifier({
      scheme: 'jenks',
      values: values,
      classes: 3
    });
    
    // クラスタ内の分散が小さいことを検証（classify を用いてクラスタを構築）
    const clusters = new Map();
    values.forEach(v => {
      const idx = classifier.classify(v);
      if (!clusters.has(idx)) {
        clusters.set(idx, []);
      }
      clusters.get(idx).push(v);
    });
    
    for (const cluster of clusters.values()) {
      const mean = cluster.reduce((sum, v) => sum + v, 0) / cluster.length;
      const variance = cluster.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / cluster.length;
      
      // 各クラスタの分散が小さい（閾値は調整可）
      expect(variance).toBeLessThan(5);
    }
  });
});
```

#### 2. classificationTargets のテスト

```javascript
// test/utils/classification.test.js

describe('classification - classificationTargets', () => {
  it('should apply classification to color only by default', () => {
    const options = normalizeClassificationOptions(undefined);
    expect(options.classificationTargets).toEqual({ color: true });
  });
  
  it('should support opacity and width flags', () => {
    const options = normalizeClassificationOptions({
      enabled: true,
      scheme: 'log',
      classificationTargets: {
        color: true,
        opacity: true,
        width: true
      }
    });
    
    expect(options.classificationTargets.color).toBe(true);
    expect(options.classificationTargets.opacity).toBe(true);
    expect(options.classificationTargets.width).toBe(true);
  });
});
```

#### 3. AdaptiveController のテスト

```javascript
// test/core/adaptive/AdaptiveController.test.js

describe('AdaptiveController', () => {
  let controller;
  
  beforeEach(() => {
    controller = new AdaptiveController();
  });
  
  it('should interpolate opacity based on normalized density', () => {
    const classifier = createClassifier({
      scheme: 'linear',
      domain: [0, 100]
    });
    
    const voxelInfo = { count: 50, normalizedDensity: 0.5 };
    const options = {
      classification: {
        enabled: true,
        classificationTargets: { opacity: true }
      },
      adaptiveParams: {
        boxOpacityRange: [0.2, 0.8]
      }
    };
    
    const result = controller.calculateAdaptiveParams(voxelInfo, classifier, options);
    
    expect(result.boxOpacity).toBeCloseTo(0.5, 2);  // 0.2 + 0.5 * (0.8 - 0.2) = 0.5
  });
  
  it('should interpolate width with TopN boost', () => {
    const classifier = createClassifier({
      scheme: 'linear',
      domain: [0, 100]
    });
    
    const voxelInfo = { count: 80, normalizedDensity: 0.8, isTopN: true };
    const options = {
      classification: {
        enabled: true,
        classificationTargets: { width: true }
      },
      adaptiveParams: {
        outlineWidthRange: [1, 5]
      },
      highlightTopNWidthBoost: 2
    };
    
    const result = controller.calculateAdaptiveParams(voxelInfo, classifier, options);
    
    // 1 + 0.8 * (5 - 1) + 2 (boost) = 6.2
    expect(result.outlineWidth).toBeCloseTo(6.2, 2);
  });
  
  it('should respect Resolver priority', () => {
    const classifier = createClassifier({
      scheme: 'linear',
      domain: [0, 100]
    });
    
    const voxelInfo = { count: 50 };
    const options = {
      classification: {
        enabled: true,
        classificationTargets: { opacity: true }
      },
      adaptiveParams: {
        boxOpacityRange: [0.2, 0.8]
      },
      boxOpacityResolver: () => 0.9  // Resolver が優先
    };
    
    // calculateAdaptiveParams は Resolver をチェックしないので、
    // 実際の優先順位は VoxelRenderer で処理される
    // ここでは AdaptiveController が計算した値を検証
    const result = controller.calculateAdaptiveParams(voxelInfo, classifier, options);
    expect(result.boxOpacity).toBeDefined();
  });
});
```

### Integration Tests / 統合テスト

#### classification-targets.test.js

```javascript
// test/integration/classification-targets.test.js

import { Heatbox } from '../../src/Heatbox.js';
import { createMockViewer, generateTestEntities } from '../helpers.js';

describe('Classification Targets Integration', () => {
  let viewer, heatbox;

  beforeEach(() => {
    viewer = createMockViewer();
  });

  afterEach(() => {
    heatbox?.destroy();
  });

  it('should apply quantile classification to color + opacity + width', async () => {
    const entities = generateTestEntities(100, { densityRange: [1, 100] });
    
    heatbox = new Heatbox(viewer, {
      classification: {
        enabled: true,
        scheme: 'quantile',
        classes: 5,
        classificationTargets: {
          color: true,
          opacity: true,
          width: true
        },
        colorMap: ['blue', 'cyan', 'yellow', 'orange', 'red']
      },
      adaptiveParams: {
        boxOpacityRange: [0.3, 1.0],
        outlineWidthRange: [1, 5]
      }
    });
    
    await heatbox.createFromEntities(entities);
    
    const stats = heatbox.getStatistics();
    expect(stats.classification.enabled).toBe(true);
    expect(stats.classification.scheme).toBe('quantile');
    expect(stats.classification.targets).toEqual({
      color: true,
      opacity: true,
      width: true
    });
    
    // ボクセルの視覚属性を検証
    const voxels = Array.from(heatbox._voxelData.values());
    
    // 低密度ボクセル（第1四分位）
    const lowDensityVoxel = voxels.find(v => v.classIndex === 0);
    expect(lowDensityVoxel.color.blue).toBeGreaterThan(0.5);  // 青系
    expect(lowDensityVoxel.boxOpacity).toBeCloseTo(0.3, 1);   // 低透明度
    expect(lowDensityVoxel.outlineWidth).toBeCloseTo(1, 1);   // 細い
    
    // 高密度ボクセル（第5四分位）
    const highDensityVoxel = voxels.find(v => v.classIndex === 4);
    expect(highDensityVoxel.color.red).toBeGreaterThan(0.5);  // 赤系
    expect(highDensityVoxel.boxOpacity).toBeCloseTo(1.0, 1);  // 高透明度
    expect(highDensityVoxel.outlineWidth).toBeCloseTo(5, 1);  // 太い
  });

  it('should apply jenks classification with natural breaks', async () => {
    // クラスタ構造を持つデータ
    const entities = [
      ...generateTestEntities(30, { densityRange: [1, 5] }),    // 低密度クラスタ
      ...generateTestEntities(30, { densityRange: [20, 25] }),  // 中密度クラスタ
      ...generateTestEntities(30, { densityRange: [80, 90] })   // 高密度クラスタ
    ];
    
    heatbox = new Heatbox(viewer, {
      classification: {
        enabled: true,
        scheme: 'jenks',
        classes: 3,
        classificationTargets: { color: true, opacity: true }
      }
    });
    
    await heatbox.createFromEntities(entities);
    
    const stats = heatbox.getStatistics();
    expect(stats.classification.jenksBreaks).toBeDefined();
    expect(stats.classification.jenksBreaks.length).toBe(4);  // 3クラス = 4境界
    
    // 境界値が自然なクラスタを反映していることを確認
    const breaks = stats.classification.jenksBreaks;
    expect(breaks[1]).toBeGreaterThan(5);
    expect(breaks[1]).toBeLessThan(20);
    expect(breaks[2]).toBeGreaterThan(25);
    expect(breaks[2]).toBeLessThan(80);
  });

  it('should maintain backward compatibility when targets not specified', async () => {
    const entities = generateTestEntities(100);
    
    // v1.0.0 と同じ設定（targets 省略）
    heatbox = new Heatbox(viewer, {
      classification: {
        enabled: true,
        scheme: 'log',
        colorMap: ['blue', 'red']
      }
    });
    
    await heatbox.createFromEntities(entities);
    
    const stats = heatbox.getStatistics();
    expect(stats.classification.targets).toEqual({ color: true });  // デフォルト
    
    // opacity/width は適用されていない
    const voxels = Array.from(heatbox._voxelData.values());
    voxels.forEach(v => {
      expect(v.boxOpacity).toBeUndefined();
      expect(v.outlineWidth).toBeUndefined();
    });
  });
});
```

#### emulation.test.js

```javascript
// test/integration/emulation.test.js

describe('Emulation Opacity/Width Integration', () => {
  it('should apply opacity and width to emulation polylines', async () => {
    const entities = generateTestEntities(50);
    
    heatbox = new Heatbox(viewer, {
      outlineRenderMode: 'emulation-only',
      classification: {
        enabled: true,
        scheme: 'linear',
        classificationTargets: {
          opacity: true,
          width: true
        }
      },
      adaptiveParams: {
        outlineOpacityRange: [0.5, 1.0],
        outlineWidthRange: [1, 4]
      }
    });
    
    await heatbox.createFromEntities(entities);
    
    // エミュレーションポリラインが生成されていることを確認
    const polylineEntities = viewer.entities.values.filter(e => e.polyline);
    expect(polylineEntities.length).toBeGreaterThan(0);
    
    // 各ポリラインに opacity/width が適用されていることを確認
    polylineEntities.forEach(entity => {
      const material = entity.polyline.material;
      const width = entity.polyline.width;
      
      expect(material.color.getValue().alpha).toBeGreaterThanOrEqual(0.5);
      expect(material.color.getValue().alpha).toBeLessThanOrEqual(1.0);
      expect(width.getValue()).toBeGreaterThanOrEqual(1);
      expect(width.getValue()).toBeLessThanOrEqual(4);
    });
  });
});
```

### Performance Tests / パフォーマンステスト

```javascript
// test/performance/classification-extension.perf.test.js

describe('Classification Extension Performance', () => {
  it('should have ≤ +15% overhead vs v1.0.0', async () => {
    const entities = generateTestEntities(5000);
    
    // Baseline: v1.0.0 (color only)
    const start1 = performance.now();
    const heatbox1 = new Heatbox(viewer, {
      classification: {
        enabled: true,
        scheme: 'log',
        classificationTargets: { color: true }
      }
    });
    await heatbox1.createFromEntities(entities);
    const baselineTime = performance.now() - start1;
    
    // v1.1.0: color + opacity + width
    const start2 = performance.now();
    const heatbox2 = new Heatbox(viewer, {
      classification: {
        enabled: true,
        scheme: 'quantile',
        classificationTargets: {
          color: true,
          opacity: true,
          width: true
        }
      }
    });
    await heatbox2.createFromEntities(entities);
    const extensionTime = performance.now() - start2;
    
    const overhead = (extensionTime - baselineTime) / baselineTime;
    expect(overhead).toBeLessThanOrEqual(0.15);  // ≤ +15%
    
    heatbox1.destroy();
    heatbox2.destroy();
  });

  it('should have ≤ +10% memory overhead', async () => {
    const entities = generateTestEntities(5000);
    
    // Baseline
    const mem1 = process.memoryUsage().heapUsed;
    const heatbox1 = new Heatbox(viewer, {
      classification: {
        enabled: true,
        scheme: 'log',
        classificationTargets: { color: true }
      }
    });
    await heatbox1.createFromEntities(entities);
    const baselineMem = process.memoryUsage().heapUsed - mem1;
    
    // v1.1.0
    const mem2 = process.memoryUsage().heapUsed;
    const heatbox2 = new Heatbox(viewer, {
      classification: {
        enabled: true,
        scheme: 'jenks',
        classificationTargets: {
          color: true,
          opacity: true,
          width: true
        }
      }
    });
    await heatbox2.createFromEntities(entities);
    const extensionMem = process.memoryUsage().heapUsed - mem2;
    
    const overhead = (extensionMem - baselineMem) / baselineMem;
    expect(overhead).toBeLessThanOrEqual(0.10);  // ≤ +10%
    
    heatbox1.destroy();
    heatbox2.destroy();
  });
});
```

## Alternatives Considered / 検討した代替案

### 1. Resolver API の完全削除

#### 利点
- API の簡素化
- パフォーマンス: 関数呼び出しオーバーヘッドの削減
- メンテナンスコストの低減

#### 採用しなかった理由
- **ROADMAP および ADR-0013/0014 の方針**: 代替実装が安定するまで Resolver を削除しない
- **既存ユーザーへの影響**: 多くのユーザーが Resolver を使用しており、段階的な移行が必要
- **v1.1.0 のスコープ**: Resolver の削除は v1.1.0 安定後、少なくとも2リリースのグレイス期間を経てから実施

### 2. gamma / easing の同時実装

#### 利点
- より高度な補間制御（ガンマ補正、イージング関数）
- D3.js との互換性向上

#### 採用しなかった理由
- **スコープの肥大化**: v1.1.0 は既に quantile/jenks/targets 拡張で十分なスコープ
- **ユーザーニーズの不確定性**: gamma/easing のニーズは quantile/jenks より低い
- **実装の複雑化**: easing 関数のライブラリ選定と統合が追加の技術的負債となる
- **将来対応可能**: v1.2.0 以降で追加可能な設計とする

### 3. 凡例の外部ライブラリ利用（Chart.js / D3.js）

#### 利点
- 高機能な凡例 UI（インタラクティブ、アニメーション）
- 既存のデザインパターン

#### 採用しなかった理由
- **依存関係の増加**: Chart.js や D3.js は大きな依存関係
- **オーバーエンジニアリング**: 凡例は単純な DOM 操作で十分
- **カスタマイズ性**: 自前実装の方がユーザーが CSS でカスタマイズしやすい
- **バンドルサイズ**: 軽量な実装を優先

### 4. WebGL ベースのカラーマップ描画

#### 利点
- パフォーマンス: GPU での色補間
- 大規模データでの高速化

#### 採用しなかった理由
- **v3.x の Primitive 化と重複**: ROADMAP で v3.0.0 に Primitive ベース描画が計画されている
- **Entity API の限界**: 現行の Entity ベースでは WebGL の直接制御が困難
- **スコープ外**: v1.1.0 は分類ロジックの拡張であり、レンダリング基盤の変更は含まない

## Consequences / 影響

### Positive / 利点

#### 1. 多変量可視化の実現
- 色・透明度・太さを統一的に制御し、データの多面的な理解が可能
- GIS 標準の複数視覚変数の同期が実現

#### 2. GIS 標準への完全対応
- quantile / jenks により、QGIS / ArcGIS との互換性が大幅に向上
- 地理統計の標準手法をすべてカバー

#### 3. Resolver からの段階的移行
- `adaptiveParams.*Range` により、Resolver の機能を宣言的に再現
- 視覚的パリティを達成し、既存ユーザーが安心して移行可能

#### 4. 凡例による観測可能性の向上
- 分類境界値と視覚変数の範囲が一目で分かる
- データ可視化の透明性が向上

#### 5. エミュレーション連携の完成
- Playground での後処理をライブラリに統合
- ユーザーのボイラープレートコードを削減

### Negative / トレードオフ

#### 1. API の複雑化
- `classificationTargets`, `adaptiveParams.boxOpacityRange` / `outlineOpacityRange` / `outlineWidthRange` など新オプションの追加
- ユーザーの学習コストが増加

#### 2. simple-statistics への依存
- quantile/jenks のために simple-statistics を利用
- バンドルサイズが約 50KB 増加（v1.0.0 で既に導入済み）

#### 3. パフォーマンスオーバーヘッド
- opacity/width の補間計算が追加
- 目標: v1.0.0 比で ≤ +15% の処理時間増加

#### 4. Resolver の存続による混乱
- 新旧 API が混在し、どちらを使うべきか不明確になる可能性
- Migration Guide とドキュメントで明確化する必要

### Risks & Mitigations / リスク & 緩和策

#### Risk 1: quantile/jenks のパフォーマンス劣化

大規模データ（10,000+ ボクセル）で quantile/jenks の計算コストが高くなる可能性。

**Mitigation**:
- simple-statistics の ckmeans（jenksBreaks の内部実装）は O(n² k) の計算量
- データサイズが大きい場合、警告を表示し、サンプリングを推奨
- キャッシュ: 同じ values 配列に対して再計算を避ける

```javascript
// キャッシュの実装例
let _cachedBreaks = null;
let _cachedValuesHash = null;

function createJenksClassifier(values, classes) {
  const valuesHash = hashArray(values);
  
  if (_cachedValuesHash === valuesHash && _cachedBreaks) {
    return _cachedBreaks;
  }
  
  const backend = getBackend();
  const jenksBreaks = backend.jenksBreaks(values, classes);
  // ...
  
  _cachedValuesHash = valuesHash;
  _cachedBreaks = { breaks, normalize, classify, jenksBreaks };
  
  return _cachedBreaks;
}
```

#### Risk 2: エミュレーション時のエンティティ爆発

ボクセル数が多い場合、エミュレーションポリラインが大量に生成され、メモリとパフォーマンスが劣化する可能性。

**Mitigation**:
- `emulationScope: 'inset-only'` オプションで、inset 枠線のみをエミュレーション
- エミュレーション対象の最大数を制限（例: 1,000 ボクセルまで）
- 警告ログ: 大量のボクセルでエミュレーションを使用する場合、パフォーマンスへの影響を通知

#### Risk 3: 凡例 UI のブラウザ互換性

DOM 操作と CSS が古いブラウザで動作しない可能性。

**Mitigation**:
- ベーシックな HTML/CSS のみを使用（Flexbox, position: absolute）
- IE11 は非対応（ROADMAP でサポート外と明記）
- モダンブラウザ（Chrome/Firefox/Safari/Edge）での動作を保証

#### Risk 4: Resolver との優先順位の混乱

ユーザーが Resolver と新 API を併用した場合、どちらが優先されるか分からない。

**Mitigation**:
- ドキュメントで明確化: **Resolver > classification.targets + adaptiveParams > base**
- 併用時に警告ログを出力: "Resolver is defined, classification.targets will be ignored"
- Migration Guide に優先順位の図を掲載

## Acceptance Criteria / 受け入れ基準

### Functional / 機能面

- [ ] `quantile` スキームが正しく動作し、分位点が計算される
- [ ] `jenks` スキームが正しく動作し、最適な境界値が計算される
- [ ] `classificationTargets.opacity` が有効な場合、opacity が分類と同期する
- [ ] `classificationTargets.width` が有効な場合、width が分類と同期する
- [ ] TopN ブーストが width に正しく加算される
- [ ] `outlineRenderMode: 'emulation-only'` 時、opacity/width がポリラインに適用される
- [ ] `createLegend()` で凡例が生成され、DOM に追加される
- [ ] 凡例が連続/離散スケールに応じて正しく表示される
- [ ] Resolver が定義されている場合、新 API より優先される
- [ ] `classificationTargets` が未指定の場合、デフォルトは `{ color: true }` のみ（v1.0.0 互換）

### Non-functional / 非機能面

- [ ] 処理時間: v1.0.0 と比較して ≤ +15% のオーバーヘッド（1k–5k ボクセル）
- [ ] メモリ使用量: ≤ +10% の増加
- [ ] バンドルサイズ: simple-statistics 追加による約 50KB 増加（v1.0.0 で既に導入済み）
- [ ] Lint 0 errors, Type Check 通過
- [ ] 既存の全テストがグリーン（回帰なし）

### Documentation / ドキュメント

- [ ] README に v1.1.0 の新機能（quantile/jenks/targets/凡例）を追加
- [ ] API.md に `classificationTargets`, `adaptiveParams.*Range`, `createLegend` を追加
- [ ] MIGRATION.md に Resolver → adaptiveParams の移行例を掲載
  - 視覚的パリティの比較スクリーンショット
  - 優先順位の図
- [ ] `examples/advanced/classification-extension-demo.html` を作成
- [ ] `examples/advanced/emulation-opacity-demo.html` を作成
- [ ] JSDoc が主要関数に付与されている

### Testing / テスト

- [ ] 単体テスト: `classification.test.js` に quantile/jenks/targets のテストを追加
- [ ] 単体テスト: `AdaptiveController.test.js` に opacity/width 補間のテストを追加
- [ ] 統合テスト: `classification-targets.test.js` で color + opacity + width の同時適用を検証
- [ ] 統合テスト: `emulation.test.js` でエミュレーション時の適用を検証
- [ ] 統合テスト: `legend.test.js` で凡例の生成・更新を検証
- [ ] パフォーマンステスト: 処理時間・メモリのオーバーヘッド検証
- [ ] ビジュアル回帰テスト: Resolver を使った既存 examples との視覚的パリティ
- [ ] CI で全テスト通過

## Migration Guide / 移行ガイド

### For Existing Users (v1.0.0 → v1.1.0) / 既存ユーザー向け

#### 破壊的変更なし（後方互換）

v1.1.0 は v1.0.0 との完全な後方互換性を維持しています:

```javascript
// v1.0.0 の既存コード（v1.1.0 でもそのまま動作）
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'log',
    colorMap: ['blue', 'red']
  }
});
```

#### quantile / jenks の使用

v1.1.0 で追加された高度スキームを使用する場合:

```javascript
// 分位数（quantile）
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'quantile',
    classes: 5,
    colorMap: ['#ffffcc', '#c2e699', '#78c679', '#31a354', '#006837']
  }
});

// Jenks natural breaks
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'jenks',
    classes: 5,
    colorMap: ['#fee5d9', '#fcae91', '#fb6a4a', '#de2d26', '#a50f15']
  }
});
```

#### opacity / width への拡張

色だけでなく、透明度や太さにも分類を適用する場合:

```javascript
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'quantile',
    classificationTargets: {
      color: true,
      opacity: true,  // NEW in v1.1.0
      width: true     // NEW in v1.1.0
    },
    colorMap: ['blue', 'cyan', 'yellow', 'orange', 'red']
  },
  adaptiveParams: {
    boxOpacityRange: [0.3, 1.0],      // NEW in v1.1.0
    outlineOpacityRange: [0.5, 1.0],  // NEW in v1.1.0
    outlineWidthRange: [1, 5]         // NEW in v1.1.0
  }
});
```

### Resolver からの移行

#### Before (Resolver API - v0.1 系)

```javascript
const heatbox = new Heatbox(viewer, {
  // 透明度の手動制御
  boxOpacityResolver: (voxelInfo) => {
    const density = voxelInfo.normalizedDensity;
    return 0.3 + density * 0.7;
  },
  
  // 太さの手動制御
  outlineWidthResolver: (voxelInfo) => {
    const density = voxelInfo.normalizedDensity;
    return 1 + density * 4;
  }
});
```

#### After (Adaptive API - v1.1.0)

```javascript
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'log',  // または 'quantile' / 'jenks'
    classificationTargets: {
      color: true,
      opacity: true,
      width: true
    }
  },
  adaptiveParams: {
    boxOpacityRange: [0.3, 1.0],
    outlineWidthRange: [1, 5]
  }
});
```

#### 視覚的パリティの検証

以下のスクリーンショットは、Resolver と Adaptive API が同等の視覚結果を生成することを示しています:

```
[Before: Resolver]          [After: Adaptive]
┌─────────────────┐        ┌─────────────────┐
│                 │        │                 │
│  (同じ見た目)   │   ≈    │  (同じ見た目)   │
│                 │        │                 │
└─────────────────┘        └─────────────────┘
```

#### 優先順位（重要）

Resolver と Adaptive API を併用した場合の優先順位:

```
1. *Resolver（最優先）
   ↓
2. classification.targets + adaptiveParams
   ↓
3. baseColor / highlightColor / opacity（デフォルト）
```

**推奨**: Resolver と Adaptive API を併用しないこと。移行時は段階的に Adaptive API に切り替えてください。

### 凡例の使用

```javascript
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'quantile',
    classes: 5
  }
});

await heatbox.createFromEntities(entities);

// 凡例を生成
const legend = heatbox.createLegend({
  position: 'bottom-right',  // 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'
  showLabels: true,
  showBreaks: true
});

// 凡例の更新（分類パラメータ変更時）
heatbox.updateOptions({
  classification: { classes: 7 }
});
// legend は自動更新される

// 凡例の削除
heatbox.destroyLegend();
```

## Future Work / 今後の作業

### v1.2.0: 時系列データの分類スコープ

```javascript
// 時刻ごとに分類を再計算 vs 全時刻で統一
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'quantile',
    temporalClassificationScope: 'per-time' | 'global'  // NEW in v1.2.0
  }
});
```

### v2.x: gamma / easing の追加

```javascript
// ガンマ補正・イージング関数
const heatbox = new Heatbox(viewer, {
  classification: {
    enabled: true,
    scheme: 'linear',
    gamma: 2.2,  // ガンマ補正
    easing: 'ease-in-out'  // イージング関数
  }
});
```

### v2.x: レイヤベース分類（ADR-0014 連携）

```javascript
// レイヤごとの色分け
const heatbox = new Heatbox(viewer, {
  aggregation: {
    enabled: true,
    byProperty: 'buildingType'
  },
  classification: {
    enabled: true,
    scheme: 'layer-dominant',  // NEW
    layerColorMap: {
      'residential': 'blue',
      'commercial': 'red',
      'industrial': 'gray'
    }
  }
});
```

### v3.x: インタラクティブ凡例

```javascript
// クリック・ホバー連携
const legend = heatbox.createLegend({
  interactive: true,
  onClassClick: (classIndex) => {
    // 該当クラスのボクセルを強調
    heatbox.highlightClass(classIndex);
  }
});
```

## References / 参照

- **ROADMAP v1.1.0**: Lines 414–513（視覚パリティ拡張）
- **ADR-0016**: v1.0.0 Classification Engine（基礎実装）
- **ADR-0014**: Voxel Layer Aggregation（レイヤ集約との将来連携）
- **ADR-0013/0014**: Resolver 非推奨化の方針
- **simple-statistics**: https://github.com/simple-statistics/simple-statistics
- **QGIS Classification**: https://docs.qgis.org/3.28/en/docs/user_manual/working_with_vector/vector_properties.html#graduated-renderer
- **Jenks natural breaks**: https://en.wikipedia.org/wiki/Jenks_natural_breaks_optimization
- **ckmeans**: https://journal.r-project.org/archive/2011/RJ-2011-015/RJ-2011-015.pdf

---

**Approval**: Pending review  
**Implementation Target**: v1.1.0-alpha.1 (2026-01-15)
