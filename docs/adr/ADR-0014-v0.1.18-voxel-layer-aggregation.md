# ADR-0014: Voxel Layer Aggregation - v0.1.18

**Status**: Proposed  
**Date**: 2025-11-02  
**Author**: hiro-nyon  
**Target Version**: v0.1.18  
**Related**: ROADMAP v0.1.18

## Context / 背景

### Problem Statement / 問題提起

Current Heatbox aggregates entities into voxels by counting total entities per voxel. However, many real-world use cases require understanding the **composition** of each voxel—not just "how many entities" but also "what types of entities" are present.

現在のHeatboxはボクセル内のエンティティを総数でカウントするのみです。しかし、多くの実世界ユースケースでは、各ボクセルの**構成**を理解する必要があります—「いくつのエンティティ」だけでなく「どの種類のエンティティ」が存在するかも重要です。

### Use Cases / ユースケース

#### 1. Urban Analytics / 都市分析
```javascript
// Aggregate by building type
// 建物種別で集約
{
  aggregation: {
    enabled: true,
    byProperty: 'buildingType'  // 'residential', 'commercial', 'industrial'
  }
}

// Result: Each voxel shows
// 結果：各ボクセルは以下を表示
// - 50% residential
// - 30% commercial  
// - 20% industrial
```

#### 2. Multi-source Data Integration / 複数ソースデータ統合
```javascript
// Aggregate by data source
// データソースで集約
{
  aggregation: {
    enabled: true,
    keyResolver: (entity) => entity.properties.source  // 'sensor-A', 'sensor-B', 'satellite'
  }
}

// Result: Identify coverage gaps from each source
// 結果：各ソースからのカバレッジギャップを特定
```

#### 3. Temporal Analysis / 時系列分析
```javascript
// Aggregate by time window (hour of day)
// 時間帯で集約（日時単位）
{
  aggregation: {
    enabled: true,
    keyResolver: (entity) => {
      const hour = new Date(entity.timestamp).getHours();
      return `hour-${hour}`;  // 'hour-0', 'hour-1', ..., 'hour-23'
    }
  }
}

// Result: Identify peak activity periods per voxel
// 結果：ボクセルごとのピーク活動時間帯を特定
```

#### 4. Classification-based Styling (Future) / 分類ベースのスタイリング（将来）
```javascript
// v1.x: Use layer stats for adaptive styling
// v1.x: レイヤ統計を適応的スタイリングに使用
const dominantLayer = voxelInfo.layerStats.get(voxelInfo.layerTop);
const color = LAYER_COLORS[voxelInfo.layerTop];
const opacity = dominantLayer.count / voxelInfo.count;  // Dominant layer ratio
```

### Current Limitations / 現在の制限

1. **No layer-level visibility** / **レイヤレベルの可視性がない**
   - Can only see total entity count per voxel
   - Cannot distinguish entity types within a voxel
   - ボクセルごとの総エンティティ数のみ表示
   - ボクセル内のエンティティ種別を区別不可

2. **Manual post-processing required** / **手動の後処理が必要**
   - Users must iterate through `voxelInfo.entities` and count by layer themselves
   - Inefficient for large datasets
   - ユーザーが`voxelInfo.entities`を反復処理し、レイヤごとに自分でカウント
   - 大規模データセットでは非効率

3. **Limited debugging/analysis** / **限定的なデバッグ/分析**
   - Hard to diagnose data quality issues (e.g., "why is this voxel dense?")
   - No way to verify data source coverage
   - データ品質問題の診断が困難（例：「なぜこのボクセルは密集しているのか？」）
   - データソースカバレッジの検証方法がない

## Decision / 決定事項

### Core Decision / 核となる決定

We will add **opt-in layer-based aggregation** in v0.1.18, allowing users to specify a layer key for each entity and automatically aggregate statistics per voxel.

v0.1.18で**オプトイン式のレイヤベース集約**を追加し、ユーザーが各エンティティのレイヤキーを指定し、ボクセルごとに統計を自動集約できるようにします。

### Scope / スコープ（v0.1.18）

- 対象: position を持つ Cesium Entity（点）に限定
- 非対象: ポリゴン、ポリライン、3D Tiles 等の点以外のジオメトリ（将来版で検討）

### Key Design Choices / 主要な設計選択

#### 1. Opt-in Configuration / オプトイン設定

```javascript
{
  aggregation: {
    enabled: false,  // Default: disabled (no behavior change)
    byProperty: null,  // Optional: property key to use as layer key
    keyResolver: null  // Optional: custom function (entity) => layerKey
  }
}
```

**Rationale**:
- Non-breaking: existing code continues to work unchanged
- Flexibility: support both simple property-based and custom resolver-based aggregation
- Performance: no overhead when disabled
- 非破壊的：既存のコードは変更なしで動作継続
- 柔軟性：シンプルなプロパティベースとカスタムリゾルバベースの両方をサポート
- パフォーマンス：無効時はオーバーヘッドなし

#### 2. Lightweight Data Structure / 軽量データ構造

```javascript
voxelInfo.layerStats = Map<layerKey: string, count: number>
```

**Rationale**:
- Memory-efficient: store only counts, not entity references
- Fast lookup: Map provides O(1) access
- Minimal overhead: ~8-16 bytes per unique layer per voxel
- メモリ効率的：カウントのみ保存、エンティティ参照は保持しない
- 高速ルックアップ：Mapは O(1) アクセスを提供
- 最小オーバーヘッド：ボクセルごとのユニークレイヤあたり ~8-16 バイト

#### 3. Top-N Summary in Statistics / 統計情報でのTop-N要約

```javascript
getStatistics() {
  return {
    // ...existing stats
    layers: [
      { key: 'residential', total: 5234 },
      { key: 'commercial', total: 2103 },
      { key: 'industrial', total: 987 }
      // ... top 10 by default
    ]
  };
}
```

**Rationale**:
- Prevent log bloat: only return top N layers (default: 10)
- Quick overview: most significant layers at a glance
- Full details available via voxel picking
- ログ肥大化を防止：上位N個のレイヤのみ返却（デフォルト：10）
- クイック概観：最も重要なレイヤを一目で確認
- ボクセルピッキングで完全な詳細を取得可能

#### 4. Picking Integration / ピッキング統合

```javascript
// When picking a voxel / ボクセルをピックした場合
voxelEntity.properties.layerTop = 'residential';  // Most common layer
voxelEntity.description = `
  <h3>Voxel Composition</h3>
  <ul>
    <li>residential: 30 (60%)</li>
    <li>commercial: 15 (30%)</li>
    <li>industrial: 5 (10%)</li>
  </ul>
`;
```

**Rationale**:
- Immediate context: user sees composition when clicking voxel
- Minimal: only show `layerTop` in properties (lightweight)
- Detailed: full breakdown in description (optional, controlled by flag)
- 即座のコンテキスト：ユーザーはボクセルクリック時に構成を確認
- 最小限：プロパティには`layerTop`のみ表示（軽量）
- 詳細：説明文で完全な内訳（オプション、フラグで制御）

#### 5. No Automatic Styling (v0.1.18) / 自動スタイリングなし（v0.1.18）

**Out of scope for v0.1.18**:
- Layer-based color/opacity/width customization
- Automatic style switching based on dominant layer
- Layer filtering (show/hide specific layers)

**v0.1.18のスコープ外**:
- レイヤベースの色/不透明度/太さのカスタマイズ
- 支配的レイヤに基づく自動スタイル切替
- レイヤフィルタリング（特定レイヤの表示/非表示）
- 点以外（ポリゴン/ポリライン/3D Tiles 等）の集約処理

**Rationale**:
- Separation of concerns: aggregation ≠ visualization
- Defer styling to v1.x classification system (ADR-TBD)
- Focus v0.1.18 on data structure and statistics
- 関心の分離：集約 ≠ 可視化
- スタイリングはv1.x分類システムに延期（ADR-TBD）
- v0.1.18はデータ構造と統計に集中

## Architecture / アーキテクチャ

### Component Structure / コンポーネント構造

```
src/
  core/
    DataProcessor.js           # Update: Add layer aggregation logic
  utils/
    validation.js              # Update: Add aggregation options validation
    constants.js               # Update: Add AGGREGATION_DEFAULTS
  Heatbox.js                   # Update: Pass aggregation options, expose layer stats
```

### DataProcessor Integration / DataProcessor統合

```javascript
// In DataProcessor.classifyEntitiesIntoVoxels()

if (options.aggregation?.enabled) {
  // Determine key resolver / キーリゾルバを決定
  let getLayerKey;
  if (options.aggregation.keyResolver) {
    getLayerKey = options.aggregation.keyResolver;
  } else if (options.aggregation.byProperty) {
    getLayerKey = (entity) => entity.properties?.[options.aggregation.byProperty] || 'unknown';
  } else {
    Logger.warn('aggregation.enabled but no byProperty or keyResolver specified, using "default" key');
    getLayerKey = () => 'default';
  }

  // Aggregate entities / エンティティを集約
  for (const entity of entities) {
    const voxelKey = /* ... calculate voxel key ... */;
    
    if (!voxelMap.has(voxelKey)) {
      voxelMap.set(voxelKey, {
        key: voxelKey,
        entities: [],
        count: 0,
        layerStats: new Map()  // NEW: layer aggregation
      });
    }
    
    const voxelInfo = voxelMap.get(voxelKey);
    voxelInfo.entities.push(entity);
    voxelInfo.count++;
    
    // NEW: Aggregate by layer
    const layerKey = getLayerKey(entity);
    voxelInfo.layerStats.set(
      layerKey,
      (voxelInfo.layerStats.get(layerKey) || 0) + 1
    );
  }
  
  // Calculate layerTop (most common layer per voxel)
  for (const voxelInfo of voxelMap.values()) {
    let maxCount = 0;
    let topLayer = null;
    
    for (const [layerKey, count] of voxelInfo.layerStats) {
      if (count > maxCount) {
        maxCount = count;
        topLayer = layerKey;
      }
    }
    
    voxelInfo.layerTop = topLayer;
  }
}
```

### Statistics Extension / 統計拡張

```javascript
// In Heatbox.getStatistics()

getStatistics() {
  const stats = {
    // ... existing stats
  };

  if (this._options.aggregation?.enabled) {
    // Aggregate across all voxels / 全ボクセルを集約
    const globalLayerCounts = new Map();
    
    for (const voxelInfo of this._voxelData.values()) {
      for (const [layerKey, count] of voxelInfo.layerStats) {
        globalLayerCounts.set(
          layerKey,
          (globalLayerCounts.get(layerKey) || 0) + count
        );
      }
    }
    
    // Top N layers / 上位N個のレイヤ
    const topN = 10;
    const sorted = Array.from(globalLayerCounts.entries())
      .sort((a, b) => b[1] - a[1])  // Sort by count descending
      .slice(0, topN);
    
    stats.layers = sorted.map(([key, total]) => ({ key, total }));
  }

  return stats;
}
```

### Picking Integration / ピッキング統合

```javascript
// In GeometryRenderer.createVoxelBox()

if (options.aggregation?.enabled && voxelInfo.layerStats) {
  entityConfig.properties.layerTop = voxelInfo.layerTop;
  
  // Optional: add full layer breakdown to description
  if (options.aggregation.showInDescription !== false) {
    const layerBreakdown = Array.from(voxelInfo.layerStats.entries())
      .sort((a, b) => b[1] - a[1])  // Sort by count
      .map(([key, count]) => {
        const pct = ((count / voxelInfo.count) * 100).toFixed(1);
        return `<li>${key}: ${count} (${pct}%)</li>`;
      })
      .join('');
    
    description += `
      <h4>Layer Composition / レイヤ構成</h4>
      <ul>${layerBreakdown}</ul>
    `;
  }
}
```

## Consequences / 影響

### Benefits / 利点

#### 1. Enhanced Observability / 観測可能性の向上
- ✅ Understand voxel composition without manual iteration
- ✅ Quick diagnosis of data quality issues
- ✅ Verify data source coverage
- ✅ 手動反復処理なしでボクセル構成を理解
- ✅ データ品質問題の迅速な診断
- ✅ データソースカバレッジの検証

#### 2. Performance / パフォーマンス
- ✅ Minimal overhead: ~8-16 bytes per unique layer per voxel
- ✅ No overhead when disabled (default)
- ✅ Target: ≤ +10% memory increase, ≤ +10% processing time
- ✅ 最小オーバーヘッド：ボクセルごとのユニークレイヤあたり ~8-16 バイト
- ✅ 無効時はオーバーヘッドなし（デフォルト）
- ✅ 目標：メモリ増加 ≤ +10%、処理時間増加 ≤ +10%

#### 3. Foundation for Future Features / 将来機能の基盤
- ✅ Enables layer-based classification in v1.x
- ✅ Supports temporal layer analysis (v1.2.0)
- ✅ Can be extended to PLATEAU/3D Tiles (future)
- ✅ v1.xでのレイヤベース分類を可能に
- ✅ 時系列レイヤ分析をサポート（v1.2.0）
- ✅ PLATEAU/3D Tilesへ拡張可能（将来）

#### 4. Flexibility / 柔軟性
- ✅ Supports both simple property-based and custom resolver-based aggregation
- ✅ Top-N summary prevents log bloat
- ✅ Optional detailed breakdown in voxel description
- ✅ シンプルなプロパティベースとカスタムリゾルバベースの両方をサポート
- ✅ Top-N要約でログ肥大化を防止
- ✅ ボクセル説明文でのオプショナルな詳細内訳

### Drawbacks / 欠点

#### 1. Memory Overhead / メモリオーバーヘッド
- ⚠️ Additional Map per voxel when enabled
- ⚠️ Scales with unique layer count per voxel
- ⚠️ 有効時はボクセルごとに追加のMap
- ⚠️ ボクセルごとのユニークレイヤ数に比例

**Mitigation**: Store only counts (not entity references), target ≤ +10% memory increase

**緩和策**：カウントのみ保存（エンティティ参照は保持しない）、メモリ増加 ≤ +10% を目標

#### 2. Processing Overhead / 処理オーバーヘッド
- ⚠️ Additional loop to resolve layer keys
- ⚠️ Map operations (set/get) per entity
- ⚠️ レイヤキー解決のための追加ループ
- ⚠️ エンティティごとのMap操作（set/get）

**Mitigation**: Target ≤ +10% processing time increase, skip when disabled

**緩和策**：処理時間増加 ≤ +10% を目標、無効時はスキップ

#### 3. API Surface Increase / API表面積の増加
- ⚠️ New options: `aggregation.enabled`, `byProperty`, `keyResolver`
- ⚠️ New statistics field: `layers`
- ⚠️ New entity property: `layerTop`
- ⚠️ 新しいオプション：`aggregation.enabled`、`byProperty`、`keyResolver`
- ⚠️ 新しい統計フィールド：`layers`
- ⚠️ 新しいエンティティプロパティ：`layerTop`

**Mitigation**: Clear documentation, opt-in (default disabled), consistent naming

**緩和策**：明確なドキュメント、オプトイン（デフォルト無効）、一貫した命名

#### 4. Limited Styling (v0.1.18) / 限定的なスタイリング（v0.1.18）
- ⚠️ No automatic color/opacity/width based on layers
- ⚠️ Users must manually interpret layer stats
- ⚠️ レイヤに基づく自動色/不透明度/太さなし
- ⚠️ ユーザーがレイヤ統計を手動で解釈する必要

**Mitigation**: Defer to v1.x classification system, provide examples of manual styling

**緩和策**：v1.x分類システムに延期、手動スタイリングの例を提供

### Risks & Mitigations / リスク & 緩和策

#### Risk: Layer Key Explosion / リスク：レイヤキーの爆発
If `keyResolver` returns too many unique keys (e.g., timestamps), memory usage could spike.

`keyResolver`があまりに多くのユニークキーを返す場合（例：タイムスタンプ）、メモリ使用量が急増する可能性があります。

**Mitigation**:
- Document best practices: use categorical keys (not continuous values)
- Add warning when unique layer count exceeds threshold (e.g., 100)
- Limit Top-N summary to prevent excessive logging
- ベストプラクティスをドキュメント化：カテゴリカルキーを使用（連続値は不可）
- ユニークレイヤ数がしきい値を超える場合に警告を追加（例：100）
- Top-N要約を制限して過度のログを防止

#### Risk: Invalid Key Resolver / リスク：無効なキーリゾルバ
User-provided `keyResolver` could throw errors or return non-string values.

ユーザー提供の`keyResolver`がエラーをスローしたり、非文字列値を返したりする可能性があります。

**Mitigation**:
- Wrap `keyResolver` calls in try/catch
- Coerce returned values to string
- Fall back to 'unknown' on error
- `keyResolver`呼び出しをtry/catchでラップ
- 返却値を文字列に強制変換
- エラー時は'unknown'にフォールバック

```javascript
try {
  layerKey = String(getLayerKey(entity));
} catch (error) {
  Logger.warn('keyResolver threw error, using "unknown"', error);
  layerKey = 'unknown';
}
```

#### Risk: Performance Regression / リスク：パフォーマンス退行
Additional Map operations could slow down large datasets.

追加のMap操作が大規模データセットを遅くする可能性があります。

**Mitigation**:
- Benchmark with 1k-5k voxels, target ≤ +10% processing time
- Profile Map operations, optimize hot paths
- Skip layer aggregation entirely when disabled (no overhead)
- 1k-5kボクセルでベンチマーク、処理時間 ≤ +10% を目標
- Map操作をプロファイル、ホットパスを最適化
- 無効時はレイヤ集約を完全にスキップ（オーバーヘッドなし）

## Implementation Plan / 実装計画

### Phase 1: Core Infrastructure (Days 1-2) / フェーズ1：コアインフラ（1-2日）

- [ ] Add `aggregation` options to `constants.js` (default: `enabled: false`)
- [ ] Add validation for `aggregation.enabled`, `byProperty`, `keyResolver` in `validation.js`
- [ ] Update JSDoc/TypeScript types for aggregation options

### Phase 2: DataProcessor Integration (Days 3-4) / フェーズ2：DataProcessor統合（3-4日）

- [ ] Implement layer key resolution logic (`byProperty` and `keyResolver`)
- [ ] Add `layerStats` Map to `voxelInfo` during entity classification
- [ ] Calculate `layerTop` (most common layer) per voxel
- [ ] Add error handling for invalid `keyResolver`

### Phase 3: Statistics Extension (Day 5) / フェーズ3：統計拡張（5日）

- [ ] Aggregate `layerStats` across all voxels in `getStatistics()`
- [ ] Return Top-N layers (default: 10) in `stats.layers`
- [ ] Add unit tests for global layer aggregation

### Phase 4: Picking Integration (Day 6) / フェーズ4：ピッキング統合（6日）

- [ ] Add `properties.layerTop` to rendered voxel entities
- [ ] Optionally add layer breakdown to voxel description
- [ ] Add flag `aggregation.showInDescription` (default: `true`)

### Phase 5: Testing (Days 7-8) / フェーズ5：テスト（7-8日）

- [ ] Unit tests: `byProperty` aggregation
- [ ] Unit tests: `keyResolver` aggregation
- [ ] Unit tests: Error handling (invalid resolver, non-string keys)
- [ ] Unit tests: Top-N summary
- [ ] Integration tests: Full workflow with aggregation enabled
- [ ] Performance tests: Verify ≤ +10% memory/time overhead

### Phase 6: Documentation & Examples (Days 9-10) / フェーズ6：ドキュメント・例（9-10日）

- [ ] Update README with aggregation section
- [ ] Add example: urban analytics (building types)
- [ ] Add example: multi-source data (sensor coverage)
- [ ] Document best practices (categorical keys, avoid timestamps)
- [ ] Update API documentation (JSDoc)

## Testing Strategy / テスト戦略

### Unit Tests

#### DataProcessor Aggregation Tests
```javascript
describe('DataProcessor - Layer Aggregation', () => {
  it('should aggregate by property', () => {
    const entities = [
      { position: { x: 0, y: 0, z: 0 }, properties: { type: 'A' } },
      { position: { x: 0, y: 0, z: 0 }, properties: { type: 'B' } },
      { position: { x: 0, y: 0, z: 0 }, properties: { type: 'A' } }
    ];
    
    const options = {
      aggregation: { enabled: true, byProperty: 'type' }
    };
    
    const voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, bounds, grid, options);
    const voxelInfo = voxelData.values().next().value;
    
    expect(voxelInfo.layerStats.get('A')).toBe(2);
    expect(voxelInfo.layerStats.get('B')).toBe(1);
    expect(voxelInfo.layerTop).toBe('A');
  });

  it('should aggregate with keyResolver', () => {
    const entities = [
      { position: { x: 0, y: 0, z: 0 }, timestamp: '2025-11-02T08:00:00Z' },
      { position: { x: 0, y: 0, z: 0 }, timestamp: '2025-11-02T14:00:00Z' },
      { position: { x: 0, y: 0, z: 0 }, timestamp: '2025-11-02T08:00:00Z' }
    ];
    
    const options = {
      aggregation: {
        enabled: true,
        keyResolver: (entity) => {
          const hour = new Date(entity.timestamp).getHours();
          return hour < 12 ? 'morning' : 'afternoon';
        }
      }
    };
    
    const voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, bounds, grid, options);
    const voxelInfo = voxelData.values().next().value;
    
    expect(voxelInfo.layerStats.get('morning')).toBe(2);
    expect(voxelInfo.layerStats.get('afternoon')).toBe(1);
    expect(voxelInfo.layerTop).toBe('morning');
  });

  it('should handle keyResolver errors gracefully', () => {
    const entities = [
      { position: { x: 0, y: 0, z: 0 } }
    ];
    
    const options = {
      aggregation: {
        enabled: true,
        keyResolver: () => { throw new Error('Resolver error'); }
      }
    };
    
    const voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, bounds, grid, options);
    const voxelInfo = voxelData.values().next().value;
    
    expect(voxelInfo.layerStats.get('unknown')).toBe(1);
  });

  it('should not aggregate when disabled', () => {
    const entities = [
      { position: { x: 0, y: 0, z: 0 }, properties: { type: 'A' } }
    ];
    
    const options = {
      aggregation: { enabled: false }
    };
    
    const voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, bounds, grid, options);
    const voxelInfo = voxelData.values().next().value;
    
    expect(voxelInfo.layerStats).toBeUndefined();
    expect(voxelInfo.layerTop).toBeUndefined();
  });
});
```

#### Statistics Aggregation Tests
```javascript
describe('Heatbox.getStatistics() - Layer Aggregation', () => {
  it('should return top N layers globally', async () => {
    const entities = generateEntitiesWithLayers(1000, ['A', 'B', 'C', 'D']);
    
    const heatbox = new Heatbox(viewer, {
      aggregation: { enabled: true, byProperty: 'layer' }
    });
    
    await heatbox.createFromEntities(entities);
    const stats = heatbox.getStatistics();
    
    expect(stats.layers).toBeDefined();
    expect(stats.layers.length).toBeLessThanOrEqual(10);  // Top 10
    expect(stats.layers[0].total).toBeGreaterThanOrEqual(stats.layers[1].total);  // Sorted descending
  });

  it('should not return layers when disabled', async () => {
    const entities = generateTestEntities(100);
    
    const heatbox = new Heatbox(viewer, {
      aggregation: { enabled: false }
    });
    
    await heatbox.createFromEntities(entities);
    const stats = heatbox.getStatistics();
    
    expect(stats.layers).toBeUndefined();
  });
});
```

#### Performance Tests
```javascript
describe('Layer Aggregation - Performance', () => {
  it('should have ≤ +10% memory overhead', () => {
    const entities = generateEntitiesWithLayers(5000, ['A', 'B', 'C']);
    
    // Baseline: no aggregation / 基準：集約なし
    const memBefore1 = process.memoryUsage().heapUsed;
    const heatbox1 = new Heatbox(viewer, { aggregation: { enabled: false } });
    heatbox1.createFromEntities(entities);
    const memAfter1 = process.memoryUsage().heapUsed;
    const baselineMemory = memAfter1 - memBefore1;
    
    // With aggregation / 集約あり
    const memBefore2 = process.memoryUsage().heapUsed;
    const heatbox2 = new Heatbox(viewer, { aggregation: { enabled: true, byProperty: 'layer' } });
    heatbox2.createFromEntities(entities);
    const memAfter2 = process.memoryUsage().heapUsed;
    const aggregationMemory = memAfter2 - memBefore2;
    
    const overhead = (aggregationMemory - baselineMemory) / baselineMemory;
    expect(overhead).toBeLessThanOrEqual(0.10);  // ≤ +10%
  });

  it('should have ≤ +10% processing time overhead', () => {
    const entities = generateEntitiesWithLayers(5000, ['A', 'B', 'C']);
    
    // Baseline / 基準
    const start1 = performance.now();
    const heatbox1 = new Heatbox(viewer, { aggregation: { enabled: false } });
    heatbox1.createFromEntities(entities);
    const baselineTime = performance.now() - start1;
    
    // With aggregation / 集約あり
    const start2 = performance.now();
    const heatbox2 = new Heatbox(viewer, { aggregation: { enabled: true, byProperty: 'layer' } });
    heatbox2.createFromEntities(entities);
    const aggregationTime = performance.now() - start2;
    
    const overhead = (aggregationTime - baselineTime) / baselineTime;
    expect(overhead).toBeLessThanOrEqual(0.10);  // ≤ +10%
  });
});
```

### Integration Tests

```javascript
describe('Layer Aggregation - Integration', () => {
  it('should display layer composition when picking voxel', async () => {
    const entities = [
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), properties: { type: 'residential' } },
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), properties: { type: 'commercial' } },
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), properties: { type: 'residential' } }
    ];
    
    const heatbox = new Heatbox(viewer, {
      aggregation: { enabled: true, byProperty: 'type' }
    });
    
    await heatbox.createFromEntities(entities);
    
    const voxelEntity = viewer.entities.values[0];
    expect(voxelEntity.properties.layerTop).toBe('residential');
    expect(voxelEntity.description).toContain('Layer Composition');
    expect(voxelEntity.description).toContain('residential: 2');
    expect(voxelEntity.description).toContain('commercial: 1');
  });

  it('should support multi-source data aggregation', async () => {
    const entities = [
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), source: 'sensor-A' },
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), source: 'sensor-B' },
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), source: 'sensor-A' }
    ];
    
    const heatbox = new Heatbox(viewer, {
      aggregation: {
        enabled: true,
        keyResolver: (entity) => entity.source
      }
    });
    
    await heatbox.createFromEntities(entities);
    const stats = heatbox.getStatistics();
    
    const sensorA = stats.layers.find(l => l.key === 'sensor-A');
    const sensorB = stats.layers.find(l => l.key === 'sensor-B');
    
    expect(sensorA.total).toBe(2);
    expect(sensorB.total).toBe(1);
  });
});
```

## Documentation Updates / ドキュメント更新

### README Section

Add new section: **Layer Aggregation (v0.1.18+)**

```markdown
## Layer Aggregation (v0.1.18+)

Aggregate entities within each voxel by custom layers (categories, types, sources).

### Basic Usage

```javascript
const heatbox = new Heatbox(viewer, {
  aggregation: {
    enabled: true,
    byProperty: 'buildingType'  // Use entity.properties.buildingType as layer key
  }
});

const stats = heatbox.getStatistics();
console.log(stats.layers);
// [
//   { key: 'residential', total: 5234 },
//   { key: 'commercial', total: 2103 },
//   { key: 'industrial', total: 987 }
// ]
```

### Custom Key Resolver

```javascript
const heatbox = new Heatbox(viewer, {
  aggregation: {
    enabled: true,
    keyResolver: (entity) => {
      // Custom logic to determine layer key / レイヤキーを決定するカスタムロジック
      const hour = new Date(entity.timestamp).getHours();
      return hour < 12 ? 'morning' : 'afternoon';
    }
  }
});
```

### Voxel Picking

When you click a voxel, the description shows layer composition:

```
Voxel Composition:
- residential: 30 (60%)
- commercial: 15 (30%)
- industrial: 5 (10%)
```

### Best Practices

- **Use categorical keys**: Avoid continuous values (timestamps, IDs) that create too many unique layers
- **Limit unique layers**: Keep unique layer count < 100 per voxel for optimal performance
- **Error handling**: `keyResolver` should return string values; errors fall back to 'unknown'

### Performance

- **Memory**: ~8-16 bytes per unique layer per voxel
- **Processing**: ≤ +10% overhead when enabled
- **No overhead**: When disabled (default), no performance impact
```

### API Documentation (JSDoc)

```javascript
/**
 * @typedef {Object} AggregationOptions
 * @property {boolean} [enabled=false] - Enable layer-based aggregation
 * @property {string} [byProperty] - Entity property key to use as layer key (e.g., 'buildingType')
 * @property {Function} [keyResolver] - Custom function (entity) => layerKey (takes precedence over byProperty)
 * @property {boolean} [showInDescription=true] - Include layer breakdown in voxel description
 */

/**
 * @typedef {Object} LayerSummary
 * @property {string} key - Layer key
 * @property {number} total - Total entity count for this layer across all voxels
 */

/**
 * @typedef {Object} Statistics
 * @property {Array<LayerSummary>} [layers] - Top N layers (when aggregation enabled)
 * @property {...} - Other existing statistics fields
 */

/**
 * @typedef {Object} VoxelInfo
 * @property {Map<string, number>} [layerStats] - Per-voxel layer counts (when aggregation enabled)
 * @property {string} [layerTop] - Most common layer key in this voxel
 * @property {...} - Other existing voxelInfo fields
 */
```

## Acceptance Criteria / 受け入れ基準

### Functional / 機能面

- [ ] `aggregation.enabled=true` aggregates entities by layer key
- [ ] `byProperty` correctly uses entity property as layer key
- [ ] `keyResolver` takes precedence over `byProperty`
- [ ] `layerStats` Map correctly stores counts per layer per voxel
- [ ] `layerTop` identifies most common layer per voxel
- [ ] `getStatistics()` returns Top-N layers (default: 10) sorted descending
- [ ] Voxel picking displays `layerTop` in properties
- [ ] Voxel description includes layer breakdown (when `showInDescription=true`)
- [ ] No behavior change when `aggregation.enabled=false` (default)

### Non-functional / 非機能面

- [ ] Memory overhead ≤ +10% vs baseline (1k-5k voxels, 3-10 unique layers)
- [ ] Processing time overhead ≤ +10% vs baseline
- [ ] No overhead when disabled (default)
- [ ] Graceful error handling for invalid `keyResolver`
- [ ] Warning logged when unique layer count exceeds threshold (100)

### Documentation / ドキュメント

- [ ] README includes Layer Aggregation section with examples
- [ ] JSDoc updated for `aggregation` options and related types
- [ ] Best practices documented (categorical keys, unique layer limits)
- [ ] Example: urban analytics (building types)
- [ ] Example: multi-source data (sensor coverage)

### Testing / テスト

- [ ] Unit tests: `byProperty` aggregation
- [ ] Unit tests: `keyResolver` aggregation
- [ ] Unit tests: Error handling (invalid resolver)
- [ ] Unit tests: Top-N summary in statistics
- [ ] Integration tests: Full workflow with picking
- [ ] Performance tests: Memory and processing time overhead

## Migration Guide / 移行ガイド

### For Existing Users / 既存ユーザー向け

**No migration required.** Layer aggregation is opt-in; existing code continues to work unchanged.

**移行不要。** レイヤ集約はオプトイン；既存コードは変更なしで動作します。

### To Enable Layer Aggregation / レイヤ集約を有効にするには

```javascript
// Before (no aggregation) / 以前（集約なし）
const heatbox = new Heatbox(viewer);

// After (with aggregation) / 以降（集約あり）
const heatbox = new Heatbox(viewer, {
  aggregation: {
    enabled: true,
    byProperty: 'type'  // or keyResolver
  }
});

const stats = heatbox.getStatistics();
console.log(stats.layers);  // Top N layers
```

## Future Work / 今後の作業

### v1.x: Layer-based Classification / レイヤベース分類

```javascript
// Automatic color/opacity/width based on dominant layer
// 支配的レイヤに基づく自動色/不透明度/太さ
{
  classification: 'layer-dominant',
  layerStyles: {
    'residential': { color: 'blue', opacity: 0.6 },
    'commercial': { color: 'red', opacity: 0.8 },
    'industrial': { color: 'gray', opacity: 0.5 }
  }
}
```

### v1.x: Layer Filtering / レイヤフィルタリング

```javascript
// Show/hide specific layers
// 特定レイヤの表示/非表示
{
  layerFilter: {
    visible: ['residential', 'commercial'],  // Hide 'industrial'
    mode: 'whitelist'  // or 'blacklist'
  }
}
```

### v1.2.0: Temporal Layer Analysis / 時系列レイヤ分析

```javascript
// Aggregate by time window and layer
// 時間帯とレイヤで集約
{
  aggregation: {
    enabled: true,
    keyResolver: (entity) => {
      const hour = new Date(entity.timestamp).getHours();
      return `${entity.properties.type}-hour${hour}`;
    }
  },
  temporalClassificationScope: 'per-time'  // Update layer stats per time slice
}
```

### Future: PLATEAU Integration / PLATEAU統合

If Heatbox is extended to support large-scale polygon/3D Tiles data (e.g., PLATEAU):
- Extract aggregation logic into separate package (`@cesium-heatbox/aggregation`)
- Support multi-geometry aggregation (points, polygons, 3D Tiles)
- Provide common aggregation layer for broader ecosystem

将来、Heatboxが大規模ポリゴン/3D Tilesデータ（例：PLATEAU）をサポートするように拡張される場合：
- 集約ロジックを別パッケージに抽出（`@cesium-heatbox/aggregation`）
- 複数ジオメトリ集約をサポート（点、ポリゴン、3D Tiles）
- より広いエコシステムのための共通集約レイヤを提供

## References / 参照

- ROADMAP v0.1.18: Lines 300-324
- ROADMAP v1.x Classification: TBD
- ROADMAP v1.2.0 Temporal: Lines 513-530

---

**Approval**: Pending review and discussion  
**Implementation Target**: v0.1.18 (2025-11-15)
