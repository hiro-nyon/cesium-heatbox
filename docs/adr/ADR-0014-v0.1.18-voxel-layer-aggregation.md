# ADR-0014: Voxel Layer Aggregation - v0.1.18

**Status**: Proposed  
**Date**: 2025-11-02  
**Author**: hiro-nyon  
**Target Version**: v0.1.18  
**Related**: ROADMAP v0.1.18

## Context / 背景

### Problem Statement / 問題提起

Current Heatbox aggregates entities into voxels by counting total entities per voxel. However, many real-world use cases require understanding the **composition** of each voxel—not just "how many entities" but also "what types of entities" are present.

現在のHeatboxはボクセル内のエンティティを総数でカウントするのみです。しかし、多くの実世界ユースケースでは、各ボクセルの**構成**を理解する必要があります—「いくつのエンティティ」だけでなく「どの種類のエンティティ」が存在するかも重要です。

### Use Cases / ユースケース

#### 1. Urban Analytics / 都市分析
```javascript
// Aggregate by building type
// 建物種別で集約
{
  aggregation: {
    enabled: true,
    byProperty: 'buildingType'  // 'residential', 'commercial', 'industrial'
  }
}

// Result: Each voxel shows
// 結果：各ボクセルは以下を表示
// - 50% residential
// - 30% commercial  
// - 20% industrial
```

#### 2. Multi-source Data Integration / 複数ソースデータ統合
```javascript
// Aggregate by data source
// データソースで集約
{
  aggregation: {
    enabled: true,
    keyResolver: (entity) => entity.properties.source  // 'sensor-A', 'sensor-B', 'satellite'
  }
}

// Result: Identify coverage gaps from each source
// 結果：各ソースからのカバレッジギャップを特定
```

#### 3. Temporal Analysis / 時系列分析
```javascript
// Aggregate by time window (hour of day)
// 時間帯で集約（日時単位）
{
  aggregation: {
    enabled: true,
    keyResolver: (entity) => {
      const hour = new Date(entity.timestamp).getHours();
      return `hour-${hour}`;  // 'hour-0', 'hour-1', ..., 'hour-23'
    }
  }
}

// Result: Identify peak activity periods per voxel
// 結果：ボクセルごとのピーク活動時間帯を特定
```

#### 4. Classification-based Styling (Future) / 分類ベースのスタイリング（将来）
```javascript
// v1.x: Use layer stats for adaptive styling
// v1.x: レイヤ統計を適応的スタイリングに使用
const dominantLayer = voxelInfo.layerStats.get(voxelInfo.layerTop);
const color = LAYER_COLORS[voxelInfo.layerTop];
const opacity = dominantLayer.count / voxelInfo.count;  // Dominant layer ratio
```

### Current Limitations / 現在の制限

1. **No layer-level visibility** / **レイヤレベルの可視性がない**
   - Can only see total entity count per voxel
   - Cannot distinguish entity types within a voxel
   - ボクセルごとの総エンティティ数のみ表示
   - ボクセル内のエンティティ種別を区別不可

2. **Manual post-processing required** / **手動の後処理が必要**
   - Users must iterate through `voxelInfo.entities` and count by layer themselves
   - Inefficient for large datasets
   - ユーザーが`voxelInfo.entities`を反復処理し、レイヤごとに自分でカウント
   - 大規模データセットでは非効率

3. **Limited debugging/analysis** / **限定的なデバッグ/分析**
   - Hard to diagnose data quality issues (e.g., "why is this voxel dense?")
   - No way to verify data source coverage
   - データ品質問題の診断が困難（例：「なぜこのボクセルは密集しているのか？」）
   - データソースカバレッジの検証方法がない

## Decision / 決定事項

### Core Decision / 核となる決定

We will add **opt-in layer-based aggregation** in v0.1.18, allowing users to specify a layer key for each entity and automatically aggregate statistics per voxel.

v0.1.18で**オプトイン式のレイヤベース集約**を追加し、ユーザーが各エンティティのレイヤキーを指定し、ボクセルごとに統計を自動集約できるようにします。

### Scope / スコープ（v0.1.18）

- 対象: position を持つ Cesium Entity（点）に限定
- 非対象: ポリゴン、ポリライン、3D Tiles 等の点以外のジオメトリ（将来版で検討）

### Key Design Choices / 主要な設計選択

#### 1. Opt-in Configuration / オプトイン設定

```javascript
{
  aggregation: {
    enabled: false,  // Default: disabled (no behavior change)
    byProperty: null,  // Optional: property key to use as layer key
    keyResolver: null  // Optional: custom function (entity) => layerKey
  }
}
```

**Rationale**:
- Non-breaking: existing code continues to work unchanged
- Flexibility: support both simple property-based and custom resolver-based aggregation
- Performance: no overhead when disabled
- 非破壊的：既存のコードは変更なしで動作継続
- 柔軟性：シンプルなプロパティベースとカスタムリゾルバベースの両方をサポート
- パフォーマンス：無効時はオーバーヘッドなし

【実装上の補足】
- Cesium Property/PropertyBag は `getValue(now)`（`now = Cesium.JulianDate.now()`）で実値に解決してからキー化する。
- `keyResolver` が返す値が Property の場合も同様に解決し、`String(value ?? 'unknown')` へ正規化する。

#### 2. Lightweight Data Structure / 軽量データ構造

```javascript
voxelInfo.layerStats = Map<layerKey: string, count: number>
```

**Rationale**:
- Memory-efficient: store only counts, not entity references
- Fast lookup: Map provides O(1) access
- Minimal overhead: ~8-16 bytes per unique layer per voxel
- メモリ効率的：カウントのみ保存、エンティティ参照は保持しない
- 高速ルックアップ：Mapは O(1) アクセスを提供
- 最小オーバーヘッド：ボクセルごとのユニークレイヤあたり ~8-16 バイト

#### 3. Top-N Summary in Statistics / 統計情報でのTop-N要約

```javascript
getStatistics() {
  return {
    // ...existing stats
    layers: [
      { key: 'residential', total: 5234 },
      { key: 'commercial', total: 2103 },
      { key: 'industrial', total: 987 }
      // ... top 10 by default
    ]
  };
}
```

**Rationale**:
- Prevent log bloat: only return top N layers (default: 10)
- Quick overview: most significant layers at a glance
- Full details available via voxel picking
- ログ肥大化を防止：上位N個のレイヤのみ返却（デフォルト：10）
- クイック概観：最も重要なレイヤを一目で確認
- ボクセルピッキングで完全な詳細を取得可能

#### 4. Picking Integration / ピッキング統合

```javascript
// When picking a voxel / ボクセルをピックした場合
voxelEntity.properties.layerTop = 'residential';  // Most common layer
voxelEntity.description = `
  <h3>Voxel Composition</h3>
  <ul>
    <li>residential: 30 (60%)</li>
    <li>commercial: 15 (30%)</li>
    <li>industrial: 5 (10%)</li>
  </ul>
`;
```

**Rationale**:
- Immediate context: user sees composition when clicking voxel
- Minimal: only show `layerTop` in properties (lightweight)
- Detailed: full breakdown in description (optional, controlled by flag)
- 即座のコンテキスト：ユーザーはボクセルクリック時に構成を確認
- 最小限：プロパティには`layerTop`のみ表示（軽量）
- 詳細：説明文で完全な内訳（オプション、フラグで制御）

#### 5. No Automatic Styling (v0.1.18) / 自動スタイリングなし（v0.1.18）

**Out of scope for v0.1.18**:
- Layer-based color/opacity/width customization
- Automatic style switching based on dominant layer
- Layer filtering (show/hide specific layers)

**v0.1.18のスコープ外**:
- レイヤベースの色/不透明度/太さのカスタマイズ
- 支配的レイヤに基づく自動スタイル切替
- レイヤフィルタリング（特定レイヤの表示/非表示）
- 点以外（ポリゴン/ポリライン/3D Tiles 等）の集約処理

**Rationale**:
- Separation of concerns: aggregation ≠ visualization
- Defer styling to v1.x classification system (ADR-TBD)
- Focus v0.1.18 on data structure and statistics
- 関心の分離：集約 ≠ 可視化
- スタイリングはv1.x分類システムに延期（ADR-TBD）
- v0.1.18はデータ構造と統計に集中

## Architecture / アーキテクチャ

### Component Structure / コンポーネント構造

```
src/
  core/
    DataProcessor.js           # Update: Add layer aggregation logic
  utils/
    validation.js              # Update: Add aggregation options validation
    constants.js               # Update: Add AGGREGATION_DEFAULTS
  Heatbox.js                   # Update: Pass aggregation options, expose layer stats
```

### DataProcessor Integration / DataProcessor統合

```javascript
// In DataProcessor.classifyEntitiesIntoVoxels()
import { resolvePropertyValue } from '../utils/cesiumProperty.js';

if (options.aggregation?.enabled) {
  const now = Cesium.JulianDate.now();

  // Determine key resolver / キーリゾルバを決定
  const byProp = options.aggregation.byProperty;
  const userResolver = options.aggregation.keyResolver;
  
  const getLayerKey = (entity) => {
    try {
      // 1) user resolver 優先
      if (typeof userResolver === 'function') {
        const raw = userResolver(entity);
        const val = resolvePropertyValue(raw, now);
        return String(val ?? 'unknown');
      }
      // 2) byProperty
      if (byProp) {
        // PropertyBag を優先的に解決
        const bag = entity.properties?.getValue?.(now);
        if (bag && typeof bag === 'object') {
          return String(bag[byProp] ?? 'unknown');
        }
        const prop = entity.properties?.[byProp];
        const val = resolvePropertyValue(prop, now);
        return String(val ?? 'unknown');
      }
    } catch (e) {
      Logger.warn('aggregation key resolution failed, fallback to "unknown"', e);
    }
    return 'unknown';
  };

  // Aggregate entities / エンティティを集約
  for (const entity of entities) {
    const voxelKey = /* ... calculate voxel key ... */;

    if (!voxelMap.has(voxelKey)) {
      voxelMap.set(voxelKey, {
        key: voxelKey,
        entities: [],
        count: 0,
        layerStats: new Map()  // NEW: layer aggregation
      });
    }

    const voxelInfo = voxelMap.get(voxelKey);
    voxelInfo.entities.push(entity);
    voxelInfo.count++;

    // NEW: Aggregate by layer (resolved key)
    const layerKey = getLayerKey(entity);
    voxelInfo.layerStats.set(layerKey, (voxelInfo.layerStats.get(layerKey) || 0) + 1);
  }

  // Calculate layerTop (most common layer per voxel)
  for (const voxelInfo of voxelMap.values()) {
    let maxCount = 0;
    let topLayer = null;
    for (const [layerKey, count] of voxelInfo.layerStats) {
      if (count > maxCount) { maxCount = count; topLayer = layerKey; }
    }
    voxelInfo.layerTop = topLayer;
  }
}
```

### Statistics Extension / 統計拡張

```javascript
// In Heatbox.getStatistics()

getStatistics() {
  const stats = {
    // ... existing stats
  };

  if (this._options.aggregation?.enabled) {
    // Aggregate across all voxels / 全ボクセルを集約
    const globalLayerCounts = new Map();
    
    for (const voxelInfo of this._voxelData.values()) {
      for (const [layerKey, count] of voxelInfo.layerStats) {
        globalLayerCounts.set(
          layerKey,
          (globalLayerCounts.get(layerKey) || 0) + count
        );
      }
    }
    
    // Top N layers / 上位N個のレイヤ（オプションで可変）
    const topN = this._options.aggregation?.topN ?? 10;
    const sorted = Array.from(globalLayerCounts.entries())
      .sort((a, b) => b[1] - a[1])  // Sort by count descending
      .slice(0, topN);
    
    stats.layers = sorted.map(([key, total]) => ({ key, total }));
  }

  return stats;
}
```

### Picking Integration / ピッキング統合

```javascript
// In GeometryRenderer.createVoxelBox()
import { escapeHtml } from '../../utils/escapeHtml.js';

if (options.aggregation?.enabled && voxelInfo.layerStats) {
  entityConfig.properties.layerTop = voxelInfo.layerTop;

  // Optional: add full layer breakdown to description (XSS-safe)
  if (options.aggregation.showInDescription !== false) {
    const layerBreakdown = Array.from(voxelInfo.layerStats.entries())
      .sort((a, b) => b[1] - a[1])
      .map(([key, count]) => {
        const pct = ((count / voxelInfo.count) * 100).toFixed(1);
        return `<li>${escapeHtml(String(key))}: ${count} (${pct}%)</li>`;
      })
      .join('');

    description += `
      <h4>Layer Composition / レイヤ構成</h4>
      <ul>${layerBreakdown}</ul>
    `;
  }
}
```

### Security Considerations / セキュリティ考慮

- HTMLへのレイヤ名の差し込みは必ず `escapeHtml` でエスケープし、XSSを防止する。
- レイヤキーは外部データ由来のため、`keyResolver`/`byProperty` で取得した値は `String(value ?? 'unknown')` に正規化し、過剰な長さや異常値はログ警告の上で扱う。

## Consequences / 影響

### Benefits / 利点

#### 1. Enhanced Observability / 観測可能性の向上
- ✅ Understand voxel composition without manual iteration
- ✅ Quick diagnosis of data quality issues
- ✅ Verify data source coverage
- ✅ 手動反復処理なしでボクセル構成を理解
- ✅ データ品質問題の迅速な診断
- ✅ データソースカバレッジの検証

#### 2. Performance / パフォーマンス
- ✅ Minimal overhead: ~8-16 bytes per unique layer per voxel
- ✅ No overhead when disabled (default)
- ✅ Target: ≤ +10% memory increase, ≤ +10% processing time
- ✅ 最小オーバーヘッド：ボクセルごとのユニークレイヤあたり ~8-16 バイト
- ✅ 無効時はオーバーヘッドなし（デフォルト）
- ✅ 目標：メモリ増加 ≤ +10%、処理時間増加 ≤ +10%

#### 3. Foundation for Future Features / 将来機能の基盤
- ✅ Enables layer-based classification in v1.x
- ✅ Supports temporal layer analysis (v1.2.0)
- ✅ Can be extended to PLATEAU/3D Tiles (future)
- ✅ v1.xでのレイヤベース分類を可能に
- ✅ 時系列レイヤ分析をサポート（v1.2.0）
- ✅ PLATEAU/3D Tilesへ拡張可能（将来）

#### 4. Flexibility / 柔軟性
- ✅ Supports both simple property-based and custom resolver-based aggregation
- ✅ Top-N summary prevents log bloat
- ✅ Optional detailed breakdown in voxel description
- ✅ シンプルなプロパティベースとカスタムリゾルバベースの両方をサポート
- ✅ Top-N要約でログ肥大化を防止
- ✅ ボクセル説明文でのオプショナルな詳細内訳

### Drawbacks / 欠点

#### 1. Memory Overhead / メモリオーバーヘッド
- ⚠️ Additional Map per voxel when enabled
- ⚠️ Scales with unique layer count per voxel
- ⚠️ 有効時はボクセルごとに追加のMap
- ⚠️ ボクセルごとのユニークレイヤ数に比例

**Mitigation**: Store only counts (not entity references), target ≤ +10% memory increase

**緩和策**：カウントのみ保存（エンティティ参照は保持しない）、メモリ増加 ≤ +10% を目標

#### 2. Processing Overhead / 処理オーバーヘッド
- ⚠️ Additional loop to resolve layer keys
- ⚠️ Map operations (set/get) per entity
- ⚠️ レイヤキー解決のための追加ループ
- ⚠️ エンティティごとのMap操作（set/get）

**Mitigation**: Target ≤ +10% processing time increase, skip when disabled

**緩和策**：処理時間増加 ≤ +10% を目標、無効時はスキップ

#### 3. API Surface Increase / API表面積の増加
- ⚠️ New options: `aggregation.enabled`, `byProperty`, `keyResolver`
- ⚠️ New statistics field: `layers`
- ⚠️ New entity property: `layerTop`
- ⚠️ 新しいオプション：`aggregation.enabled`、`byProperty`、`keyResolver`
- ⚠️ 新しい統計フィールド：`layers`
- ⚠️ 新しいエンティティプロパティ：`layerTop`

**Mitigation**: Clear documentation, opt-in (default disabled), consistent naming

**緩和策**：明確なドキュメント、オプトイン（デフォルト無効）、一貫した命名

#### 4. Limited Styling (v0.1.18) / 限定的なスタイリング（v0.1.18）
- ⚠️ No automatic color/opacity/width based on layers
- ⚠️ Users must manually interpret layer stats
- ⚠️ レイヤに基づく自動色/不透明度/太さなし
- ⚠️ ユーザーがレイヤ統計を手動で解釈する必要

**Mitigation**: Defer to v1.x classification system, provide examples of manual styling

**緩和策**：v1.x分類システムに延期、手動スタイリングの例を提供

### Risks & Mitigations / リスク & 緩和策

#### Risk: Layer Key Explosion / リスク：レイヤキーの爆発
If `keyResolver` returns too many unique keys (e.g., timestamps), memory usage could spike.

`keyResolver`があまりに多くのユニークキーを返す場合（例：タイムスタンプ）、メモリ使用量が急増する可能性があります。

**Mitigation**:
- Document best practices: use categorical keys (not continuous values)
- Add warning when unique layer count exceeds threshold (e.g., 100)
- Limit Top-N summary to prevent excessive logging
- ベストプラクティスをドキュメント化：カテゴリカルキーを使用（連続値は不可）
- ユニークレイヤ数がしきい値を超える場合に警告を追加（例：100）
- Top-N要約を制限して過度のログを防止

#### Risk: Invalid Key Resolver / リスク：無効なキーリゾルバ
User-provided `keyResolver` could throw errors or return non-string values.

ユーザー提供の`keyResolver`がエラーをスローしたり、非文字列値を返したりする可能性があります。

**Mitigation**:
- Wrap `keyResolver` calls in try/catch
- Coerce returned values to string
- Fall back to 'unknown' on error
- `keyResolver`呼び出しをtry/catchでラップ
- 返却値を文字列に強制変換
- エラー時は'unknown'にフォールバック

```javascript
try {
  layerKey = String(getLayerKey(entity));
} catch (error) {
  Logger.warn('keyResolver threw error, using "unknown"', error);
  layerKey = 'unknown';
}
```

#### Risk: Performance Regression / リスク：パフォーマンス退行
Additional Map operations could slow down large datasets.

追加のMap操作が大規模データセットを遅くする可能性があります。

**Mitigation**:
- Benchmark with 1k-5k voxels, target ≤ +10% processing time
- Profile Map operations, optimize hot paths
- Skip layer aggregation entirely when disabled (no overhead)
- 1k-5kボクセルでベンチマーク、処理時間 ≤ +10% を目標
- Map操作をプロファイル、ホットパスを最適化
- 無効時はレイヤ集約を完全にスキップ（オーバーヘッドなし）

## Implementation Plan / 実装計画

### Phase 1: Core Infrastructure (Days 1-2) / フェーズ1：コアインフラ（1-2日）

- [ ] Add `aggregation` options to `constants.js` (default: `enabled: false`)
- [ ] Add validation for `aggregation.enabled`, `byProperty`, `keyResolver` in `validation.js`
- [ ] Update JSDoc/TypeScript types for aggregation options

### Phase 2: DataProcessor Integration (Days 3-4) / フェーズ2：DataProcessor統合（3-4日）

- [ ] Implement layer key resolution logic (`byProperty` and `keyResolver`)
- [ ] Add `layerStats` Map to `voxelInfo` during entity classification
- [ ] Calculate `layerTop` (most common layer) per voxel
- [ ] Add error handling for invalid `keyResolver`

### Phase 3: Statistics Extension (Day 5) / フェーズ3：統計拡張（5日）

- [ ] Aggregate `layerStats` across all voxels in `getStatistics()`
- [ ] Return Top-N layers (default: 10) in `stats.layers`
- [ ] Add unit tests for global layer aggregation

### Phase 4: Picking Integration (Day 6) / フェーズ4：ピッキング統合（6日）

- [ ] Add `properties.layerTop` to rendered voxel entities
- [ ] Optionally add layer breakdown to voxel description
- [ ] Add flag `aggregation.showInDescription` (default: `true`)

### Phase 5: Testing (Days 7-8) / フェーズ5：テスト（7-8日）

- [ ] Unit tests: `byProperty` aggregation
- [ ] Unit tests: `keyResolver` aggregation
- [ ] Unit tests: Error handling (invalid resolver, non-string keys)
- [ ] Unit tests: Top-N summary
- [ ] Integration tests: Full workflow with aggregation enabled
- [ ] Performance tests: Verify ≤ +10% memory/time overhead

### Phase 6: Documentation & Examples (Days 9-10) / フェーズ6：ドキュメント・例（9-10日）

- [ ] Update README with aggregation section
- [ ] Add example: urban analytics (building types)
- [ ] Add example: multi-source data (sensor coverage)
- [ ] Document best practices (categorical keys, avoid timestamps)
- [ ] Update API documentation (JSDoc)

## Detailed Implementation Specification / 詳細実装仕様

### Requirements Summary / 要件サマリ

**Purpose / 目的**: Add layer-based aggregation for point entities (with `position` property) - flat categorical aggregation only.

**Scope / スコープ**: Point entities only. Polygons, polylines, and 3D Tiles are out of scope.

**Compatibility / 互換性**: Default is disabled (`enabled=false`). When disabled, zero overhead.

**Output / 出力**:
- Per voxel: `voxelInfo.layerStats: Map<string, number>` and `voxelInfo.layerTop: string|null`
- Global statistics: `getStatistics().layers: Array<{key, total}>` (Top-N, default N=10)

**Current State / 現状（前提）**:
- ROADMAP and ADR-0014 specifications are agreed upon (updated to clarify point entities only)
- Implementation not yet started (as of v0.1.17)
- However, `src/Heatbox.js:756` has the skeleton for global aggregation - if `voxelInfo.layerStats` exists, logic to return `stats.layers` is present
- Therefore, need to implement `layerStats` generation and `layerTop` calculation in DataProcessor, plus coordination with validation/constants/rendering description

### Implementation Tasks / 実装タスク

#### 1. Add Default Options / デフォルトオプション追加

**File**: `src/utils/constants.js`

**Specification**:
```javascript
DEFAULT_OPTIONS.aggregation = {
  enabled: false,
  byProperty: null,
  keyResolver: null,
  showInDescription: true,
  topN: 10
}
```
- Default is disabled
- `topN` is the number of layers to include in statistics summary

#### 2. Add Options Validation / オプション検証の追加

**File**: `src/utils/validation.js`

**Specification**:
- If `aggregation` is provided, normalize to object
- Validate fields:
  - `enabled`: boolean
  - `byProperty`: string|null
  - `keyResolver`: function|null
  - `showInDescription`: boolean
  - `topN`: number (>0, max 100 or any safe upper limit)
- If `keyResolver` is not a function, warn and set to null
- All fields default to `DEFAULTS` if not present

#### 3. Cesium Property Resolution Utility / Cesium Property解決ユーティリティ

**New File**: `src/utils/cesiumProperty.js`

**Function**: `resolvePropertyValue(prop, time)`
- If `prop?.getValue === 'function'`, call `getValue(time)`
- For PropertyBag, `getValue(time)` returns flattened object
- Catch exceptions and return `undefined`

**Note**: In DataProcessor, pass `Cesium.JulianDate.now()` as `time`

#### 4. HTML Escape Utility / HTMLエスケープユーティリティ

**New File**: `src/utils/escapeHtml.js`

**Function**: `escapeHtml(str)`
- Convert `& < > " '` to standard HTML entities
- Purpose: XSS prevention in description popups

#### 5. DataProcessor: Layer Aggregation Implementation (Both Modes) / DataProcessor: レイヤ集約の実装（両モード）

**File**: `src/core/DataProcessor.js`

**Target Functions**:
- Uniform grid: `classifyEntitiesIntoVoxels` (around line 23)
- Spatial ID mode: `_classifyBySpatialId` (around line 248)

**Specification**:

1. **Setup**: `const now = Cesium.JulianDate.now();`

2. **Key Resolution Logic**:
   - If `keyResolver` exists, call `(entity) => any`
     - If return value is Cesium Property, resolve with `resolvePropertyValue`
   - Otherwise, if `byProperty` specified:
     - If `entity.properties?.getValue(now)` exists, get flattened object and reference `byProperty`
     - Otherwise, get `entity.properties?.[byProperty]` directly and resolve with `resolvePropertyValue` if needed
   - On failure: `'unknown'`
   - Return value: `String(value ?? 'unknown')`

3. **VoxelInfo Initialization**: Add `layerStats: new Map()` when creating voxelInfo

4. **Per Entity**: `voxelInfo.layerStats.set(key, (prev||0)+1)`

5. **After Loop**: Calculate `voxelInfo.layerTop` as the most common category for each voxel

**Notes**:
- Maintain existing `entities.push` and `count++`
- Exceptions handled by existing try/catch with warn and skip
- When disabled (`aggregation.enabled=false`), do nothing

#### 6. Heatbox: Finalize Statistics Top-N / Heatbox: 統計Top-Nの最終化

**File**: `src/Heatbox.js` (around line 756)

**Specification**: Existing code has Top-N=10 hardcoded. Replace with `this.options.aggregation?.topN ?? 10`

#### 7. GeometryRenderer: Picking/Description Integration / GeometryRenderer: ピッキング/説明への反映

**File**: `src/core/geometry/GeometryRenderer.js`

**In `createVoxelBox(config)`** (around line 104):
- If `this.options.aggregation?.enabled && voxelInfo.layerStats`:
  - `entityConfig.properties.layerTop = voxelInfo.layerTop || null;`
  - Description: If `this.options.aggregation.showInDescription !== false`, create descending breakdown of `voxelInfo.layerStats` and append
  - When outputting breakdown, use `escapeHtml(key)` for layer names (XSS prevention)

**In `createVoxelDescription`**: Use `escapeHtml` for HTML construction as well

#### 8. Example Minor Fixes / 例の微修正

- `zoomControl: 'manual'` already added (for zoom slider reflection). No changes needed.

### Acceptance Criteria / 受け入れ基準

**Compatibility / 互換性**:
- With `aggregation.enabled=false` (default), no changes to existing behavior or statistics

**Correctness / 正しさ**:
- With `byProperty`, correctly resolves Cesium Property/PropertyBag and multiple keys appear in `layerStats`
- With `keyResolver`, correctly converts Property return values to key values
- Each voxel's `layerTop` returns the most common category
- `getStatistics().layers` returns only Top-N (N configurable via options)

**Security / セキュリティ**:
- Layer names output to description HTML are `escapeHtml` processed (XSS prevented)

**Performance / パフォーマンス**:
- When enabled, processing time and memory increase ≤ +10% (target)
- When disabled, zero overhead

**Display / 表示**:
- Picked voxel has `properties.layerTop` and description includes breakdown (% display) when `showInDescription=true`

### Testing (Jest, jsdom) / テスト（Jest, jsdom）

**Test File Example**: `test/core/aggregation/aggregation.test.js`

**Recommended Cases**:
- `byProperty` aggregation (including ConstantProperty/PropertyBag) with correct `layerStats` and `layerTop`
- `keyResolver` aggregation (including cases where return value is ConstantProperty)
- Top-N summary is cut at N items
- When aggregation disabled, `stats.layers` is undefined/empty
- XSS prevention: Layer name with `<script>` results in entity-escaped string in description (string comparison)

**Note**:
- For failure detection, always include `expect(targetVoxel).toBeDefined()` before target voxel/assertions

**Execution**:
- Default: `npm test --silent -- --reporters=summary --bail=1`

### Reference File Locations / 参考ファイル位置

- **DataProcessor** (aggregation implementation): `src/core/DataProcessor.js:23`, `src/core/DataProcessor.js:248`
- **Heatbox** (statistics Top-N): `src/Heatbox.js:756`
- **GeometryRenderer** (properties/description): `src/core/geometry/GeometryRenderer.js:104`, `src/core/geometry/GeometryRenderer.js:544`
- **Constants**: `src/utils/constants.js:1`
- **Validation**: `src/utils/validation.js:1`

### Implementation Guide / 実装ガイド

**Code Conventions / コード規約**:
- 2-space indent, semicolons required, prefer `const`
- Utilities in `src/utils/` with camelCase names

**Logging / ログ**:
- Minimal (follow existing Logger)
- New WARNs should have clear content

**Module Separation / モジュール分割**:
- Core in DataProcessor
- Shared logic in utils (Property resolution, HTML escape)

**Existing CI Constraints / 既存のCI制約**:
- Must pass: `npm run -s lint && npm run -s type-check && npm test --silent -- --reporters=summary`

## Testing Strategy / テスト戦略

### Unit Tests

#### DataProcessor Aggregation Tests
```javascript
describe('DataProcessor - Layer Aggregation', () => {
  it('should aggregate by property', () => {
    const entities = [
      { position: { x: 0, y: 0, z: 0 }, properties: { type: 'A' } },
      { position: { x: 0, y: 0, z: 0 }, properties: { type: 'B' } },
      { position: { x: 0, y: 0, z: 0 }, properties: { type: 'A' } }
    ];
    
    const options = {
      aggregation: { enabled: true, byProperty: 'type' }
    };
    
    const voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, bounds, grid, options);
    const voxelInfo = voxelData.values().next().value;
    
    expect(voxelInfo.layerStats.get('A')).toBe(2);
    expect(voxelInfo.layerStats.get('B')).toBe(1);
    expect(voxelInfo.layerTop).toBe('A');
  });

  it('should aggregate with keyResolver', () => {
    const entities = [
      { position: { x: 0, y: 0, z: 0 }, timestamp: '2025-11-02T08:00:00Z' },
      { position: { x: 0, y: 0, z: 0 }, timestamp: '2025-11-02T14:00:00Z' },
      { position: { x: 0, y: 0, z: 0 }, timestamp: '2025-11-02T08:00:00Z' }
    ];
    
    const options = {
      aggregation: {
        enabled: true,
        keyResolver: (entity) => {
          const hour = new Date(entity.timestamp).getHours();
          return hour < 12 ? 'morning' : 'afternoon';
        }
      }
    };
    
    const voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, bounds, grid, options);
    const voxelInfo = voxelData.values().next().value;
    
    expect(voxelInfo.layerStats.get('morning')).toBe(2);
    expect(voxelInfo.layerStats.get('afternoon')).toBe(1);
    expect(voxelInfo.layerTop).toBe('morning');
  });

  it('should handle keyResolver errors gracefully', () => {
    const entities = [
      { position: { x: 0, y: 0, z: 0 } }
    ];
    
    const options = {
      aggregation: {
        enabled: true,
        keyResolver: () => { throw new Error('Resolver error'); }
      }
    };
    
    const voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, bounds, grid, options);
    const voxelInfo = voxelData.values().next().value;
    
    expect(voxelInfo.layerStats.get('unknown')).toBe(1);
  });

  it('should not aggregate when disabled', () => {
    const entities = [
      { position: { x: 0, y: 0, z: 0 }, properties: { type: 'A' } }
    ];
    
    const options = {
      aggregation: { enabled: false }
    };
    
    const voxelData = DataProcessor.classifyEntitiesIntoVoxels(entities, bounds, grid, options);
    const voxelInfo = voxelData.values().next().value;
    
    expect(voxelInfo.layerStats).toBeUndefined();
    expect(voxelInfo.layerTop).toBeUndefined();
  });
});
```

#### Statistics Aggregation Tests
```javascript
describe('Heatbox.getStatistics() - Layer Aggregation', () => {
  it('should return top N layers globally', async () => {
    const entities = generateEntitiesWithLayers(1000, ['A', 'B', 'C', 'D']);
    
    const heatbox = new Heatbox(viewer, {
      aggregation: { enabled: true, byProperty: 'layer' }
    });
    
    await heatbox.createFromEntities(entities);
    const stats = heatbox.getStatistics();
    
    expect(stats.layers).toBeDefined();
    expect(stats.layers.length).toBeLessThanOrEqual(10);  // Top 10
    expect(stats.layers[0].total).toBeGreaterThanOrEqual(stats.layers[1].total);  // Sorted descending
  });

  it('should not return layers when disabled', async () => {
    const entities = generateTestEntities(100);
    
    const heatbox = new Heatbox(viewer, {
      aggregation: { enabled: false }
    });
    
    await heatbox.createFromEntities(entities);
    const stats = heatbox.getStatistics();
    
    expect(stats.layers).toBeUndefined();
  });
});
```

#### Performance Tests
```javascript
describe('Layer Aggregation - Performance', () => {
  it('should have ≤ +10% memory overhead', () => {
    const entities = generateEntitiesWithLayers(5000, ['A', 'B', 'C']);
    
    // Baseline: no aggregation / 基準：集約なし
    const memBefore1 = process.memoryUsage().heapUsed;
    const heatbox1 = new Heatbox(viewer, { aggregation: { enabled: false } });
    heatbox1.createFromEntities(entities);
    const memAfter1 = process.memoryUsage().heapUsed;
    const baselineMemory = memAfter1 - memBefore1;
    
    // With aggregation / 集約あり
    const memBefore2 = process.memoryUsage().heapUsed;
    const heatbox2 = new Heatbox(viewer, { aggregation: { enabled: true, byProperty: 'layer' } });
    heatbox2.createFromEntities(entities);
    const memAfter2 = process.memoryUsage().heapUsed;
    const aggregationMemory = memAfter2 - memBefore2;
    
    const overhead = (aggregationMemory - baselineMemory) / baselineMemory;
    expect(overhead).toBeLessThanOrEqual(0.10);  // ≤ +10%
  });

  it('should have ≤ +10% processing time overhead', () => {
    const entities = generateEntitiesWithLayers(5000, ['A', 'B', 'C']);
    
    // Baseline / 基準
    const start1 = performance.now();
    const heatbox1 = new Heatbox(viewer, { aggregation: { enabled: false } });
    heatbox1.createFromEntities(entities);
    const baselineTime = performance.now() - start1;
    
    // With aggregation / 集約あり
    const start2 = performance.now();
    const heatbox2 = new Heatbox(viewer, { aggregation: { enabled: true, byProperty: 'layer' } });
    heatbox2.createFromEntities(entities);
    const aggregationTime = performance.now() - start2;
    
    const overhead = (aggregationTime - baselineTime) / baselineTime;
    expect(overhead).toBeLessThanOrEqual(0.10);  // ≤ +10%
  });
});
```

### Integration Tests

```javascript
describe('Layer Aggregation - Integration', () => {
  it('should display layer composition when picking voxel', async () => {
    const entities = [
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), properties: { type: 'residential' } },
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), properties: { type: 'commercial' } },
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), properties: { type: 'residential' } }
    ];
    
    const heatbox = new Heatbox(viewer, {
      aggregation: { enabled: true, byProperty: 'type' }
    });
    
    await heatbox.createFromEntities(entities);
    
    const voxelEntity = viewer.entities.values[0];
    expect(voxelEntity.properties.layerTop).toBe('residential');
    expect(voxelEntity.description).toContain('Layer Composition');
    expect(voxelEntity.description).toContain('residential: 2');
    expect(voxelEntity.description).toContain('commercial: 1');
  });

  it('should support multi-source data aggregation', async () => {
    const entities = [
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), source: 'sensor-A' },
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), source: 'sensor-B' },
      { position: Cesium.Cartesian3.fromDegrees(139.7, 35.69, 50), source: 'sensor-A' }
    ];
    
    const heatbox = new Heatbox(viewer, {
      aggregation: {
        enabled: true,
        keyResolver: (entity) => entity.source
      }
    });
    
    await heatbox.createFromEntities(entities);
    const stats = heatbox.getStatistics();
    
    const sensorA = stats.layers.find(l => l.key === 'sensor-A');
    const sensorB = stats.layers.find(l => l.key === 'sensor-B');
    
    expect(sensorA.total).toBe(2);
    expect(sensorB.total).toBe(1);
  });
});
```

## Documentation Updates / ドキュメント更新

### README Section

Add new section: **Layer Aggregation (v0.1.18+)**

```markdown
## Layer Aggregation (v0.1.18+)

Aggregate entities within each voxel by custom layers (categories, types, sources).

### Basic Usage

```javascript
const heatbox = new Heatbox(viewer, {
  aggregation: {
    enabled: true,
    byProperty: 'buildingType'  // Use entity.properties.buildingType as layer key
  }
});

const stats = heatbox.getStatistics();
console.log(stats.layers);
// [
//   { key: 'residential', total: 5234 },
//   { key: 'commercial', total: 2103 },
//   { key: 'industrial', total: 987 }
// ]
```

### Custom Key Resolver

```javascript
const heatbox = new Heatbox(viewer, {
  aggregation: {
    enabled: true,
    keyResolver: (entity) => {
      // Custom logic to determine layer key / レイヤキーを決定するカスタムロジック
      const hour = new Date(entity.timestamp).getHours();
      return hour < 12 ? 'morning' : 'afternoon';
    }
  }
});
```

### Voxel Picking

When you click a voxel, the description shows layer composition:

```
Voxel Composition:
- residential: 30 (60%)
- commercial: 15 (30%)
- industrial: 5 (10%)
```

### Best Practices

- **Use categorical keys**: Avoid continuous values (timestamps, IDs) that create too many unique layers
- **Limit unique layers**: Keep unique layer count < 100 per voxel for optimal performance
- **Error handling**: `keyResolver` should return string values; errors fall back to 'unknown'

### Performance

- **Memory**: ~8-16 bytes per unique layer per voxel
- **Processing**: ≤ +10% overhead when enabled
- **No overhead**: When disabled (default), no performance impact
```

### API Documentation (JSDoc)

```javascript
/**
 * @typedef {Object} AggregationOptions
 * @property {boolean} [enabled=false] - Enable layer-based aggregation
 * @property {string} [byProperty] - Entity property key to use as layer key (e.g., 'buildingType')
 * @property {Function} [keyResolver] - Custom function (entity) => layerKey (takes precedence over byProperty)
 * @property {boolean} [showInDescription=true] - Include layer breakdown in voxel description
 */

/**
 * @typedef {Object} LayerSummary
 * @property {string} key - Layer key
 * @property {number} total - Total entity count for this layer across all voxels
 */

/**
 * @typedef {Object} Statistics
 * @property {Array<LayerSummary>} [layers] - Top N layers (when aggregation enabled)
 * @property {...} - Other existing statistics fields
 */

/**
 * @typedef {Object} VoxelInfo
 * @property {Map<string, number>} [layerStats] - Per-voxel layer counts (when aggregation enabled)
 * @property {string} [layerTop] - Most common layer key in this voxel
 * @property {...} - Other existing voxelInfo fields
 */
```

## Acceptance Criteria / 受け入れ基準

### Functional / 機能面

- [ ] `aggregation.enabled=true` aggregates entities by layer key
- [ ] `byProperty` correctly uses entity property as layer key
- [ ] `keyResolver` takes precedence over `byProperty`
- [ ] `layerStats` Map correctly stores counts per layer per voxel
- [ ] `layerTop` identifies most common layer per voxel
- [ ] `getStatistics()` returns Top-N layers (default: 10) sorted descending
- [ ] Voxel picking displays `layerTop` in properties
- [ ] Voxel description includes layer breakdown (when `showInDescription=true`)
- [ ] No behavior change when `aggregation.enabled=false` (default)

### Non-functional / 非機能面

- [ ] Memory overhead ≤ +10% vs baseline (1k-5k voxels, 3-10 unique layers)
- [ ] Processing time overhead ≤ +10% vs baseline
- [ ] No overhead when disabled (default)
- [ ] Graceful error handling for invalid `keyResolver`
- [ ] Warning logged when unique layer count exceeds threshold (100)

### Documentation / ドキュメント

- [ ] README includes Layer Aggregation section with examples
- [ ] JSDoc updated for `aggregation` options and related types
- [ ] Best practices documented (categorical keys, unique layer limits)
- [ ] Example: urban analytics (building types)
- [ ] Example: multi-source data (sensor coverage)

### Testing / テスト

- [ ] Unit tests: `byProperty` aggregation
- [ ] Unit tests: `keyResolver` aggregation
- [ ] Unit tests: Error handling (invalid resolver)
- [ ] Unit tests: Top-N summary in statistics
- [ ] Integration tests: Full workflow with picking
- [ ] Performance tests: Memory and processing time overhead

## Migration Guide / 移行ガイド

### For Existing Users / 既存ユーザー向け

**No migration required.** Layer aggregation is opt-in; existing code continues to work unchanged.

**移行不要。** レイヤ集約はオプトイン；既存コードは変更なしで動作します。

### To Enable Layer Aggregation / レイヤ集約を有効にするには

```javascript
// Before (no aggregation) / 以前（集約なし）
const heatbox = new Heatbox(viewer);

// After (with aggregation) / 以降（集約あり）
const heatbox = new Heatbox(viewer, {
  aggregation: {
    enabled: true,
    byProperty: 'type'  // or keyResolver
  }
});

const stats = heatbox.getStatistics();
console.log(stats.layers);  // Top N layers
```

## Future Work / 今後の作業

### v1.x: Layer-based Classification / レイヤベース分類

```javascript
// Automatic color/opacity/width based on dominant layer
// 支配的レイヤに基づく自動色/不透明度/太さ
{
  classification: 'layer-dominant',
  layerStyles: {
    'residential': { color: 'blue', opacity: 0.6 },
    'commercial': { color: 'red', opacity: 0.8 },
    'industrial': { color: 'gray', opacity: 0.5 }
  }
}
```

### v1.x: Layer Filtering / レイヤフィルタリング

```javascript
// Show/hide specific layers
// 特定レイヤの表示/非表示
{
  layerFilter: {
    visible: ['residential', 'commercial'],  // Hide 'industrial'
    mode: 'whitelist'  // or 'blacklist'
  }
}
```

### v1.2.0: Temporal Layer Analysis / 時系列レイヤ分析

```javascript
// Aggregate by time window and layer
// 時間帯とレイヤで集約
{
  aggregation: {
    enabled: true,
    keyResolver: (entity) => {
      const hour = new Date(entity.timestamp).getHours();
      return `${entity.properties.type}-hour${hour}`;
    }
  },
  temporalClassificationScope: 'per-time'  // Update layer stats per time slice
}
```

### Future: PLATEAU Integration / PLATEAU統合

If Heatbox is extended to support large-scale polygon/3D Tiles data (e.g., PLATEAU):
- Extract aggregation logic into separate package (`@cesium-heatbox/aggregation`)
- Support multi-geometry aggregation (points, polygons, 3D Tiles)
- Provide common aggregation layer for broader ecosystem

将来、Heatboxが大規模ポリゴン/3D Tilesデータ（例：PLATEAU）をサポートするように拡張される場合：
- 集約ロジックを別パッケージに抽出（`@cesium-heatbox/aggregation`）
- 複数ジオメトリ集約をサポート（点、ポリゴン、3D Tiles）
- より広いエコシステムのための共通集約レイヤを提供

## References / 参照

- ROADMAP v0.1.18: Lines 300-324
- ROADMAP v1.x Classification: TBD
- ROADMAP v1.2.0 Temporal: Lines 513-530

---

## Implementation Notes / 実装メモ

### Implementation Status / 実装状況

**Status**: ✅ Fully implemented and tested  
**Branch**: `feature/v0.1.18-layer-aggregation`  
**Date**: 2025-11-02

### Deviations from Original Specification / 当初仕様からの変更点

The detailed specification above proposed creating separate utility files (`src/utils/cesiumProperty.js` and `src/utils/escapeHtml.js`). However, the actual implementation integrates these utilities directly into the consuming modules for better cohesion:

上記の詳細仕様では、別個のユーティリティファイル（`src/utils/cesiumProperty.js`と`src/utils/escapeHtml.js`）の作成を提案していました。しかし、実際の実装では、より良い凝集性のため、これらのユーティリティを消費モジュールに直接統合しています：

1. **Cesium Property Resolution / Cesium Property解決**:
   - **Proposed**: Separate `src/utils/cesiumProperty.js` with `resolvePropertyValue(prop, time)` function
   - **Implemented**: Inline resolution logic in `DataProcessor.js` within the aggregation setup (lines 46-65, 382-401)
   - **Rationale**: Property resolution is tightly coupled to aggregation logic and only used in DataProcessor. Inline implementation avoids unnecessary module indirection.
   
   **提案**: 独立した`src/utils/cesiumProperty.js`に`resolvePropertyValue(prop, time)`関数
   **実装**: `DataProcessor.js`の集約セットアップ内でインライン解決ロジック（46-65行、382-401行）
   **理由**: Property解決は集約ロジックと密結合しており、DataProcessorでのみ使用。インライン実装により不要なモジュール間接参照を回避。

2. **HTML Escape / HTMLエスケープ**:
   - **Proposed**: Separate `src/utils/escapeHtml.js` with `escapeHtml(str)` function
   - **Implemented**: Private method `_escapeHtml(str)` in `GeometryRenderer.js` (lines 558-567)
   - **Rationale**: HTML escaping is only needed in GeometryRenderer for voxel descriptions. Private method keeps implementation encapsulated.
   
   **提案**: 独立した`src/utils/escapeHtml.js`に`escapeHtml(str)`関数
   **実装**: `GeometryRenderer.js`のプライベートメソッド`_escapeHtml(str)`（558-567行）
   **理由**: HTMLエスケープはGeometryRendererのボクセル説明でのみ必要。プライベートメソッドにより実装をカプセル化。

### Cesium PropertyBag Resolution / Cesium PropertyBag解決

**Implemented**: All aggregation paths correctly resolve Cesium `Property` and `PropertyBag` values before using them as layer keys.

**実装済み**: 全ての集約パスで、Cesium `Property` および `PropertyBag` の値をレイヤキーとして使用する前に正しく解決しています。

- **byProperty mode**: `getValue(currentTime)` is called automatically in `DataProcessor.js` (lines 46-65, 382-401)
- **keyResolver mode**: Example implementations in `examples/aggregation/multi-source.html` demonstrate proper resolution
- **String normalization**: All layer keys are coerced to strings using `String(layerKey)` (lines 164, 502)
- **Error handling**: Failed resolutions fall back to `'unknown'` with warning logs

**byPropertyモード**: `DataProcessor.js`で自動的に`getValue(currentTime)`を呼び出し（46-65行、382-401行）  
**keyResolverモード**: `examples/aggregation/multi-source.html`の実装例で適切な解決を実証  
**String正規化**: 全てのレイヤキーを`String(layerKey)`で文字列化（164行、502行）  
**エラーハンドリング**: 解決失敗時は警告ログと共に`'unknown'`にフォールバック

### XSS Prevention / XSS対策

**Implemented**: HTML escaping is applied to all layer keys before injecting them into voxel descriptions.

**実装済み**: 全てのレイヤキーをボクセル説明に注入する前にHTMLエスケープを適用しています。

- `GeometryRenderer._escapeHtml()` method (lines 558-567)
- Applied to layer keys in description (line 596) and layerTop (line 600)
- Prevents XSS attacks from malicious entity properties

`GeometryRenderer._escapeHtml()`メソッド（558-567行）  
説明内のレイヤキー（596行）とlayerTop（600行）に適用  
悪意のあるエンティティプロパティからのXSS攻撃を防止

### Test Coverage / テストカバレッジ

- **Unit tests**: `test/core/aggregation.test.js` (PropertyBag resolution, string coercion, error handling)
- **Integration tests**: `test/integration/aggregation.test.js` (full workflow, XSS prevention)
- **Examples**: `examples/aggregation/single-source.html`, `examples/aggregation/multi-source.html`

**ユニットテスト**: `test/core/aggregation.test.js`（PropertyBag解決、文字列変換、エラーハンドリング）  
**統合テスト**: `test/integration/aggregation.test.js`（完全なワークフロー、XSS防止）  
**サンプル**: `examples/aggregation/single-source.html`、`examples/aggregation/multi-source.html`

---

**Approval**: Implemented and tested  
**Implementation Target**: v0.1.18 (2025-11-02)
