# ADR-0013: Spatial ID Support (tile-grid mode) - v0.1.17

**Status**: Proposed  
**Date**: 2025-11-02  
**Author**: hiro-nyon  
**Target Version**: v0.1.17  
**Related**: ROADMAP v0.1.17, PREP-ADR-0013

## Context / 背景

### Problem Statement / 問題提起

Current Heatbox uses a uniform voxel grid defined by user-specified `voxelSize` (in meters). While this approach is simple and performant, it has limitations when integrating with spatial index systems that require tile-based addressing.

現在のHeatboxはユーザー指定の`voxelSize`（メートル単位）による一様ボクセルグリッドを使用しています。このアプローチはシンプルで高速ですが、タイルベースのアドレッシングを必要とする空間インデックスシステムとの統合には制限があります。

### Use Cases / ユースケース

1. **Data interoperability** / **データ相互運用性**
   - Share voxel data with systems using METI Spatial ID (4D space-time infrastructure)
   - Export/import voxelized data with standardized spatial identifiers
   - MEI空間ID（4次元時空間情報基盤）を使用するシステムとボクセルデータを共有
   - 標準化された空間識別子でボクセル化データをエクスポート/インポート

2. **Hierarchical spatial queries** / **階層的空間クエリ**
   - Navigate between zoom levels (parent/children)
   - Query neighboring voxels efficiently
   - ズームレベル間の移動（親/子）
   - 隣接ボクセルの効率的なクエリ

3. **Multi-resolution visualization** / **多解像度可視化**
   - Adaptive zoom-based detail levels
   - Consistent addressing across resolutions
   - ズームベースの適応的詳細レベル
   - 解像度間での一貫したアドレッシング

### Existing Infrastructure / 既存のインフラ

**ouranos-gex-lib-for-javascript** provides a reference implementation of METI Spatial ID specification:
- Open source (MIT license)
- Maintained by Geolonia Inc.
- Converts lng/lat/alt to ZFXY (3D tile coordinates)
- Provides 8-vertex bounding boxes for each voxel
- Supports zoom levels 0-35

**ouranos-gex-lib-for-javascript**はMETI空間ID仕様のリファレンス実装を提供：
- オープンソース（MITライセンス）
- Geolonia社がメンテナンス
- lng/lat/altをZFXY（3次元タイル座標）に変換
- 各ボクセルの8頂点バウンディングボックスを提供
- ズームレベル0-35をサポート

## Decision / 決定事項

### Core Decision / 核となる決定

We will add **opt-in Spatial ID support** as a new voxel generation mode in v0.1.17, while **maintaining the existing uniform grid as the default**.

v0.1.17で**オプトイン式の空間IDサポート**を新しいボクセル生成モードとして追加し、**既存の一様グリッドをデフォルトとして維持**します。

### Key Design Choices / 主要な設計選択

#### 1. Opt-in Mode / オプトインモード

```javascript
{
  spatialId: {
    enabled: false,  // Default: existing uniform grid
    mode: 'tile-grid',  // v0.1.17: only tile-grid mode
    provider: 'ouranos-gex',  // or null for built-in fallback
    zoom: 25,  // or 'auto'
    zoomControl: 'auto',  // 'auto' | 'manual'
    zoomTolerancePct: 10  // for auto zoom selection
  }
}
```

**Rationale**:
- Non-breaking: existing code continues to work unchanged
- Clear separation: different modes for different use cases
- Future extensibility: can add other spatial index systems
- 非破壊的：既存のコードは変更なしで動作し続ける
- 明確な分離：異なるユースケースに対する異なるモード
- 将来の拡張性：他の空間インデックスシステムを追加可能

#### 2. ID Format Convention / ID形式の規約

**Public API**: Use `.zfxyStr` (URL path format)

```
/25/15/29304/13104
```

**Internal only**: `.tilehash` (hashed format, not exposed)

**Rationale**:
- zfxyStr is human-readable and web-compatible
- Matches METI guideline examples
- Can be used in URLs, filenames, keys
- zfxyStrは人間可読でウェブ互換
- METIガイドラインの例と一致
- URL、ファイル名、キーとして使用可能

#### 3. Optional Dependency / オプショナル依存

```json
{
  "optionalDependencies": {
    "ouranos-gex-lib-for-javascript": "github:ouranos-gex/ouranos-gex-lib-for-JavaScript"
  }
}
```

**Rationale**:
- Library remains functional without ouranos-gex
- Users can opt out of spatial ID features
- Reduces bundle size for users who don't need it
- Built-in fallback ensures basic functionality
- ouranos-gexなしでもライブラリは機能する
- ユーザーは空間ID機能をオプトアウト可能
- 不要なユーザーのバンドルサイズを削減
- 内蔵フォールバックが基本機能を保証

#### 4. Dynamic Import with Fallback / 動的インポートとフォールバック

```javascript
// Attempt to load ouranos-gex
let OuranosSpace = null;
try {
  const module = await import('ouranos-gex-lib-for-javascript');
  OuranosSpace = module.Space;
  Logger.info('ouranos-gex loaded successfully');
} catch (error) {
  Logger.warn('ouranos-gex not available, using built-in ZFXY adapter', error);
  OuranosSpace = null;
}
```

**Fallback behavior**:
- Use built-in ZFXY converter (approximate calculation)
- Log warning but continue processing
- Set `spatialIdProvider: null` in statistics
- フォールバック挙動：
  - 内蔵ZFXYコンバーター使用（近似計算）
  - 警告をログに出力するが処理は継続
  - 統計情報で`spatialIdProvider: null`を設定

#### 5. Auto Zoom Selection / 自動ズーム選択

```javascript
if (zoomControl === 'auto') {
  // Find zoom level where XY cell size matches voxelSize within tolerance
  // Target: relative error ≤ zoomTolerancePct (default 10%)
  
  const targetSize = options.voxelSize || 30;  // meters
  let bestZoom = 25;
  let minError = Infinity;
  
  for (let z = 15; z <= 30; z++) {
    const cellSizeXY = calculateCellSizeAtZoom(z, centerLat);
    const relativeError = Math.abs(cellSizeXY - targetSize) / targetSize;
    
    if (relativeError < minError && relativeError <= zoomTolerancePct / 100) {
      bestZoom = z;
      minError = relativeError;
    }
  }
  
  return bestZoom;
}
```

**Rationale**:
- XY dimensions are prioritized (horizontal extent)
- Z dimension (altitude) uses F coordinate from ZFXY
- Users can override with manual zoom for specific resolutions
- XY次元を優先（水平方向の範囲）
- Z次元（高度）はZFXYのF座標を使用
- ユーザーは特定の解像度のために手動ズームで上書き可能

#### 6. Deferred Global QA / グローバルQAの延期

**v0.1.17 scope** / **v0.1.17のスコープ**:
- Basic tile-grid mode implementation
- Ouranos-gex integration
- Auto zoom selection
- 基本的なtile-gridモードの実装
- ouranos-gex統合
- 自動ズーム選択

**Deferred to v0.1.19** / **v0.1.19に延期**:
- ±180° longitude wrap edge cases
- ±85.0511° latitude boundary testing
- Hemisphere crossing scenarios
- Comprehensive antimeridian demo
- ±180°経度ラップのエッジケース
- ±85.0511°緯度境界のテスト
- 半球跨ぎシナリオ
- 包括的な日付変更線デモ

**Rationale**:
- v0.1.17 focuses on core integration and basic functionality
- Global edge cases require extensive testing and examples
- Allows earlier delivery of core features
- v0.1.17はコア統合と基本機能に集中
- グローバルエッジケースは広範なテストと例が必要
- コア機能の早期提供が可能

## Architecture / アーキテクチャ

### Component Structure / コンポーネント構造

```
src/
  core/
    spatial/
      SpatialIdAdapter.js          # New: Spatial ID abstraction layer
      ZFXYConverter.js              # New: Built-in ZFXY converter (fallback)
  utils/
    validation.js                   # Update: Add spatialId options validation
    constants.js                    # Update: Add SPATIAL_ID_DEFAULTS
  Heatbox.js                        # Update: Pass spatialId options
  DataProcessor.js                  # Update: Use SpatialIdAdapter when enabled
```

### SpatialIdAdapter Interface / SpatialIdAdapterインターフェース

```javascript
class SpatialIdAdapter {
  constructor(options = {}) {
    this.provider = options.provider || 'ouranos-gex';
    this.Space = null;  // Set via loadProvider()
    this.fallbackMode = false;
  }

  async loadProvider() {
    if (this.provider === 'ouranos-gex') {
      try {
        const module = await import('ouranos-gex-lib-for-javascript');
        this.Space = module.Space;
        Logger.info('ouranos-gex loaded');
      } catch (error) {
        Logger.warn('ouranos-gex not available, using built-in fallback');
        this.fallbackMode = true;
      }
    }
  }

  /**
   * Get voxel bounds from coordinates
   * @param {number} lng - Longitude
   * @param {number} lat - Latitude  
   * @param {number} alt - Altitude (meters)
   * @param {number} zoom - Zoom level (0-35)
   * @returns {{zfxy, zfxyStr, vertices: Array<{lng, lat, alt}>}}
   */
  getVoxelBounds(lng, lat, alt, zoom) {
    if (this.Space && !this.fallbackMode) {
      const space = new this.Space({ lng, lat, alt }, zoom);
      return {
        zfxy: space.zfxy,         // {z, f, x, y}
        zfxyStr: space.zfxyStr,   // PUBLIC API format
        vertices: space.vertices3d()  // 8 corners
      };
    } else {
      return ZFXYConverter.convert(lng, lat, alt, zoom);
    }
  }

  /**
   * Calculate optimal zoom level for target cell size
   * @param {number} targetSize - Target cell size in meters
   * @param {number} centerLat - Center latitude for calculation
   * @param {number} tolerance - Tolerance percentage (default: 10)
   * @returns {number} Optimal zoom level
   */
  calculateOptimalZoom(targetSize, centerLat, tolerance = 10) {
    // Implementation based on decision #5
    // ...
  }
}
```

### DataProcessor Integration / DataProcessor統合

```javascript
// In DataProcessor.js
if (options.spatialId?.enabled) {
  const adapter = new SpatialIdAdapter({
    provider: options.spatialId.provider
  });
  
  await adapter.loadProvider();
  
  // Determine zoom level
  let zoom;
  if (options.spatialId.zoomControl === 'auto') {
    zoom = adapter.calculateOptimalZoom(
      options.voxelSize || 30,
      centerLat,
      options.spatialId.zoomTolerancePct || 10
    );
  } else {
    zoom = options.spatialId.zoom || 25;
  }
  
  // Process entities
  const voxelMap = new Map();
  
  for (const entity of entities) {
    const { zfxy, zfxyStr, vertices } = adapter.getVoxelBounds(
      entity.position.lng,
      entity.position.lat,
      entity.position.alt,
      zoom
    );
    
    // Aggregate by zfxyStr (public key format)
    if (!voxelMap.has(zfxyStr)) {
      voxelMap.set(zfxyStr, {
        key: zfxyStr,
        bounds: vertices,  // 8 vertices from ouranos-gex or fallback
        spatialId: { ...zfxy, id: zfxyStr },
        entities: [],
        count: 0
      });
    }
    
    const voxelInfo = voxelMap.get(zfxyStr);
    voxelInfo.entities.push(entity);
    voxelInfo.count++;
  }
  
  return voxelMap;
}
```

### VoxelRenderer Update / VoxelRenderer更新

```javascript
// VoxelRenderer uses voxelInfo.bounds (8 vertices) to calculate center and dimensions
const centerLon = (bounds[0].lng + bounds[4].lng) / 2;  // Example calculation
const centerLat = (bounds[0].lat + bounds[4].lat) / 2;
const centerAlt = (bounds[0].alt + bounds[4].alt) / 2;

const cellSizeX = Cesium.Cartesian3.distance(
  Cesium.Cartesian3.fromDegrees(bounds[0].lng, bounds[0].lat, bounds[0].alt),
  Cesium.Cartesian3.fromDegrees(bounds[1].lng, bounds[1].lat, bounds[1].alt)
);
// ... similar for Y and Z dimensions

// Pass to GeometryRenderer.createVoxelBox()
this.geometryRenderer.createVoxelBox({
  centerLon, centerLat, centerAlt,
  cellSizeX, cellSizeY, boxHeight,
  // ... other params
});
```

## Consequences / 影響

### Benefits / 利点

#### 1. Interoperability / 相互運用性
- ✅ Compatible with METI Spatial ID ecosystem
- ✅ Can share voxelized data with other systems
- ✅ Hierarchical queries (parent/children/neighbors)
- ✅ METI空間IDエコシステムと互換
- ✅ ボクセル化データを他システムと共有可能
- ✅ 階層的クエリ（親/子/隣接）

#### 2. Future-proof / 将来性
- ✅ Foundation for 4D (time dimension) support in v1.2.0
- ✅ Can add other spatial index systems (OLC, H3, etc.)
- ✅ Consistent addressing across zoom levels
- ✅ v1.2.0での4D（時間次元）サポートの基盤
- ✅ 他の空間インデックスシステム（OLC、H3など）を追加可能
- ✅ ズームレベル間での一貫したアドレッシング

#### 3. Non-breaking / 非破壊的
- ✅ Existing code continues to work unchanged
- ✅ Opt-in: users explicitly enable spatial ID mode
- ✅ Fallback ensures functionality without ouranos-gex
- ✅ 既存コードは変更なしで動作継続
- ✅ オプトイン：ユーザーが明示的に空間IDモードを有効化
- ✅ フォールバックでouranos-gexなしでも機能

#### 4. Performance / パフォーマンス
- ✅ Built-in fallback is lightweight (no external dependency required)
- ✅ Spatial ID lookups can be optimized with tile indices
- ✅ 内蔵フォールバックは軽量（外部依存不要）
- ✅ 空間IDルックアップはタイルインデックスで最適化可能

### Drawbacks / 欠点

#### 1. Complexity / 複雑性
- ⚠️ Additional code path for spatial ID mode
- ⚠️ Need to maintain both uniform grid and tile-grid modes
- ⚠️ Testing complexity increases (with/without ouranos-gex)
- ⚠️ 空間IDモードの追加コードパス
- ⚠️ 一様グリッドとtile-gridの両モードを維持
- ⚠️ テストの複雑性増加（ouranos-gexあり/なし）

#### 2. High-latitude distortion / 高緯度歪み
- ⚠️ XY cell dimensions vary with latitude (Web Mercator projection)
- ⚠️ Not suitable for polar regions (±85.0511° limit)
- ⚠️ Users should choose manual zoom at high latitudes
- ⚠️ 緯度によってXYセル寸法が変化（Web Mercator投影）
- ⚠️ 極域には不適（±85.0511°制限）
- ⚠️ 高緯度ではユーザーが手動ズームを選択すべき

#### 3. Deferred edge cases / エッジケースの延期
- ⚠️ ±180° longitude wrap not fully tested in v0.1.17
- ⚠️ Boundary scenarios deferred to v0.1.19
- ⚠️ Requires documentation of limitations
- ⚠️ ±180°経度ラップはv0.1.17で完全テストされない
- ⚠️ 境界シナリオはv0.1.19に延期
- ⚠️ 制限事項のドキュメント化が必要

#### 4. Dependency uncertainty / 依存関係の不確実性
- ⚠️ ouranos-gex is beta/development version (v0.0.0)
- ⚠️ API may change in future updates
- ⚠️ Built-in fallback may diverge from reference implementation
- ⚠️ ouranos-gexはベータ/開発版（v0.0.0）
- ⚠️ APIが将来のアップデートで変更される可能性
- ⚠️ 内蔵フォールバックがリファレンス実装と乖離する可能性

### Mitigations / 緩和策

#### For Complexity / 複雑性への対応
- Clear separation of concerns (SpatialIdAdapter abstraction)
- Comprehensive unit tests for both modes
- Examples demonstrating both uniform and tile-grid modes
- 関心の明確な分離（SpatialIdAdapter抽象化）
- 両モードの包括的な単体テスト
- 一様グリッドとtile-gridの両モードを示す例

#### For High-latitude Issues / 高緯度問題への対応
- Document latitude-dependent distortion in README
- Provide manual zoom selection option
- Add warnings in documentation and examples
- READMEで緯度依存の歪みを文書化
- 手動ズーム選択オプションを提供
- ドキュメントと例で警告を追加

#### For Edge Cases / エッジケースへの対応
- v0.1.19 dedicated to global QA testing
- Document known limitations in v0.1.17
- Add unit tests for common scenarios (0-180°E, 30-60°N)
- v0.1.19をグローバルQAテストに専念
- v0.1.17で既知の制限事項を文書化
- 一般的なシナリオの単体テスト追加（0-180°E、30-60°N）

#### For Dependency Uncertainty / 依存関係の不確実性への対応
- Built-in fallback ensures basic functionality
- Abstract via SpatialIdAdapter (easy to swap implementations)
- Monitor ouranos-gex updates and test against releases
- 内蔵フォールバックが基本機能を保証
- SpatialIdAdapter経由で抽象化（実装の交換が容易）
- ouranos-gexのアップデートを監視し、リリースに対してテスト

## Implementation Plan / 実装計画

### Phase 1: Core Infrastructure (Days 1-3) / フェーズ1：コアインフラ（1-3日）

- [ ] Create `src/core/spatial/` directory
- [ ] Implement `SpatialIdAdapter` with dynamic import
- [ ] Implement `ZFXYConverter` (built-in fallback)
- [ ] Add `spatialId` options to validation
- [ ] Update `constants.js` with defaults

### Phase 2: DataProcessor Integration (Days 4-5) / フェーズ2：DataProcessor統合（4-5日）

- [ ] Update `DataProcessor.js` to use SpatialIdAdapter when enabled
- [ ] Implement auto zoom selection algorithm
- [ ] Aggregate entities by zfxyStr key
- [ ] Store bounds as 8 vertices in voxelInfo

### Phase 3: VoxelRenderer Update (Day 6) / フェーズ3：VoxelRenderer更新（6日）

- [ ] Update VoxelRenderer to calculate center/dimensions from bounds
- [ ] Add `properties.spatialId` to rendered entities
- [ ] Update picking to display spatial ID info

### Phase 4: Statistics & Observability (Day 7) / フェーズ4：統計・観測可能性（7日）

- [ ] Add `spatialIdEnabled`, `spatialIdProvider`, `spatialIdZoom` to `getStatistics()`
- [ ] Add `zoomControl` mode to statistics
- [ ] Log warnings when fallback is used

### Phase 5: Testing (Days 8-10) / フェーズ5：テスト（8-10日）

- [ ] Unit tests: SpatialIdAdapter (with/without ouranos-gex)
- [ ] Unit tests: ZFXYConverter (fallback)
- [ ] Unit tests: Auto zoom selection
- [ ] Integration tests: Full workflow with spatial ID mode
- [ ] Edge case tests: Common scenarios (defer global edge cases to v0.1.19)

### Phase 6: Documentation & Examples (Days 11-12) / フェーズ6：ドキュメント・例（11-12日）

- [ ] Update README with spatial ID section
- [ ] Add example: basic spatial ID usage
- [ ] Document limitations (high latitude, edge cases)
- [ ] Update API documentation (JSDoc)

## Testing Strategy / テスト戦略

### Unit Tests

#### SpatialIdAdapter Tests
```javascript
describe('SpatialIdAdapter', () => {
  it('should load ouranos-gex when available', async () => {
    const adapter = new SpatialIdAdapter({ provider: 'ouranos-gex' });
    await adapter.loadProvider();
    expect(adapter.Space).toBeDefined();
    expect(adapter.fallbackMode).toBe(false);
  });

  it('should use fallback when ouranos-gex not available', async () => {
    // Mock import failure
    jest.mock('ouranos-gex-lib-for-javascript', () => {
      throw new Error('Module not found');
    });
    const adapter = new SpatialIdAdapter({ provider: 'ouranos-gex' });
    await adapter.loadProvider();
    expect(adapter.fallbackMode).toBe(true);
  });

  it('should return 8 vertices from getVoxelBounds', () => {
    const adapter = new SpatialIdAdapter();
    const result = adapter.getVoxelBounds(139.6917, 35.6895, 50, 25);
    expect(result.vertices).toHaveLength(8);
    expect(result.zfxyStr).toMatch(/^\/\d+\/\d+\/\d+\/\d+$/);
  });

  it('should match ouranos-gex vertices when available', () => {
    // Assuming ouranos-gex is loaded
    const { Space } = require('ouranos-gex-lib-for-javascript');
    const space = new Space({ lng: 139.6917, lat: 35.6895, alt: 50 }, 25);
    const expected = space.vertices3d();

    const adapter = new SpatialIdAdapter();
    const result = adapter.getVoxelBounds(139.6917, 35.6895, 50, 25);
    
    expect(result.vertices).toEqual(expected);
  });
});
```

#### ZFXYConverter Tests
```javascript
describe('ZFXYConverter', () => {
  it('should convert lng/lat/alt to ZFXY', () => {
    const result = ZFXYConverter.convert(139.6917, 35.6895, 50, 25);
    expect(result.zfxy).toEqual({ z: 25, f: expect.any(Number), x: expect.any(Number), y: expect.any(Number) });
  });

  it('should generate 8 vertices for bounding box', () => {
    const result = ZFXYConverter.convert(139.6917, 35.6895, 50, 25);
    expect(result.vertices).toHaveLength(8);
    // Verify vertices form a valid box
    const lngs = result.vertices.map(v => v.lng);
    const lats = result.vertices.map(v => v.lat);
    const alts = result.vertices.map(v => v.alt);
    expect(Math.max(...lngs) - Math.min(...lngs)).toBeGreaterThan(0);
    expect(Math.max(...lats) - Math.min(...lats)).toBeGreaterThan(0);
    expect(Math.max(...alts) - Math.min(...alts)).toBeGreaterThan(0);
  });

  it('should clamp latitude to ±85.0511', () => {
    const result = ZFXYConverter.convert(0, 90, 0, 25);
    expect(result.vertices[0].lat).toBeLessThanOrEqual(85.0511);
  });
});
```

#### Auto Zoom Selection Tests
```javascript
describe('Auto Zoom Selection', () => {
  it('should select zoom with XY error ≤ 10%', () => {
    const adapter = new SpatialIdAdapter();
    const zoom = adapter.calculateOptimalZoom(30, 35.6895, 10);
    
    const cellSize = calculateCellSizeAtZoom(zoom, 35.6895);
    const relativeError = Math.abs(cellSize - 30) / 30;
    expect(relativeError).toBeLessThanOrEqual(0.10);
  });

  it('should return zoom within 15-30 range', () => {
    const adapter = new SpatialIdAdapter();
    const zoom = adapter.calculateOptimalZoom(100, 35.6895, 10);
    expect(zoom).toBeGreaterThanOrEqual(15);
    expect(zoom).toBeLessThanOrEqual(30);
  });
});
```

### Integration Tests

```javascript
describe('Spatial ID Integration', () => {
  it('should create voxels with spatial ID when enabled', async () => {
    const heatbox = new Heatbox(viewer, {
      spatialId: {
        enabled: true,
        mode: 'tile-grid',
        zoom: 25
      }
    });

    const entities = generateTestEntities(100);
    const stats = await heatbox.createFromEntities(entities);

    expect(stats.spatialIdEnabled).toBe(true);
    expect(stats.spatialIdZoom).toBe(25);

    // Verify rendered entities have spatialId properties
    const voxelEntities = heatbox.getVoxelEntities();
    expect(voxelEntities[0].properties.spatialId).toBeDefined();
    expect(voxelEntities[0].properties.spatialId.id).toMatch(/^\/\d+\/\d+\/\d+\/\d+$/);
  });

  it('should work without ouranos-gex (fallback)', async () => {
    // Mock ouranos-gex unavailability
    jest.mock('ouranos-gex-lib-for-javascript', () => {
      throw new Error('Module not found');
    });

    const heatbox = new Heatbox(viewer, {
      spatialId: {
        enabled: true,
        mode: 'tile-grid',
        zoom: 25
      }
    });

    const entities = generateTestEntities(100);
    const stats = await heatbox.createFromEntities(entities);

    expect(stats.spatialIdEnabled).toBe(true);
    expect(stats.spatialIdProvider).toBeNull();
    // Should still render successfully with built-in fallback
    expect(stats.renderedVoxels).toBeGreaterThan(0);
  });
});
```

## Documentation Updates / ドキュメント更新

### README Section

Add new section: **Spatial ID Support (v0.1.17+)**

```markdown
## Spatial ID Support (v0.1.17+)

Heatbox supports METI Spatial ID (4D space-time infrastructure) for tile-based voxel addressing.

### Basic Usage

```javascript
const heatbox = new Heatbox(viewer, {
  spatialId: {
    enabled: true,
    mode: 'tile-grid',  // v0.1.17: only tile-grid mode
    zoom: 25,  // or 'auto' for automatic selection
    zoomControl: 'auto'  // 'auto' | 'manual'
  }
});
```

### Auto Zoom Selection

When `zoomControl: 'auto'`, Heatbox selects the zoom level where XY cell size matches your `voxelSize` within 10% tolerance.

```javascript
const heatbox = new Heatbox(viewer, {
  voxelSize: 50,  // target 50m cells
  spatialId: {
    enabled: true,
    zoomControl: 'auto',
    zoomTolerancePct: 10  // allow ±10% error
  }
});
```

### Accessing Spatial IDs

Each rendered voxel includes spatial ID information:

```javascript
viewer.selectedEntity = voxelEntity;
console.log(voxelEntity.properties.spatialId);
// { z: 25, f: 15, x: 29304, y: 13104, id: "/25/15/29304/13104" }
```

### Limitations

- **Latitude range**: ±85.0511° (Web Mercator projection limit)
- **High-latitude distortion**: XY cell dimensions vary with latitude; use manual zoom at high latitudes
- **Edge cases**: ±180° longitude wrap and boundary scenarios are fully tested in v0.1.19

### Optional Dependency

Spatial ID support requires `ouranos-gex-lib-for-javascript`. If not installed, Heatbox uses a built-in fallback with approximate calculations.

```bash
npm install github:ouranos-gex/ouranos-gex-lib-for-JavaScript
```
```

### API Documentation (JSDoc)

```javascript
/**
 * @typedef {Object} SpatialIdOptions
 * @property {boolean} [enabled=false] - Enable spatial ID mode
 * @property {'tile-grid'} [mode='tile-grid'] - Spatial ID mode (v0.1.17: tile-grid only)
 * @property {string} [provider='ouranos-gex'] - Spatial ID provider
 * @property {number|'auto'} [zoom=25] - Zoom level or 'auto' for automatic selection
 * @property {'auto'|'manual'} [zoomControl='auto'] - Zoom control mode
 * @property {number} [zoomTolerancePct=10] - Tolerance percentage for auto zoom selection
 */
```

## Acceptance Criteria / 受け入れ基準

### Functional / 機能面

- [ ] `spatialId.enabled=true` creates tile-grid voxels instead of uniform grid
- [ ] Each voxel's 8 vertices match `Space.vertices3d()` (within floating-point tolerance)
- [ ] `properties.spatialId` contains `{z, f, x, y, id}` where `id` is zfxyStr format
- [ ] `zoomControl:'auto'` selects zoom with XY relative error ≤ 10%
- [ ] Works without ouranos-gex (built-in fallback)
- [ ] `getStatistics()` includes `spatialIdEnabled`, `spatialIdProvider`, `spatialIdZoom`, `zoomControl`

### Non-functional / 非機能面

- [ ] No performance regression for existing uniform grid mode (±5%)
- [ ] Spatial ID mode overhead ≤ 15% vs uniform grid (similar entity count)
- [ ] Built-in fallback adds ≤ 5KB to bundle size

### Documentation / ドキュメント

- [ ] README includes Spatial ID section with examples
- [ ] JSDoc updated for spatialId options
- [ ] Known limitations documented (latitude, edge cases)
- [ ] Example demonstrating basic spatial ID usage

### Testing / テスト

- [ ] Unit tests: SpatialIdAdapter (with/without ouranos-gex)
- [ ] Unit tests: ZFXYConverter fallback
- [ ] Unit tests: Auto zoom selection
- [ ] Integration tests: Full spatial ID workflow
- [ ] Edge case tests: Common scenarios (0-180°E, 30-60°N)

## Migration Guide / 移行ガイド

### For Existing Users / 既存ユーザー向け

**No migration required.** Spatial ID support is opt-in; existing code continues to work unchanged.

**移行不要。** 空間IDサポートはオプトイン；既存コードは変更なしで動作します。

### To Enable Spatial ID / 空間IDを有効にするには

```javascript
// Before (uniform grid)
const heatbox = new Heatbox(viewer, {
  voxelSize: 30
});

// After (tile-grid with spatial ID)
const heatbox = new Heatbox(viewer, {
  spatialId: {
    enabled: true,
    zoomControl: 'auto'  // Auto-select zoom to match ~30m cells
  }
});
```

## Future Work / 今後の作業

### v0.1.19: Global QA / グローバルQA

- Comprehensive ±180° longitude wrap testing
- ±85.0511° latitude boundary scenarios
- Hemisphere crossing test cases
- Antimeridian demo example

### v1.2.0: 4D (Time Dimension) / 4次元（時間次元）

- Extend spatial ID to include time component
- Temporal classification scope (per-time vs global)
- Time-based voxel animation

### Future: Additional Spatial Index Systems / その他の空間インデックスシステム

- Open Location Code (OLC / Plus Codes)
- H3 (Uber's Hexagonal Hierarchical Spatial Index)
- QuadKeys (Microsoft Bing Maps Tile System)

## References / 参照

- PREP-ADR-0013: ouranos-gex API Summary
- ROADMAP v0.1.17: Lines 239-298
- ROADMAP v0.1.19: Lines 325-361
- ouranos-gex GitHub: https://github.com/ouranos-gex/ouranos-gex-lib-for-JavaScript
- METI Guideline: https://www.ipa.go.jp/digital/architecture/project/autonomousmobilerobot/3dspatial_guideline.html

---

**Approval**: Pending review and discussion  
**Implementation Target**: v0.1.17 (2025-11-15)

