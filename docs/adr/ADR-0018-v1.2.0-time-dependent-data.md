# ADR-0018: v1.2.0 時間依存データ（PoC）

**Status**: Approved
**Date**: 2025-11-19
**Author**: hiro-nyon
**Target Version**: v1.2.0
**Related**: ROADMAP v1.2.0, ADR-0017 (Classification Extension)

## Context / 背景

### Problem Statement / 問題提起

現在の Heatbox（v0.1.x〜v1.1.x）は **静的なボクセルデータの可視化** に特化しており、時間経過に伴って変化するデータ（時系列データ）を扱う標準的な方法が存在しません。

CesiumJS は `viewer.clock` および `JulianDate` による強力な時間管理機能を持ち、CZML や 3D Tiles などのフォーマットは時間依存プロパティをネイティブにサポートしています。しかし、Heatbox はこの時間軸と一切連動していないため、動的なデータ可視化（例：人流の推移、気象データの変化、移動体の軌跡密度、疫病の拡散シミュレーションなど）を実現するには、以下のような **回避策** が必要になります：

1. **アプリケーション側での Clock 監視とデータ更新**: `viewer.clock.onTick` リスナーを登録し、毎フレーム `setData()` を呼び出す
2. **手動スロットリング**: 更新頻度を制限するため、フレームカウンターやタイマーを自前で実装する
3. **統計量の再計算回避**: 時間変化しても色の意味（絶対値）を固定したい場合、全期間の統計量を事前計算し、`colorResolver` で直接色を計算する

これらの回避策は、**パフォーマンス問題**、**実装の複雑性**、**保守コスト** をもたらします。特に、`setData()` はボクセルグリッドの完全再構築（インデックス生成、境界計算、統計量計算）を行うため、毎フレーム呼び出すと FPS が著しく低下します（例: 10,000点のデータで60fps → 5fps に低下）。

さらに、時間変化に伴う **色の正規化（Classification）のスコープ** （全期間で正規化するか、その瞬間だけで正規化するか）を制御する標準的な仕組みがなく、以下の問題が発生します：

- **Global 正規化の欠如**: 「赤色 = 100人以上」のような絶対値基準を維持できない。深夜（最大10人）と昼間（最大1,000人）で同じ「赤」になってしまい、時点間の比較が困難。
- **Per-Time 正規化の自動化不足**: その瞬間のコントラストを最大化したい場合でも、毎回手動で統計量を再計算する必要がある。

v1.2.0 では、Cesium のタイムライン機能と自然に連携する時間依存ボクセル可視化を実現します。

### Use Cases / ユースケース

#### 1. 人流・交通流の時系列変化（パフォーマンスと統合）
渋谷駅周辺の24時間の人流データをアニメーション表示します。
- **課題**: 毎フレーム `setData` を呼ぶと重すぎる。
- **解決策**: Heatbox 内部で `viewer.clock` を監視し、データ変更時のみ効率的に部分更新を行います。二分探索とキャッシュにより、データ検索も O(1)〜O(log n) に高速化されます。

#### 2. 分類スコープの制御（Global vs Per-Time）
都市の気温分布など、時刻によって値のレンジが大きく変わるデータを扱います。
- **Global Scope**: 全期間の統計量（Min 15℃ / Max 40℃）で色を固定。「35℃以上は赤」という絶対基準で警告を表示したい場合に適しています。
- **Per-Time Scope**: その瞬間の統計量（深夜は Min 18℃ / Max 22℃）で色を動的に正規化。深夜の中での相対的なホットスポットを見つけたい場合に適しています。

#### その他のユースケース
- **シミュレーション結果**: 災害拡散予測など、数万ステップのデータをスムーズに再生。
- **CZML との統合**: 航空機の軌跡（CZML）とボクセル密度を同期して表示。
- **不規則なデータ**: イベント駆動型の不規則な時間間隔データもサポート。

### Goals / 目標

1.  **開発者エクスペリエンス**: `temporal` オプション一つで時系列対応を可能にする。
2.  **パフォーマンス**: 10,000点のデータで 60fps 以上を維持（現状の5倍向上）。
3.  **柔軟性**: Global/Per-Time スコープの選択により、絶対値・相対値の両方の可視化に対応。

### Scope / スコープ

**In Scope (v1.2.0)**:
- `viewer.clock` と連動した自動更新
- 高速なデータ検索（TimeSlicer）
- Global/Per-Time Classification Scope
- 基本的なエッジケース処理（範囲外、隙間）

**Out of Scope**:
- データの補間（Interpolation）: v1.3.0
- 遅延ロード（Lazy Loading）: v1.3.0
- 3D Tiles 統合: v2.0

## Decision / 決定事項

### 1. Temporal Options の導入

Heatbox のコンストラクタオプションに `temporal` プロパティを追加し、時系列データの挙動を完全に制御できるようにします。

```javascript
/**
 * @typedef {Object} TemporalDataEntry
 * @property {JulianDate|string|Date|number} start - 開始時刻
 *   - JulianDate: そのまま使用
 *   - string: ISO8601形式（例: '2025-01-15T12:00:00Z'）として解釈
 *   - Date: JavaScript Date オブジェクト
 *   - number: Unix timestamp (秒単位)
 * @property {JulianDate|string|Date|number} stop - 終了時刻（形式は start と同じ）
 * @property {Array<Object>} data - その期間のポイントデータ配列
 *   - 各要素は通常の Heatbox データ形式（lat, lon, alt, weight など）
 */

/**
 * @typedef {Object} TemporalOptions
 * @property {boolean} [enabled=false] - 時間依存モードの有効化
 * @property {TemporalDataEntry[]} [data=[]] - 時系列データソース
 * @property {'global'|'per-time'} [classificationScope='global'] - 分類スコープ
 *   - 'global': 全期間の統計量を使用（色の絶対値が固定）
 *   - 'per-time': 各時点の統計量を使用（コントラスト最大化）
 * @property {number|'frame'} [updateInterval=100] - 更新チェック間隔
 *   - number: ミリ秒単位（例: 100 = 100msごとにチェック）
 *   - 'frame': 毎フレームチェック（高頻度だが変更検知により最適化）
 * @property {'clear'|'hold'} [outOfRangeBehavior='hold'] - 範囲外の挙動
 *   - 'clear': データ範囲外ではボクセルをクリア
 *   - 'hold': 最後のデータを保持（デフォルト）
 * @property {'skip'|'prefer-earlier'|'prefer-later'} [overlapResolution='prefer-earlier']
 *   - データ範囲が重複している場合の解決策
 *   - 'skip': 重複を検出したらエラー
 *   - 'prefer-earlier': 早い方のエントリーを優先
 *   - 'prefer-later': 遅い方のエントリーを優先
 * @property {boolean} [interpolate=false] - (Future) データ間の補間を行うか
 *   - v1.2.0では false 固定（v1.3.0で実装予定）
 */
```

**使用例**:

```javascript
const heatbox = new Heatbox(viewer, {
  // ... 既存オプション（voxelSize, colorMap など）
  temporal: {
    enabled: true,
    data: [
      {
        start: '2025-01-15T00:00:00Z',
        stop: '2025-01-15T01:00:00Z',
        data: [{ lat: 35.6, lon: 139.7, weight: 10 }, ...]
      },
      // ... 他の時刻
    ],
    classificationScope: 'global',
    updateInterval: 100,
    outOfRangeBehavior: 'clear'
  }
});
```

### 2. Classification Scope の仕様

- **Global Scope**: 初期化時に全データの統計量（Min/Max/Quantiles）を計算・キャッシュします。時点間の比較が可能で、更新時の計算コストはゼロです。
- **Per-Time Scope**: 描画更新ごとにその時点のデータから統計量を計算します。常にコントラストが最大化されますが、計算コストがかかります。

### 3. TimeSlicer によるデータ抽出

単純な線形探索ではなく、以下の最適化を実装します：
1.  **キャッシュ**: 前回アクセスしたエントリーを保持し、連続再生時は O(1) で取得。
2.  **近傍探索**: 前回のインデックスの前後を優先的にチェック。
3.  **二分探索**: ランダムアクセス時は O(log n) で検索。

## Architecture / アーキテクチャ

### Component Structure / コンポーネント構造

```
src/
  core/
    temporal/                          # NEW: 時系列データ管理モジュール
      TimeController.js                # NEW: Clock監視と更新トリガー
      TimeSlicer.js                    # NEW: 時系列データの管理と抽出
    Heatbox.js                         # UPDATE: temporal オプションの初期化、破棄処理
    DataProcessor.js                   # UPDATE: 外部統計量の受け入れ
  utils/
    temporalUtils.js                   # NEW: JulianDate変換・比較ヘルパー
test/
  core/
    temporal/                          # NEW: テストファイル
      TimeController.test.js
      TimeSlicer.test.js
  integration/
    temporal-integration.test.js      # NEW: 統合テスト
```

### 詳細なクラス構造

#### TimeController クラス

```javascript
/**
 * Cesium Clock と Heatbox を連携させるコントローラ
 * - viewer.clock.onTick を監視
 * - TimeSlicer を使って現在時刻のデータを取得
 * - データ変更時に Heatbox を更新
 */
class TimeController {
  constructor(viewer, heatbox, options) {
    this._viewer = viewer;
    this._heatbox = heatbox;
    this._slicer = new TimeSlicer(options.data, options);
    this._options = options;
    
    this._lastUpdateTime = null;      // 前回更新した実時間（スロットリング用）
    this._lastEntry = null;           // 前回のデータエントリー（変更検知用）
    this._removeListener = null;      // Clock リスナー削除用
    this._isActive = false;
  }

  activate() {
    if (this._isActive) return;
    this._isActive = true;

    // Global scope の場合、初期化時に統計量を計算
    if (this._options.classificationScope === 'global') {
      const globalStats = this._slicer.calculateGlobalStats(
        this._heatbox._options.valueProperty || 'weight'
      );
      this._heatbox._globalStats = globalStats;
    }

    // Clock リスナーを登録
    this._removeListener = this._viewer.clock.onTick.addEventListener(
      this._onTick.bind(this)
    );

    // 初回更新
    this._onTick(this._viewer.clock);
  }

  deactivate() {
    if (!this._isActive) return;
    this._isActive = false;

    if (this._removeListener) {
      this._removeListener();
      this._removeListener = null;
    }
  }

  _onTick(clock) {
    const now = clock.currentTime;
    
    // スロットリングチェック
    if (!this._shouldUpdate(now)) return;

    // 現在時刻に対応するデータを取得
    const entry = this._slicer.getEntry(now);
    
    // データが前回と同じなら何もしない（変更検知）
    if (entry === this._lastEntry) return;
    
    this._lastEntry = entry;
    this._updateHeatbox(entry);
  }

  _shouldUpdate(now) {
    const interval = this._options.updateInterval;
    
    if (interval === 'frame') {
      return true;  // 毎フレーム更新
    }

    // 前回更新からの経過時間をチェック
    const currentRealTime = Date.now();
    if (
      this._lastUpdateTime === null ||
      currentRealTime - this._lastUpdateTime >= interval
    ) {
      this._lastUpdateTime = currentRealTime;
      return true;
    }

    return false;
  }

  _updateHeatbox(entry) {
    if (!entry) {
      // データなし: outOfRangeBehavior に従う
      if (this._options.outOfRangeBehavior === 'clear') {
        this._heatbox.clear();
      }
      return;
    }

    // データ更新オプション
    const updateOptions = { _skipRebuild: false };

    // Global scope の場合、事前計算済みの統計量を渡す
    if (this._options.classificationScope === 'global') {
      updateOptions._externalStats = this._heatbox._globalStats;
    }

    this._heatbox.setData(entry.data, updateOptions);
  }

  /**
   * 時系列データを動的に更新（将来拡張用）
   */
  updateData(newData) {
    this._slicer = new TimeSlicer(newData, this._options);
    
    if (this._options.classificationScope === 'global') {
      const globalStats = this._slicer.calculateGlobalStats(
        this._heatbox._options.valueProperty || 'weight'
      );
      this._heatbox._globalStats = globalStats;
    }

    // 現在時刻で再描画
    const entry = this._slicer.getEntry(this._viewer.clock.currentTime);
    this._lastEntry = null;  // 強制更新
    this._updateHeatbox(entry);
  }

  /**
   * デバッグ情報取得
   */
  getDebugInfo() {
    return {
      isActive: this._isActive,
      currentEntry: this._lastEntry,
      totalEntries: this._slicer._entries.length,
      currentIndex: this._slicer._currentIndex,
      cacheHitRate: this._slicer.getCacheHitRate()
    };
  }
}
```

#### TimeSlicer クラス

```javascript
/**
 * 時系列データの管理と高速検索
 * - データのソート・正規化
 * - 二分探索 + キャッシュによる高速検索
 * - Global 統計量の計算
 */
class TimeSlicer {
  constructor(rawData, options = {}) {
    this._options = options;
    this._entries = this._normalizeAndSort(rawData);
    this._currentIndex = 0;
    this._currentEntry = null;
    this._globalStatsCache = {};
    
    // パフォーマンス計測用
    this._searchCount = 0;
    this._cacheHits = 0;
  }

  /**
   * データの正規化とソート
   */
  _normalizeAndSort(rawData) {
    if (!Array.isArray(rawData) || rawData.length === 0) {
      throw new Error('Temporal data must be a non-empty array');
    }

    // 正規化
    const normalized = rawData.map((entry, index) => {
      if (!entry.start || !entry.stop || !entry.data) {
        throw new Error(
          `Invalid entry at index ${index}: missing start, stop, or data`
        );
      }

      const start = this._toJulianDate(entry.start);
      const stop = this._toJulianDate(entry.stop);

      // 時刻検証
      if (JulianDate.greaterThan(start, stop)) {
        throw new Error(
          `Invalid time range at index ${index}: start > stop`
        );
      }

      // 単一時点データの処理
      if (JulianDate.equals(start, stop)) {
        stop = JulianDate.addSeconds(start, 1, new JulianDate());
      }

      return { start, stop, data: entry.data };
    });

    // ソート
    normalized.sort((a, b) => JulianDate.compare(a.start, b.start));

    // オーバーラップ検証
    if (this._options.overlapResolution === 'skip') {
      this._validateNoOverlap(normalized);
    }

    return normalized;
  }

  _toJulianDate(value) {
    if (value instanceof Cesium.JulianDate) return value;
    if (typeof value === 'string') {
      return Cesium.JulianDate.fromIso8601(value);
    }
    if (value instanceof Date) {
      return Cesium.JulianDate.fromDate(value);
    }
    if (typeof value === 'number') {
      return Cesium.JulianDate.fromDate(new Date(value * 1000));
    }
    throw new Error(`Unsupported time format: ${typeof value}`);
  }

  _validateNoOverlap(entries) {
    for (let i = 0; i < entries.length - 1; i++) {
      const current = entries[i];
      const next = entries[i + 1];
      
      if (JulianDate.greaterThan(current.stop, next.start)) {
        throw new Error(
          `Data overlap detected: entry ${i} stops at ${current.stop}, ` +
          `but entry ${i + 1} starts at ${next.start}`
        );
      }
    }
  }

  /**
   * 現在時刻に対応するエントリーを取得
   */
  getEntry(currentTime) {
    this._searchCount++;

    // キャッシュチェック
    if (this._currentEntry) {
      if (
        JulianDate.greaterThanOrEquals(currentTime, this._currentEntry.start) &&
        JulianDate.lessThan(currentTime, this._currentEntry.stop)
      ) {
        this._cacheHits++;
        return this._currentEntry;
      }
    }

    // 近傍探索
    const nearbyIndices = [
      this._currentIndex,
      this._currentIndex + 1,
      this._currentIndex - 1
    ];

    for (const idx of nearbyIndices) {
      if (idx >= 0 && idx < this._entries.length) {
        const entry = this._entries[idx];
        if (this._isInRange(currentTime, entry)) {
          this._currentIndex = idx;
          this._currentEntry = entry;
          return entry;
        }
      }
    }

    // 二分探索
    const index = this._binarySearch(currentTime);
    if (index >= 0) {
      this._currentIndex = index;
      this._currentEntry = this._entries[index];
      return this._currentEntry;
    }

    // 見つからない
    this._currentEntry = null;
    return null;
  }

  _isInRange(time, entry) {
    return (
      JulianDate.greaterThanOrEquals(time, entry.start) &&
      JulianDate.lessThan(time, entry.stop)
    );
  }

  _binarySearch(time) {
    let left = 0;
    let right = this._entries.length - 1;

    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const entry = this._entries[mid];

      if (this._isInRange(time, entry)) {
        return mid;
      }

      if (JulianDate.lessThan(time, entry.start)) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }

    return -1;
  }

  /**
   * Global 統計量を計算
   */
  calculateGlobalStats(valueProperty = 'weight') {
    const cacheKey = valueProperty;
    
    if (this._globalStatsCache[cacheKey]) {
      return this._globalStatsCache[cacheKey];
    }

    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    let count = 0;
    const allValues = [];

    for (const entry of this._entries) {
      for (const point of entry.data) {
        const value = point[valueProperty] ?? 1;
        min = Math.min(min, value);
        max = Math.max(max, value);
        sum += value;
        count++;
        allValues.push(value);
      }
    }

    // 平均・中央値
    const mean = count > 0 ? sum / count : 0;
    allValues.sort((a, b) => a - b);
    const median = this._calculateMedian(allValues);

    // 分位数（必要に応じて）
    const quantiles = this._calculateQuantiles(allValues, [0.25, 0.5, 0.75]);

    this._globalStatsCache[cacheKey] = {
      min,
      max,
      mean,
      median,
      quantiles,
      domain: [min, max],
      count
    };

    return this._globalStatsCache[cacheKey];
  }

  _calculateMedian(sortedValues) {
    if (sortedValues.length === 0) return 0;
    const mid = Math.floor(sortedValues.length / 2);
    if (sortedValues.length % 2 === 0) {
      return (sortedValues[mid - 1] + sortedValues[mid]) / 2;
    }
    return sortedValues[mid];
  }

  _calculateQuantiles(sortedValues, quantiles) {
    return quantiles.map(q => {
      const index = Math.floor(sortedValues.length * q);
      return sortedValues[Math.min(index, sortedValues.length - 1)];
    });
  }

  /**
   * キャッシュヒット率（パフォーマンス分析用）
   */
  getCacheHitRate() {
    return this._searchCount > 0
      ? this._cacheHits / this._searchCount
      : 0;
  }

  /**
   * 時間範囲情報を取得
   */
  getTimeRange() {
    if (this._entries.length === 0) {
      return null;
    }
    return {
      start: this._entries[0].start,
      stop: this._entries[this._entries.length - 1].stop
    };
  }
}
```

### DataFlow / データフロー

#### 初期化フロー

```
1. Heatbox Constructor
   │
   ├─ options.temporal.enabled === true?
   │   ├─ YES → TimeController を作成
   │   │   │
   │   │   ├─ TimeSlicer を初期化
   │   │   │   ├─ データの正規化（string/Date → JulianDate）
   │   │   │   ├─ start 時刻でソート
   │   │   │   └─ オーバーラップ検証
   │   │   │
   │   │   └─ classificationScope === 'global'?
   │   │       ├─ YES → calculateGlobalStats()
   │   │       │   ├─ 全エントリーを走査
   │   │       │   ├─ min/max/mean/median を計算
   │   │       │   └─ キャッシュに保存
   │   │       │
   │   │       └─ NO → 何もしない
   │   │
   │   └─ TimeController.activate()
   │       ├─ viewer.clock.onTick にリスナー登録
   │       └─ 初回更新（現在時刻のデータを表示）
   │
   └─ NO → 通常の静的モード（既存の動作）
```

#### 更新フロー（Clock Tick）

```
1. viewer.clock.onTick イベント発火（毎フレーム or 設定間隔）
   │
   ├─ TimeController._onTick()
   │   │
   │   ├─ _shouldUpdate() でスロットリング判定
   │   │   ├─ updateInterval === 'frame' → 常に true
   │   │   └─ updateInterval === number → 前回からの経過時間をチェック
   │   │
   │   ├─ TimeSlicer.getEntry(clock.currentTime)
   │   │   │
   │   │   ├─ キャッシュチェック（前回と同じエントリー？）
   │   │   │   └─ HIT → すぐ返す（O(1)）
   │   │   │
   │   │   ├─ 近傍探索（currentIndex ± 1）
   │   │   │   └─ HIT → インデックス更新して返す（O(1)）
   │   │   │
   │   │   └─ 二分探索
   │   │       └─ HIT/MISS → 結果を返す（O(log n)）
   │   │
   │   ├─ データ変更検知（entry !== lastEntry?）
   │   │   └─ 同じなら何もせず終了（描画スキップ）
   │   │
   │   └─ _updateHeatbox(entry)
   │       │
   │       ├─ entry === null?
   │       │   ├─ YES → outOfRangeBehavior に従う
   │       │   │   ├─ 'clear' → heatbox.clear()
   │       │   │   └─ 'hold' → 何もしない
   │       │   │
   │       │   └─ NO → 続行
   │       │
   │       ├─ updateOptions を構築
   │       │   └─ classificationScope === 'global'?
   │       │       └─ YES → _externalStats を含める
   │       │
   │       └─ heatbox.setData(entry.data, updateOptions)
   │           │
   │           ├─ DataProcessor.process()
   │           │   ├─ _externalStats あり？
   │           │   │   └─ YES → 統計計算をスキップ
   │           │   │
   │           │   └─ NO → _calculateStatistics() 実行
   │           │
   │           ├─ VoxelGrid.rebuild()
   │           │   └─ ボクセルへのエンティティ割り当て
   │           │
   │           └─ VoxelRenderer.update()
   │               └─ Cesium エンティティの更新
   │
   └─ 次の Tick まで待機
```

### Integration Points / 統合ポイント

#### 1. Heatbox クラスの拡張

```javascript
class Heatbox {
  constructor(viewer, options = {}) {
    // ... 既存の初期化処理

    // Temporal モードの初期化
    if (options.temporal?.enabled) {
      this._timeController = new TimeController(viewer, this, options.temporal);
      this._timeController.activate();
    } else {
      this._timeController = null;
    }
  }

  destroy() {
    // Temporal リソースの破棄
    if (this._timeController) {
      this._timeController.deactivate();
      this._timeController = null;
    }

    // ... 既存の破棄処理
  }
}
```

#### 2. DataProcessor の拡張

```javascript
class DataProcessor {
  process(data, options = {}) {
    // ... データ検証

    // 外部統計量の受け入れ
    if (options._externalStats) {
      this._stats = options._externalStats;
      // 統計計算をスキップ
    } else {
      this._stats = this._calculateStatistics(data);
    }

    // ... 残りの処理
  }
}
```

## Detailed Design / 詳細設計

詳細な実装コードは **Architecture** セクションに記載されています。ここでは、実装時の重要なポイントをまとめます。

### 1. TimeController の責務

- Cesium Clock の `onTick` イベント監視
- スロットリングによる更新頻度制御
- TimeSlicer を使った現在時刻のデータ取得
- データ変更検知と Heatbox への更新指示
- リソースのライフサイクル管理（activate/deactivate）

### 2. TimeSlicer の最適化戦略

- **三段階検索**: キャッシュ → 近傍探索 → 二分探索
- **データ正規化**: 複数の時刻形式を JulianDate に統一
- **統計量キャッシュ**: Global Scope 時の事前計算
- **パフォーマンス計測**: キャッシュヒット率の追跡

### 3. DataProcessor の拡張

- `options._externalStats` を受け入れ、統計計算をスキップ
- 既存のロジックとの互換性維持（`_externalStats` がない場合は従来通り）
- `valueProperty` の柔軟なサポート

### 4. エラーハンドリング

- データ検証エラー（start/stop/data の欠如）
- 時刻形式エラー（サポートされていない型）
- オーバーラップエラー（`overlapResolution: 'skip'` 時）
- 範囲外アクセス（データが見つからない場合の挙動）

## Implementation Plan / 実装計画

### Phase 1: 基盤実装（Days 1-3）

**目的**: TimeController と TimeSlicer の基本機能を実装

#### Tasks

- [ ] `src/core/temporal/` ディレクトリを作成
- [ ] `TimeSlicer.js` を実装
  - [ ] コンストラクタとデータ正規化 (`_normalizeAndSort`)
  - [ ] JulianDate 変換 (`_toJulianDate`)
  - [ ] 基本的なデータ検索 (`getEntry`) - 線形探索でまず動作確認
  - [ ] データ検証ロジック（start/stop/data の存在チェック）
- [ ] `TimeController.js` を実装
  - [ ] コンストラクタ
  - [ ] `activate()` / `deactivate()` メソッド
  - [ ] `_onTick()` の基本構造（変更検知なし、スロットリングなし）
- [ ] ユニットテスト作成
  - [ ] `test/core/temporal/TimeSlicer.test.js`
  - [ ] `test/core/temporal/TimeController.test.js`
  - [ ] 基本的な正常系テスト

**検収基準**:
- `TimeSlicer` が ISO8601 文字列を受け入れ、ソートできる
- `TimeController` が viewer.clock.onTick を監視し、データを取得できる
- テストが全てパスする（カバレッジ不問）

### Phase 2: パフォーマンス最適化（Days 4-5）

**目的**: キャッシュ、二分探索、スロットリングを実装

#### Tasks

- [ ] `TimeSlicer.js` の最適化
  - [ ] 二分探索 (`_binarySearch`) の実装
  - [ ] キャッシュと近傍探索の実装 (`_currentIndex`, `_currentEntry`)
  - [ ] パフォーマンス計測機能 (`getCacheHitRate`)
- [ ] `TimeController.js` のスロットリング実装
  - [ ] `_shouldUpdate()` メソッド
  - [ ] `updateInterval` オプションのサポート ('frame' と number)
  - [ ] データ変更検知 (`_lastEntry` との比較)
- [ ] パフォーマンステスト作成
  - [ ] `test/performance/temporal-performance.test.js`
  - [ ] 1,000エントリーのデータで検索速度を測定
  - [ ] キャッシュヒット率の確認

**検収基準**:
- 24エントリーのデータで連続再生時、99%以上のキャッシュヒット率
- 二分探索が O(log n) で動作することを確認
- スロットリングが正しく機能（updateInterval=100ms で最大10回/秒）

### Phase 3: Classification Scope 統合（Days 6-8）

**目的**: Global/Per-Time スコープを実装し、既存の classification システムと統合

#### Tasks

- [ ] `TimeSlicer.js` の統計量計算
  - [ ] `calculateGlobalStats()` メソッド
  - [ ] `valueProperty` の動的サポート
  - [ ] 分位数・中央値の計算
- [ ] `DataProcessor.js` の拡張
  - [ ] `options._externalStats` の受け入れ
  - [ ] 統計計算スキップロジック
  - [ ] 既存ロジックとの互換性確認
- [ ] `TimeController.js` の統合
  - [ ] Global Scope 時の統計量計算（初期化時）
  - [ ] `_updateHeatbox()` での `_externalStats` 渡し
- [ ] 統合テスト作成
  - [ ] `test/integration/temporal-integration.test.js`
  - [ ] Global Scope: 統計量が固定されることを確認
  - [ ] Per-Time Scope: 統計量が動的に変化することを確認

**検収基準**:
- Global Scope で初期化時に統計計算が1回だけ実行される
- Per-Time Scope で更新ごとに統計計算が実行される
- 既存の classification.scheme ('linear', 'log', 'threshold') が正しく動作

### Phase 4: Edge Case 対応（Days 9-10）

**目的**: エラーハンドリングとエッジケース処理

#### Tasks

- [ ] `TimeSlicer.js` のエッジケース処理
  - [ ] オーバーラップ検証 (`_validateNoOverlap`)
  - [ ] `overlapResolution` オプションの実装
  - [ ] 単一時点データ（start === stop）の処理
  - [ ] 空配列やnull データの処理
- [ ] `TimeController.js` のエッジケース処理
  - [ ] `outOfRangeBehavior` オプションの実装
  - [ ] データが見つからない場合の処理
- [ ] `Heatbox.js` のリソース管理
  - [ ] `destroy()` での `TimeController.deactivate()` 呼び出し
  - [ ] メモリリーク防止の確認
- [ ] エッジケーステスト作成
  - [ ] オーバーラップデータでエラーが出ることを確認
  - [ ] データ範囲外で 'clear' / 'hold' が正しく動作
  - [ ] destroy() 後にリスナーが削除されることを確認

**検収基準**:
- 全てのエッジケースでエラーまたは定義された動作が発生
- メモリリークが発生しない（destroy() 後のリスナー削除を確認）

### Phase 5: ドキュメントとサンプル（Days 11-12）

**目的**: ユーザー向けドキュメントと動作サンプルを作成

#### Tasks

- [ ] API ドキュメント作成
  - [ ] `docs/API.md` に `temporal` オプションを追加
  - [ ] JSDoc コメントの完成度チェック
- [ ] サンプル作成
  - [ ] `examples/temporal/basic-temporal.html` - 基本的な使い方
  - [ ] `examples/temporal/global-vs-per-time.html` - スコープ比較
  - [ ] `examples/temporal/simulation.html` - シミュレーション結果の可視化
  - [ ] `examples/temporal/README.md` - サンプルの説明
- [ ] Wiki 更新
  - [ ] `wiki/Temporal-Data.md` を作成
  - [ ] `wiki/API-Reference.md` に temporal セクションを追加
- [ ] マイグレーションガイド作成
  - [ ] 既存の手動Clock監視コードから temporal オプションへの移行例

**検収基準**:
- サンプルがブラウザで正しく動作
- ドキュメントが明瞭で、3つのユースケースがカバーされている

### Phase 6: テストカバレッジと最終調整（Days 13-14）

**目的**: テストカバレッジを上げ、バグ修正

#### Tasks

- [ ] テストカバレッジ確認
  - [ ] `TimeController.js`: 関数カバレッジ 90%+
  - [ ] `TimeSlicer.js`: 関数カバレッジ 90%+
- [ ] 不足しているテストケースを追加
  - [ ] 複数の `valueProperty` に対する統計計算
  - [ ] Clock の `multiplier` 変更時の挙動
  - [ ] 逆再生時のキャッシュヒット確認
- [ ] パフォーマンスベンチマーク
  - [ ] 10,000点 × 24エントリーのデータで60fps維持を確認
  - [ ] Global Scope 初期化時間が許容範囲内（< 500ms）
- [ ] バグ修正とリファクタリング
  - [ ] Linter エラー修正
  - [ ] TypeScript 型定義の追加 (`types/index.d.ts`)

**検収基準**:
- 全テストがパス
- テストカバレッジが閾値を満たす（branches 65%+, functions 80%+, lines 80%+, statements 80%+）
- サンプルが各ブラウザ（Chrome, Firefox, Safari）で動作

### Phase 7: レビューとリリース準備（Day 15）

#### Tasks

- [ ] コードレビュー
  - [ ] PR を作成し、レビュー依頼
  - [ ] レビューコメントへの対応
- [ ] CI 確認
  - [ ] GitHub Actions が全て緑
  - [ ] Build、Test、Lint、Type-check が成功
- [ ] リリースノート作成
  - [ ] `RELEASE_NOTES.md` に v1.2.0 の内容を追加
  - [ ] Breaking Changes（なし）を明記
  - [ ] 新機能のハイライト
- [ ] バージョン更新
  - [ ] `package.json#version` を `1.2.0-alpha.1` に更新
  - [ ] `src/index.js` の `VERSION` を更新
- [ ] タグ作成とプッシュ
  - [ ] `git tag -a v1.2.0-alpha.1 -m "release: 1.2.0-alpha.1"`
  - [ ] `git push origin v1.2.0-alpha.1`

**検収基準**:
- CI が緑
- npm に正しくパブリッシュされる
- サンプルが公開 URL で動作

## Testing Strategy / テスト戦略

### Unit Tests
- **TimeSlicer**: 正規化、ソート、検索ロジック（キャッシュ/二分探索）、統計量計算の正確性を検証。
- **TimeController**: Clock イベントのハンドリング、スロットリング、ライフサイクル管理を検証。

```javascript
// test/core/temporal/TimeSlicer.test.js
describe('TimeSlicer', () => {
  it('normalizes and sorts entries then caches last hit', () => {
    const slicer = new TimeSlicer([
      { start: '2025-01-15T01:00:00Z', stop: '2025-01-15T02:00:00Z', data: ['later'] },
      { start: '2025-01-15T00:00:00Z', stop: '2025-01-15T01:00:00Z', data: ['earlier'] }
    ]);
    const t1 = Cesium.JulianDate.fromIso8601('2025-01-15T00:30:00Z');
    const t2 = Cesium.JulianDate.fromIso8601('2025-01-15T01:30:00Z');
    expect(slicer.getEntry(t1).data).toEqual(['earlier']);
    expect(slicer.getEntry(t2).data).toEqual(['later']);
    // キャッシュヒット: 同じ時刻で O(1)
    expect(slicer.getEntry(t2)).toBe(slicer.getEntry(t2));
  });

  it('calculates global stats once per property', () => {
    const slicer = new TimeSlicer([
      { start: '2025-01-15T00:00:00Z', stop: '2025-01-15T01:00:00Z', data: [{ weight: 1 }] },
      { start: '2025-01-15T01:00:00Z', stop: '2025-01-15T02:00:00Z', data: [{ weight: 3 }] }
    ]);
    const stats = slicer.calculateGlobalStats('weight');
    expect(stats.min).toBe(1);
    expect(stats.max).toBe(3);
    // 2回目はキャッシュを返す
    expect(slicer.calculateGlobalStats('weight')).toBe(stats);
  });
});

// test/core/temporal/TimeController.test.js
describe('TimeController', () => {
  it('throttles updates by updateInterval', () => {
    const viewer = createMockViewer();
    const heatbox = createMockHeatbox();
    const controller = new TimeController(viewer, heatbox, {
      data: [{ start: '2025-01-15T00:00:00Z', stop: '2025-01-15T01:00:00Z', data: ['A'] }],
      updateInterval: 100
    });
    controller.activate();
    viewer.clock.onTick.trigger(); // 1回目
    viewer.clock.onTick.trigger(); // スロットリングで無視
    expect(heatbox.setData).toHaveBeenCalledTimes(1);
  });

  it('clears when out of range if outOfRangeBehavior=clear', () => {
    const viewer = createMockViewer();
    const heatbox = createMockHeatbox();
    const controller = new TimeController(viewer, heatbox, {
      data: [{ start: '2025-01-15T00:00:00Z', stop: '2025-01-15T01:00:00Z', data: ['A'] }],
      outOfRangeBehavior: 'clear'
    });
    controller.activate();
    viewer.clock.currentTime = Cesium.JulianDate.fromIso8601('2025-01-15T10:00:00Z');
    viewer.clock.onTick.trigger();
    expect(heatbox.clear).toHaveBeenCalled();
  });
});
```

### Integration Tests
- **End-to-End**: Viewer, Clock, Heatbox を組み合わせ、時間経過とともにボクセルが更新されることを確認。
- **Scope**: Global Scope で色が固定され、Per-Time Scope で変動することを確認。

```javascript
// test/integration/temporal-integration.test.js
it('syncs Cesium clock with Heatbox (global scope)', () => {
  const viewer = new Cesium.Viewer('c');
  const data = [
    { start: '2025-01-15T00:00:00Z', stop: '2025-01-15T01:00:00Z', data: generateData(100) },
    { start: '2025-01-15T01:00:00Z', stop: '2025-01-15T02:00:00Z', data: generateData(200) }
  ];
  const heatbox = new Heatbox(viewer, {
    temporal: { enabled: true, data, classificationScope: 'global', updateInterval: 50 },
    classification: { scheme: 'linear', colorMap: ['blue', 'red'] }
  });

  viewer.clock.currentTime = Cesium.JulianDate.fromIso8601('2025-01-15T00:30:00Z');
  viewer.clock.tick();
  expect(heatbox._voxelGrid.entities.length).toBe(100);

  viewer.clock.currentTime = Cesium.JulianDate.fromIso8601('2025-01-15T01:30:00Z');
  viewer.clock.tick();
  expect(heatbox._voxelGrid.entities.length).toBe(200);
});
```

### Performance Tests
- **Benchmark**: 10,000点 × 24時間のデータで 60fps を維持できるか確認。
- **Initialization**: Global Scope の初期化が許容時間内（<500ms）で完了するか確認。

```javascript
// test/performance/temporal-performance.test.js
it('keeps cache hit rate >= 0.99 during continuous playback', () => {
  const data = Array.from({ length: 24 }, (_, i) => ({
    start: `2025-01-15T${String(i).padStart(2, '0')}:00:00Z`,
    stop: `2025-01-15T${String(i + 1).padStart(2, '0')}:00:00Z`,
    data: generateData(1000)
  }));
  const slicer = new TimeSlicer(data);
  for (let i = 0; i < 24; i++) {
    const t = Cesium.JulianDate.fromIso8601(`2025-01-15T${String(i).padStart(2, '0')}:30:00Z`);
    slicer.getEntry(t);
    slicer.getEntry(t); // キャッシュヒット
  }
  expect(slicer.getCacheHitRate()).toBeGreaterThan(0.99);
});

it('calculates global stats within 500ms for 240k points', () => {
  const data = Array.from({ length: 24 }, () => ({
    start: '2025-01-15T00:00:00Z',
    stop: '2025-01-15T01:00:00Z',
    data: generateData(10000) // 24 × 10,000 = 240,000
  }));
  const slicer = new TimeSlicer(data);
  const start = performance.now();
  slicer.calculateGlobalStats('weight');
  expect(performance.now() - start).toBeLessThan(500);
});
```

### Coverage Targets

| Module | Branches | Functions | Lines | Statements |
|--------|----------|-----------|-------|------------|
| TimeController | 80% | 90% | 85% | 85% |
| TimeSlicer | 85% | 95% | 90% | 90% |
| Integration | 70% | 85% | 80% | 80% |
| **Overall** | **65%+** | **80%+** | **80%+** | **80%+** |

## Migration Guide / 移行ガイド

v1.2.0 で導入される `temporal` オプションは新機能であり、既存の静的マップに対する破壊的変更はありません。

### 手動実装からの移行

これまで `viewer.clock.onTick` を使って手動で時系列データを実装していた場合は、`temporal` オプションへの移行を推奨します。

#### Before (v1.1.x)

```javascript
const dataFrames = [...]; // 時系列データ
viewer.clock.onTick.addEventListener((clock) => {
  const time = clock.currentTime;
  const frame = findFrameManually(dataFrames, time); // 手動検索
  heatbox.setData(frame.data); // 毎フレーム setData（重い）
});
```

#### After (v1.2.0)

```javascript
const heatbox = new Heatbox(viewer, {
  temporal: {
    enabled: true,
    data: [
      { start: '2025-01-15T00:00:00Z', stop: '2025-01-15T01:00:00Z', data: [...] },
      { start: '2025-01-15T01:00:00Z', stop: '2025-01-15T02:00:00Z', data: [...] }
    ],
    updateInterval: 100,
    classificationScope: 'global'
  },
  classification: {
    scheme: 'linear',
    colorMap: ['blue', 'red']
  }
});
```

## Alternatives Considered / 検討した代替案

### Alternative 1: CZML TimeIntervalCollection の直接利用

**アプローチ**: Cesium の CZML `TimeIntervalCollection` を内部で使い、各ボクセルを `Entity` として管理し、`availability` プロパティで時間範囲を制御する。

**利点**:
- Cesium ネイティブの時間管理機構を利用でき、追加実装が少ない
- 各ボクセルが独立して時間範囲を持てる（ボクセルごとに異なる時刻範囲も可能）

**欠点**:
- **パフォーマンス**: 数千個のボクセル × 数十の時間範囲 = 数万の `Entity` が必要で、メモリとレンダリングコストが膨大
- **API の複雑化**: ユーザーが CZML 形式でデータを提供する必要があり、学習コストが高い
- **柔軟性の欠如**: Global/Per-Time スコープのような統計ベースの制御が困難

**却下理由**: パフォーマンスとAPI設計の観点から、ボクセル単位の時間管理は不適切。データ全体を時刻ごとに切り替える方が効率的。

### Alternative 2: WebWorker での統計計算

**アプローチ**: Global 統計量の計算を WebWorker で行い、メインスレッドをブロックしないようにする。

**利点**:
- 初期化時の応答性が向上（UI が固まらない）
- 大規模データセット（数百万点）でも影響が少ない

**欠点**:
- **複雑性**: WebWorker のセットアップ、データ転送、エラーハンドリングが必要
- **オーバーヘッド**: 小規模データ（数万点）では Worker 生成コストの方が大きい可能性
- **デバッグ困難**: Worker 内のエラーが追跡しにくい

**将来的な採用**: v1.2.0 では見送り、v1.3.0 以降でオプション機能として検討。`temporal.useWorker: true` のような設定で有効化。

### Alternative 3: 3D Tiles への統合

**アプローチ**: 時系列データを 3D Tiles フォーマット（複数の Tileset、または時間依存プロパティ）として提供し、Cesium の標準機能で描画する。

**利点**:
- **スケーラビリティ**: サーバーサイドで大規模データを管理でき、クライアントはストリーミング取得
- **標準化**: Cesium の既存機能と完全に統合される
- **LOD**: 距離に応じた詳細度切り替えが自動

**欠点**:
- **サーバー要件**: 3D Tiles サーバーのセットアップが必要（ユーザー負担大）
- **リアルタイム性の欠如**: 事前生成されたタイルのみ対応、動的データ更新が困難
- **Heatbox の特性喪失**: ボクセル集約や動的 Classification の利点が失われる

**採用パス**: v1.2.0 はクライアント側での時系列データ管理に焦点を当て、v2.0 で 3D Tiles オプションを追加検討（`temporal.source: '3d-tiles'`）。

### Alternative 4: setData() の軽量化（統計計算のみ更新）

**アプローチ**: 新しい `updateData()` メソッドを追加し、ボクセルグリッドの再構築をスキップして統計量とエンティティ属性のみ更新する。

**利点**:
- `setData()` の重い処理（_buildIndex, _calculateBounds）を回避
- 更新コストが大幅に削減（80ms → 5ms 程度）

**欠点**:
- **API 分裂**: `setData()` と `updateData()` の使い分けをユーザーが理解する必要
- **制限**: ボクセルの空間構造が変わらない場合のみ有効（データ点数や分布が大きく変わると不適切）
- **保守コスト**: 2つの更新パスを管理する必要

**部分採用**: v1.2.0 では内部実装として `options._skipRebuild` を導入するが、公開APIとしては提供しない。v1.3.0 で `heatbox.updateValues(data)` として検討。

## Consequences / 影響

### Positive / ポジティブな影響

1. **開発者エクスペリエンスの向上**:
   - Clock 監視ロジックが不要になり、コード量が50-100行削減
   - Cesium のタイムラインUIと自然に統合され、学習コストが低い
   - サンプルコードが短くなり、理解しやすくなる

2. **パフォーマンスの大幅改善**:
   - Global Scope 使用時、統計計算コストがゼロに（初期化時1回のみ）
   - キャッシュと二分探索により、データ検索が O(n) → O(log n) → O(1) に
   - 変更検知により、不要な再描画をスキップ
   - 結果: 10,000点のデータで60fps以上を維持（従来は10fps程度）

3. **新しいユースケースの開拓**:
   - シミュレーション結果の可視化（災害拡散、交通流）
   - CZML との統合（移動体の軌跡密度）
   - GIS データの時間変化分析（人口動態、気象データ）

4. **API の一貫性**:
   - `classification` システムとの統合により、既存の知識が再利用可能
   - 時系列データも静的データと同じ `colorMap`, `scheme` を使用

5. **将来拡張への道筋**:
   - 補間（v1.3.0）
   - 遅延ロード（v1.3.0）
   - 3D Tiles 統合（v2.0）
   - リアルタイムストリーミング（v2.x）

### Negative / ネガティブな影響

1. **初期化時のオーバーヘッド（Global Scope）**:
   - 全データを走査するため、大規模データ（数百万点）では初期化に数秒かかる可能性
   - **緩和策**: v1.2.0 ではドキュメントで推奨データサイズを明記（< 100万点）。将来的に WebWorker やストリーミングロードで対応。

2. **メモリ使用量の増加**:
   - 時系列データを全てメモリに保持するため、ブラウザのメモリ制限に注意が必要
   - 例: 24時間 × 10,000点 × 50byte/点 = 約12MB（許容範囲）
   - **緩和策**: ドキュメントでメモリ見積もり式を提供。大規模データは 3D Tiles を推奨（v2.0）。

3. **API 複雑性の増加**:
   - `temporal` オプションが追加され、学習すべき概念が増える
   - Global vs Per-Time の選択が分かりにくい可能性
   - **緩和策**: 詳細なドキュメント、インタラクティブなサンプル、デフォルト設定の最適化（`global` をデフォルト）。

4. **破壊的変更のリスク（将来）**:
   - v1.2.0 は PoC であり、v1.3.0 で API が変更される可能性
   - 例: `interpolate` オプションが追加されると、既存の挙動が変わる可能性
   - **緩和策**: セマンティックバージョニングを厳守。Breaking Changes は必ずメジャーバージョンアップ。

5. **テスト負荷の増加**:
   - 時系列データの組み合わせテストが必要（データ形式 × スコープ × エッジケース）
   - CI 実行時間が延びる可能性
   - **緩和策**: パフォーマンステストは manual 実行、ユニットテストは最小限に絞る。

### Risks & Mitigations / リスクと緩和策

| リスク | 影響度 | 発生確率 | 緩和策 |
|--------|-------|---------|-------|
| 大規模データでの初期化遅延 | 高 | 中 | ドキュメントで推奨サイズを明記。将来 WebWorker 対応 |
| メモリ不足 | 中 | 低 | メモリ見積もり式を提供。3D Tiles への移行パス明示 |
| API 変更による互換性問題 | 中 | 中 | SemVer 厳守。Deprecation 警告を早期に出す |
| Per-Time Scope のパフォーマンス低下 | 中 | 高 | ドキュメントで `updateInterval` の推奨値を提示（200-500ms） |
| データの隙間によるちらつき | 低 | 中 | デフォルトで 'hold' 挙動。将来 `interpolate` で解決 |
| Clock 同期ズレ | 低 | 低 | 実用上許容。厳密な同期が必要なら `scene.preUpdate` を強化 |

### Alternative Summary vs Risks / 代替案とリスク対応の対応表

| 代替案 | 主なリスク | 対応策 |
|--------|-----------|--------|
| CZML TimeIntervalCollection | エンティティ爆発による性能劣化 | 採用せず。TimeSlicer で時刻ごとに一括切替 |
| WebWorker 統計計算 | 実装複雑化・転送オーバーヘッド | v1.2.0では見送り。大規模データ時のみ将来オプション化 |
| 3D Tiles 統合 | サーバー要件・リアルタイム性欠如 | v2.0で別系統として検討。現行はクライアント内完結を維持 |
| setData 軽量化 API | API分裂・制約の誤用 | 内部オプションに留め、v1.3.0で `updateValues` を検討 |

## Acceptance Criteria / 受け入れ基準（詳細版）

### 1. Functional / 機能要件

- [ ] **時刻形式サポート**: ISO8601、Date、Unix timestamp、JulianDate を受理し、`start` ソート済みの `TimeSlicer._entries` が生成されることをユニットテストで確認。
- [ ] **Clock 連動**: `viewer.clock` の再生/停止/シーク/倍率変更に追従し、10,000点データで 30fps 以上を維持（Integration Test で確認）。
- [ ] **Classification Scope**: Global では初期化時1回の統計計算で固定され、Per-Time では時刻ごとに再計算されることを統合テストで検証。
- [ ] **Edge Cases**: 範囲外で `clear/hold` が設定通り動作、隙間/オーバーラップが `overlapResolution` に従うことをユニットテストで確認。

### 2. Non-Functional / 非機能要件

- [ ] **初期化時間**: 240,000点データの Global Scope 初期化が 500ms 未満（Performance Test）。
- [ ] **更新時間**: Global 更新 50ms 未満、Per-Time 100ms 未満（Benchmark）。
- [ ] **フレームレート**: `updateInterval=100` で 60fps を維持（E2E ベンチ）。
- [ ] **キャッシュヒット率**: 24エントリー連続再生で 0.99 以上（Performance Test）。
- [ ] **互換性**: 既存静的モードが破壊的影響を受けない（回帰テストで確認）。

### 3. Code Quality / コード品質

- [ ] **カバレッジ**: Overall 65/80/80/80 以上、TimeController 関数 90% 以上、TimeSlicer 関数 95% 以上。
- [ ] **Lint/Type-check**: `npm run -s lint` / `npm run -s type-check` が成功。
- [ ] **JSDoc**: 公開メソッドに JSDoc が揃い、生成ドキュメントに temporal オプションが反映。

### 4. Documentation / ドキュメント

- [ ] **API**: `docs/API.md` に `temporal`、`classificationScope`、`updateInterval`、`outOfRangeBehavior` を追加。
- [ ] **サンプル**: `examples/temporal/*` 3本が動作し、README に手順がある。
- [ ] **Wiki/移行**: `wiki/Temporal-Data.md` と `MIGRATION.md` に手動実装からの移行手順を記載。

## Future Work / 今後の作業

- **v1.3.0**: データの補間 (Interpolation) と遅延ロード (Lazy Loading)。
- **v2.0**: 3D Tiles 統合による大規模データ対応。

## References / 参照

### Internal Documents

- ROADMAP v1.2.0, ADR-0016 (Classification Engine), ADR-0017 (Classification Extension), ADR-0014 (Layer Aggregation)

### Cesium Documentation

- [Cesium Clock API](https://cesium.com/learn/cesiumjs/ref-doc/Clock.html)
- [JulianDate API](https://cesium.com/learn/cesiumjs/ref-doc/JulianDate.html)
- [CZML Time Dynamic Data](https://github.com/AnalyticalGraphicsInc/czml-writer/wiki/CZML-Guide)
- [3D Tiles Specification](https://docs.ogc.org/cs/22-025r4/22-025r4.html)

### External Resources

- GeoJSON-T Specification, OGC Moving Features, D3.js Time Scales, Kepler.gl Time Playback

### Related Work

- deck.gl TripsLayer, Mapbox Studio Temporal Data, Leaflet.TimeDimension, Cesium Time Series Examples

---

**Last Updated**: 2025-11-19  
**Status**: Approved  
**Next Steps**: Phase 1 実装開始（TimeController / TimeSlicer の基盤実装）
