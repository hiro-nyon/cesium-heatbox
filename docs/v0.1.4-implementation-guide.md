# v0.1.4 ボクセルサイズ自動決定機能 - 実装ガイド

## 実装箇所一覧

### 1. src/utils/constants.js
**追加**: DEFAULT_OPTIONSに`autoVoxelSize: false`を追加

```javascript
export const DEFAULT_OPTIONS = {
  // 既存オプション...
  autoVoxelSize: false,  // v0.1.4: 自動ボクセルサイズ決定（既存互換性のためfalse）
  // 既存オプション続き...
};
```

### 2. src/utils/validation.js  
**追加**: 自動調整用の新しいユーティリティ関数

```javascript
/**
 * データ範囲に基づいて初期ボクセルサイズを推定
 * @param {Object} bounds - 境界情報
 * @param {number} entityCount - エンティティ数
 * @returns {number} 推定ボクセルサイズ（メートル）
 */
export function estimateInitialVoxelSize(bounds, entityCount) {
  // TODO: 実装
  // 1. データ範囲（X/Y/Z軸の物理的範囲）を計算
  const dataRange = calculateDataRange(bounds);
  
  // 2. エンティティ密度を推定
  const volume = dataRange.x * dataRange.y * dataRange.z;
  const density = entityCount / volume;
  
  // 3. 密度に応じて適切なボクセルサイズを推定
  // - 高密度: 細かいサイズ
  // - 低密度: 粗いサイズ
  // - 基本は20m、密度に応じて10m-100m範囲で調整
  
  return estimatedSize;
}

/**
 * 境界からデータ範囲を計算
 * @param {Object} bounds - 境界情報
 * @returns {Object} データ範囲 {x, y, z}（メートル）
 */
export function calculateDataRange(bounds) {
  // TODO: 実装
  // 緯度経度をメートルに変換（簡易変換）
  const centerLat = (bounds.minLat + bounds.maxLat) / 2;
  const lonRangeMeters = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);
  const latRangeMeters = (bounds.maxLat - bounds.minLat) * 111000;
  const altRangeMeters = bounds.maxAlt - bounds.minAlt;
  
  return {
    x: lonRangeMeters,
    y: latRangeMeters, 
    z: altRangeMeters
  };
}
```

### 3. src/Heatbox.js
**修正**: setData()メソッドで自動調整ロジックを実行（描画は各軸の実セルサイズ `cellSizeX/Y/Z` を使用）

```javascript
setData(entities) {
  if (!isValidEntities(entities)) {
    this.clear();
    return;
  }
  
  try {
    Logger.debug('Heatbox.setData - 処理開始:', entities.length, '個のエンティティ');
    
    // 1. 境界計算
    Logger.debug('Step 1: 境界計算');
    this._bounds = CoordinateTransformer.calculateBounds(entities);
    if (!this._bounds) {
      Logger.error('境界計算に失敗');
      this.clear();
      return;
    }
    Logger.debug('境界計算完了:', this._bounds);

    // v0.1.4: 自動ボクセルサイズ調整
    let finalVoxelSize = this.options.voxelSize || DEFAULT_OPTIONS.voxelSize;
    let autoAdjustmentInfo = null;
    
    if (this.options.autoVoxelSize && !this.options.voxelSize) {
      // TODO: 自動調整実装
      const estimatedSize = estimateInitialVoxelSize(this._bounds, entities.length);
      const tempGrid = VoxelGrid.createGrid(this._bounds, estimatedSize);
      const validation = validateVoxelCount(tempGrid.totalVoxels, estimatedSize);
      
      if (!validation.valid && validation.recommendedSize) {
        finalVoxelSize = validation.recommendedSize;
        autoAdjustmentInfo = {
          enabled: true,
          originalSize: estimatedSize,
          finalSize: finalVoxelSize,
          adjusted: true,
          reason: `Performance limit exceeded: ${tempGrid.totalVoxels} > ${PERFORMANCE_LIMITS.maxVoxels}`
        };
        Logger.info(`Auto-adjusted voxelSize: ${estimatedSize}m → ${finalVoxelSize}m`);
      } else {
        finalVoxelSize = estimatedSize;
        autoAdjustmentInfo = {
          enabled: true,
          originalSize: estimatedSize,
          finalSize: finalVoxelSize,
          adjusted: false,
          reason: null
        };
        Logger.info(`Auto-determined voxelSize: ${finalVoxelSize}m`);
      }
    }

    // 2. グリッド生成（最終的なボクセルサイズを使用）
    Logger.debug('Step 2: グリッド生成 (サイズ:', finalVoxelSize, 'm)');
    this._grid = VoxelGrid.createGrid(this._bounds, finalVoxelSize);
    Logger.debug('グリッド生成完了:', this._grid);
    
    // 3-5. 既存処理続行...
    
    // 統計情報に自動調整情報を追加
    if (autoAdjustmentInfo) {
      this._statistics.autoAdjusted = autoAdjustmentInfo.adjusted;
      this._statistics.originalVoxelSize = autoAdjustmentInfo.originalSize;
      this._statistics.finalVoxelSize = autoAdjustmentInfo.finalSize;
      this._statistics.adjustmentReason = autoAdjustmentInfo.reason;
    }
    
  } catch (error) {
    Logger.error('ヒートマップ作成エラー:', error);
    this.clear();
    throw error;
  }
}

/**
 * デバッグ情報を取得
 * @returns {Object} デバッグ情報
 */
getDebugInfo() {
  const baseInfo = {
    options: { ...this.options },
    bounds: this._bounds,
    grid: this._grid,
    statistics: this._statistics
  };
  
  // v0.1.4: 自動調整情報を追加
  if (this.options.autoVoxelSize) {
    baseInfo.autoVoxelSizeInfo = {
      enabled: this.options.autoVoxelSize,
      originalSize: this._statistics?.originalVoxelSize,
      finalSize: this._statistics?.finalVoxelSize,
      adjusted: this._statistics?.autoAdjusted || false,
      reason: this._statistics?.adjustmentReason,
      dataRange: this._bounds ? calculateDataRange(this._bounds) : null,
      estimatedDensity: this._bounds && this._statistics ? 
        this._statistics.totalEntities / (calculateDataRange(this._bounds).x * calculateDataRange(this._bounds).y * calculateDataRange(this._bounds).z) : null
    };
  }
  
  return baseInfo;
}
```

### 4. src/core/DataProcessor.js
**修正**: calculateStatistics()で新しい統計フィールドを初期化

```javascript
static calculateStatistics(voxelData, grid) {
  if (voxelData.size === 0) {
    return {
      totalVoxels: grid.totalVoxels,
      renderedVoxels: 0,
      nonEmptyVoxels: 0,
      emptyVoxels: grid.totalVoxels,
      totalEntities: 0,
      minCount: 0,
      maxCount: 0,
      averageCount: 0,
      // v0.1.4: 自動調整情報の初期化
      autoAdjusted: false,
      originalVoxelSize: null,
      finalVoxelSize: null,
      adjustmentReason: null
    };
  }
  
  const counts = Array.from(voxelData.values()).map(voxel => voxel.count);
  const totalEntities = counts.reduce((sum, count) => sum + count, 0);
  
  const stats = {
    totalVoxels: grid.totalVoxels,
    renderedVoxels: 0, // 実際の描画後にVoxelRendererから設定される
    nonEmptyVoxels: voxelData.size,
    emptyVoxels: grid.totalVoxels - voxelData.size,
    totalEntities: totalEntities,
    minCount: Math.min(...counts),
    maxCount: Math.max(...counts),
    averageCount: totalEntities / voxelData.size,
    // v0.1.4: 自動調整情報の初期化
    autoAdjusted: false,
    originalVoxelSize: null,
    finalVoxelSize: null,
    adjustmentReason: null
  };
  
  Logger.debug('統計情報計算完了:', stats);
  return stats;
}
```

## 実装手順

### Phase 1: コア機能
1. **constants.js**: `autoVoxelSize: false` を DEFAULT_OPTIONS に追加
2. **validation.js**: `estimateInitialVoxelSize()` と `calculateDataRange()` を実装
3. **Heatbox.js**: `setData()` で自動調整ロジック実装
4. **DataProcessor.js**: 統計情報の初期化を更新

### Phase 2: 統合テスト
1. 基本例で自動調整をテスト
2. 大量データでの調整動作確認
3. 手動指定との優先度確認

### Phase 3: ドキュメント同期
1. JSDoc HTMLの再生成
2. 型定義の最終チェック

## エラーハンドリング

### フォールバック戦略
```javascript
// 自動調整失敗時のフォールバック
try {
  finalVoxelSize = estimateInitialVoxelSize(bounds, entities.length);
} catch (error) {
  Logger.warn('Auto voxel size estimation failed, using default:', error);
  finalVoxelSize = DEFAULT_OPTIONS.voxelSize;
  autoAdjustmentInfo = {
    enabled: true,
    adjusted: false,
    reason: 'Estimation failed, using default size'
  };
}
```

## テスト観点

### 正常系
- 小規模データ (100 entities) で細かいサイズ
- 大規模データ (50000 entities) でパフォーマンス制限内での粗いサイズ
- 手動指定時の自動調整無効確認

### 異常系  
- エンティティ数0での処理
- 境界計算失敗時のフォールバック
- 推奨サイズ計算エラー時の処理
