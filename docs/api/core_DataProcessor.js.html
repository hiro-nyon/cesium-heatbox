<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/DataProcessor.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/DataProcessor.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * データ処理を担当するクラス
 */
import { CoordinateTransformer } from './CoordinateTransformer.js';
import { VoxelGrid } from './VoxelGrid.js';
import { hasValidPosition } from '../utils/validation.js';

/**
 * エンティティデータの処理を担当するクラス
 */
export class DataProcessor {
  /**
   * エンティティをボクセルに分類
   * @param {Array} entities - エンティティ配列
   * @param {Object} bounds - 境界情報
   * @param {Object} grid - グリッド情報
   * @returns {Map} ボクセルデータ（キー: ボクセルキー, 値: ボクセル情報）
   */
  static classifyEntitiesIntoVoxels(entities, bounds, grid) {
    const voxelData = new Map();
    let processedCount = 0;
    
    for (const entity of entities) {
      if (!hasValidPosition(entity)) {
        continue;
      }
      
      const position = CoordinateTransformer.getEntityPosition(entity);
      if (!position) {
        continue;
      }
      
      try {
        const voxelIndex = CoordinateTransformer.cartesianToVoxelIndex(position, bounds, grid);
        
        // 範囲チェック
        if (voxelIndex.x >= 0 &amp;&amp; voxelIndex.x &lt; grid.numVoxelsX &amp;&amp;
            voxelIndex.y >= 0 &amp;&amp; voxelIndex.y &lt; grid.numVoxelsY &amp;&amp;
            voxelIndex.z >= 0 &amp;&amp; voxelIndex.z &lt; grid.numVoxelsZ) {
            
            const voxelKey = VoxelGrid.getVoxelKey(voxelIndex.x, voxelIndex.y, voxelIndex.z);
            
            if (!voxelData.has(voxelKey)) {
              voxelData.set(voxelKey, {
                x: voxelIndex.x,
                y: voxelIndex.y,
                z: voxelIndex.z,
                entities: [],
                count: 0
              });
            }
            
            const voxelInfo = voxelData.get(voxelKey);
            voxelInfo.entities.push(entity);
            voxelInfo.count++;
            
            processedCount++;
        }
      } catch (error) {
        console.warn('エンティティの処理に失敗:', error);
      }
    }
    
    console.log(`${processedCount}個のエンティティを${voxelData.size}個のボクセルに分類`);
    return voxelData;
  }
  
  /**
   * ボクセルデータから統計情報を計算
   * @param {Map} voxelData - ボクセルデータ
   * @param {Object} grid - グリッド情報
   * @returns {Object} 統計情報
   */
  static calculateStatistics(voxelData, grid) {
    const counts = Array.from(voxelData.values()).map(voxel => voxel.count);
    const totalEntities = counts.reduce((sum, count) => sum + count, 0);
    
    return {
      totalVoxels: grid.totalVoxels,
      nonEmptyVoxels: voxelData.size,
      emptyVoxels: grid.totalVoxels - voxelData.size,
      totalEntities: totalEntities,
      minCount: counts.length > 0 ? Math.min(...counts) : 0,
      maxCount: counts.length > 0 ? Math.max(...counts) : 0,
      averageCount: voxelData.size > 0 ? totalEntities / voxelData.size : 0
    };
  }
  
  /**
   * ボクセルデータをフィルタリング
   * @param {Map} voxelData - ボクセルデータ
   * @param {Function} filterFunc - フィルタ関数
   * @returns {Map} フィルタリングされたボクセルデータ
   */
  static filterVoxelData(voxelData, filterFunc) {
    const filteredData = new Map();
    
    for (const [key, voxelInfo] of voxelData.entries()) {
      if (filterFunc(voxelInfo)) {
        filteredData.set(key, voxelInfo);
      }
    }
    
    return filteredData;
  }
  
  /**
   * 密度に基づいてボクセルデータをソート
   * @param {Map} voxelData - ボクセルデータ
   * @param {boolean} ascending - 昇順の場合はtrue
   * @returns {Array} ソートされたボクセル情報配列
   */
  static sortVoxelsByDensity(voxelData, ascending = false) {
    const voxels = Array.from(voxelData.values());
    
    return voxels.sort((a, b) => {
      return ascending ? a.count - b.count : b.count - a.count;
    });
  }
  
  /**
   * 上位N個のボクセルを取得
   * @param {Map} voxelData - ボクセルデータ
   * @param {number} topN - 取得する上位の数
   * @returns {Array} 上位N個のボクセル情報
   */
  static getTopNVoxels(voxelData, topN) {
    const sortedVoxels = this.sortVoxelsByDensity(voxelData, false);
    return sortedVoxels.slice(0, topN);
  }
  
  /**
   * 統計情報の詳細レポートを生成
   * @param {Object} statistics - 統計情報
   * @param {Map} voxelData - ボクセルデータ
   * @returns {Object} 詳細レポート
   */
  static generateDetailedReport(statistics, voxelData) {
    const densityDistribution = {};
    
    // 密度分布を計算
    for (const voxelInfo of voxelData.values()) {
      const count = voxelInfo.count;
      densityDistribution[count] = (densityDistribution[count] || 0) + 1;
    }
    
    // 密度の分位数を計算
    const sortedCounts = Array.from(voxelData.values())
      .map(v => v.count)
      .sort((a, b) => a - b);
    
    const getPercentile = (arr, percentile) => {
      const index = Math.floor(arr.length * percentile / 100);
      return arr[index] || 0;
    };
    
    return {
      ...statistics,
      densityDistribution,
      percentiles: {
        p25: getPercentile(sortedCounts, 25),
        p50: getPercentile(sortedCounts, 50),
        p75: getPercentile(sortedCounts, 75),
        p90: getPercentile(sortedCounts, 90),
        p95: getPercentile(sortedCounts, 95)
      }
    };
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CoordinateTransformer.html">CoordinateTransformer</a></li><li><a href="DataProcessor.html">DataProcessor</a></li><li><a href="Heatbox.html">Heatbox</a></li><li><a href="VoxelGrid.html">VoxelGrid</a></li><li><a href="VoxelRenderer.html">VoxelRenderer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#COLOR_CONSTANTS">COLOR_CONSTANTS</a></li><li><a href="global.html#COORDINATE_CONSTANTS">COORDINATE_CONSTANTS</a></li><li><a href="global.html#DEFAULT_OPTIONS">DEFAULT_OPTIONS</a></li><li><a href="global.html#DEFAULT_STATISTICS">DEFAULT_STATISTICS</a></li><li><a href="global.html#ERROR_MESSAGES">ERROR_MESSAGES</a></li><li><a href="global.html#PERFORMANCE_LIMITS">PERFORMANCE_LIMITS</a></li><li><a href="global.html#VERSION">VERSION</a></li><li><a href="global.html#createBoundsFromCenter">createBoundsFromCenter</a></li><li><a href="global.html#createHeatbox">createHeatbox</a></li><li><a href="global.html#generateTestEntities">generateTestEntities</a></li><li><a href="global.html#getAllEntities">getAllEntities</a></li><li><a href="global.html#getEnvironmentInfo">getEnvironmentInfo</a></li><li><a href="global.html#getTokyoStationBounds">getTokyoStationBounds</a></li><li><a href="global.html#hasValidPosition">hasValidPosition</a></li><li><a href="global.html#isValidEntities">isValidEntities</a></li><li><a href="global.html#isValidViewer">isValidViewer</a></li><li><a href="global.html#isValidVoxelSize">isValidVoxelSize</a></li><li><a href="global.html#validateAndNormalizeOptions">validateAndNormalizeOptions</a></li><li><a href="global.html#validateVoxelCount">validateVoxelCount</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Aug 19 2025 21:48:32 GMT+0900 (日本標準時)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
