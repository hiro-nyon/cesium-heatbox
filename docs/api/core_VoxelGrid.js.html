<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/VoxelGrid.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/VoxelGrid.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * ボクセルグリッドを管理するクラス（シンプル実装）
 */
import { Logger } from '../utils/logger.js';

/**
 * 3Dボクセルグリッドを管理するクラス
 */
export class VoxelGrid {
  /**
   * 境界情報とボクセルサイズからグリッドを作成（シンプル版）
   * @param {Object} bounds - 境界情報
   * @param {number} voxelSizeMeters - 目標ボクセルサイズ（メートル）。実セルサイズは各軸で範囲/分割数。
   * @returns {Object} グリッド情報 { numVoxelsX, numVoxelsY, numVoxelsZ, totalVoxels, voxelSizeMeters, cellSizeX, cellSizeY, cellSizeZ, lonRangeMeters, latRangeMeters, altRangeMeters }
   */
  static createGrid(bounds, voxelSizeMeters) {
    // 緯度・経度をメートルに概算変換（シンプルな公式）
    const centerLat = (bounds.minLat + bounds.maxLat) / 2;
    const lonRangeMeters = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);
    const latRangeMeters = (bounds.maxLat - bounds.minLat) * 111000;
    const altRangeMeters = bounds.maxAlt - bounds.minAlt;
    
    // 各軸のボクセル数を計算
    const numVoxelsX = Math.max(1, Math.ceil(lonRangeMeters / voxelSizeMeters));
    const numVoxelsY = Math.max(1, Math.ceil(latRangeMeters / voxelSizeMeters));
    const numVoxelsZ = Math.max(1, Math.ceil(altRangeMeters / voxelSizeMeters));

    // 実際の各軸セルサイズ（メートル）
    // ceil により分割数が増える場合があるため、実セルサイズは指定サイズ以下になる。
    const cellSizeX = numVoxelsX > 0 ? (lonRangeMeters / numVoxelsX) : voxelSizeMeters;
    const cellSizeY = numVoxelsY > 0 ? (latRangeMeters / numVoxelsY) : voxelSizeMeters;
    // 高度差が極小の場合に0にならないよう最低1mを確保
    const cellSizeZ = numVoxelsZ > 0 ? Math.max(altRangeMeters / numVoxelsZ, 1) : Math.max(voxelSizeMeters, 1);
    
    const totalVoxels = numVoxelsX * numVoxelsY * numVoxelsZ;
    
    Logger.debug('VoxelGrid created:', {
      numVoxelsX,
      numVoxelsY,
      numVoxelsZ,
      totalVoxels,
      voxelSizeMeters,
      cellSizeX,
      cellSizeY,
      cellSizeZ,
      lonRangeMeters,
      latRangeMeters,
      altRangeMeters
    });
    
    return {
      numVoxelsX,
      numVoxelsY,
      numVoxelsZ,
      totalVoxels,
      voxelSizeMeters,
      cellSizeX,
      cellSizeY,
      cellSizeZ,
      lonRangeMeters,
      latRangeMeters,
      altRangeMeters
    };
  }
  
  /**
   * ボクセルインデックスからキーを生成
   * @param {number} x - X軸インデックス
   * @param {number} y - Y軸インデックス
   * @param {number} z - Z軸インデックス
   * @returns {string} ボクセルキー
   */
  static getVoxelKey(x, y, z) {
    return `${x},${y},${z}`;
  }
  
  /**
   * ボクセルキーからインデックスを解析
   * @param {string} key - ボクセルキー
   * @returns {Object} インデックス {x, y, z}
   */
  static parseVoxelKey(key) {
    const [x, y, z] = key.split(',').map(Number);
    return { x, y, z };
  }
  
  /**
   * グリッド内の全ボクセルを反復処理
   * @param {Object} grid - グリッド情報
   * @param {Function} callback - 各ボクセルに対するコールバック関数
   */
  static iterateAllVoxels(grid, callback) {
    const { numVoxelsX, numVoxelsY, numVoxelsZ } = grid;
    
    for (let x = 0; x &lt; numVoxelsX; x++) {
      for (let y = 0; y &lt; numVoxelsY; y++) {
        for (let z = 0; z &lt; numVoxelsZ; z++) {
          const key = this.getVoxelKey(x, y, z);
          callback(x, y, z, key);
        }
      }
    }
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CoordinateTransformer.html">CoordinateTransformer</a></li><li><a href="DataProcessor.html">DataProcessor</a></li><li><a href="Heatbox.html">Heatbox</a></li><li><a href="VoxelGrid.html">VoxelGrid</a></li><li><a href="VoxelRenderer.html">VoxelRenderer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#COLOR_CONSTANTS">COLOR_CONSTANTS</a></li><li><a href="global.html#COORDINATE_CONSTANTS">COORDINATE_CONSTANTS</a></li><li><a href="global.html#DEFAULT_OPTIONS">DEFAULT_OPTIONS</a></li><li><a href="global.html#DEFAULT_STATISTICS">DEFAULT_STATISTICS</a></li><li><a href="global.html#ERROR_MESSAGES">ERROR_MESSAGES</a></li><li><a href="global.html#LOG_LEVELS">LOG_LEVELS</a></li><li><a href="global.html#Logger">Logger</a></li><li><a href="global.html#PERFORMANCE_LIMITS">PERFORMANCE_LIMITS</a></li><li><a href="global.html#VERSION">VERSION</a></li><li><a href="global.html#calculateDataRange">calculateDataRange</a></li><li><a href="global.html#createBoundsFromCenter">createBoundsFromCenter</a></li><li><a href="global.html#createHeatbox">createHeatbox</a></li><li><a href="global.html#estimateInitialVoxelSize">estimateInitialVoxelSize</a></li><li><a href="global.html#generateTestEntities">generateTestEntities</a></li><li><a href="global.html#getAllEntities">getAllEntities</a></li><li><a href="global.html#getEnvironmentInfo">getEnvironmentInfo</a></li><li><a href="global.html#getLogLevel">getLogLevel</a></li><li><a href="global.html#getTokyoStationBounds">getTokyoStationBounds</a></li><li><a href="global.html#hasValidPosition">hasValidPosition</a></li><li><a href="global.html#isValidEntities">isValidEntities</a></li><li><a href="global.html#isValidViewer">isValidViewer</a></li><li><a href="global.html#isValidVoxelSize">isValidVoxelSize</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#validateAndNormalizeOptions">validateAndNormalizeOptions</a></li><li><a href="global.html#validateVoxelCount">validateVoxelCount</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Aug 26 2025 23:55:56 GMT+0900 (Japan Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
