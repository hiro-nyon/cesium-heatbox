<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/CoordinateTransformer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/CoordinateTransformer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * 座標変換を担当するクラス
 */
import * as Cesium from 'cesium';
import { COORDINATE_CONSTANTS } from '../utils/constants.js';

/**
 * 座標変換機能を提供するクラス
 */
export class CoordinateTransformer {
  /**
   * エンティティ配列から3D境界を計算
   * @param {Array} entities - エンティティ配列
   * @returns {Object} 境界情報
   */
  static calculateBounds(entities) {
    if (!Array.isArray(entities) || entities.length === 0) {
      throw new Error('エンティティが提供されていません');
    }
    
    let minLon = Infinity;
    let maxLon = -Infinity;
    let minLat = Infinity;
    let maxLat = -Infinity;
    let minAlt = Infinity;
    let maxAlt = -Infinity;
    
    let validCount = 0;
    
    for (const entity of entities) {
      const position = this.getEntityPosition(entity);
      
      if (!position) {
        continue;
      }
      
      // Cartesian3からCartographic（経度、緯度、高度）に変換
      const cartographic = Cesium.Cartographic.fromCartesian(position);
      const lon = Cesium.Math.toDegrees(cartographic.longitude);
      const lat = Cesium.Math.toDegrees(cartographic.latitude);
      const alt = cartographic.height;
      
      minLon = Math.min(minLon, lon);
      maxLon = Math.max(maxLon, lon);
      minLat = Math.min(minLat, lat);
      maxLat = Math.max(maxLat, lat);
      minAlt = Math.min(minAlt, alt);
      maxAlt = Math.max(maxAlt, alt);
      
      validCount++;
    }
    
    if (validCount === 0) {
      throw new Error('有効な位置情報を持つエンティティが見つかりません');
    }
    
    return {
      minLon,
      maxLon,
      minLat,
      maxLat,
      minAlt,
      maxAlt,
      centerLon: (minLon + maxLon) / 2,
      centerLat: (minLat + maxLat) / 2,
      centerAlt: (minAlt + maxAlt) / 2
    };
  }
  
  /**
   * エンティティから位置情報を取得
   * @param {Object} entity - Cesium Entity
   * @returns {Cesium.Cartesian3|null} 位置情報
   */
  static getEntityPosition(entity) {
    if (!entity || !entity.position) {
      return null;
    }
    
    try {
      // Propertyベースの位置情報の場合
      if (typeof entity.position.getValue === 'function') {
        const position = entity.position.getValue(Cesium.JulianDate.now());
        return position;
      }
      
      // 直接Cartesian3の場合
      if (entity.position.x !== undefined) {
        return entity.position;
      }
      
      return null;
    } catch (error) {
      console.warn('エンティティの位置情報取得に失敗:', error);
      return null;
    }
  }
  
  /**
   * 境界からメートル単位の範囲を計算
   * @param {Object} bounds - 境界情報
   * @returns {Object} メートル単位の範囲情報
   */
  static calculateMetersRange(bounds) {
    const { minLon, maxLon, minLat, maxLat, minAlt, maxAlt, centerLat } = bounds;
    
    // 緯度による経度の補正
    const centerLatRad = centerLat * COORDINATE_CONSTANTS.DEGREES_TO_RADIANS;
    const lonRangeMeters = (maxLon - minLon) * COORDINATE_CONSTANTS.DEGREES_TO_METERS_LAT * Math.cos(centerLatRad);
    const latRangeMeters = (maxLat - minLat) * COORDINATE_CONSTANTS.DEGREES_TO_METERS_LAT;
    const altRangeMeters = maxAlt - minAlt;
    
    return {
      lonRangeMeters,
      latRangeMeters,
      altRangeMeters
    };
  }
  
  /**
   * 地理座標をボクセルインデックスに変換
   * @param {number} lon - 経度
   * @param {number} lat - 緯度
   * @param {number} alt - 高度
   * @param {Object} bounds - 境界情報
   * @param {Object} grid - グリッド情報
   * @returns {Object} ボクセルインデックス {x, y, z}
   */
  static coordinateToVoxelIndex(lon, lat, alt, bounds, grid) {
    const { minLon, maxLon, minLat, maxLat, minAlt, maxAlt } = bounds;
    const { numVoxelsX, numVoxelsY, numVoxelsZ } = grid;
    
    // 正規化（0-1の範囲）
    const lonDen = (maxLon - minLon);
    const latDen = (maxLat - minLat);
    const altDen = (maxAlt - minAlt);
    const normalizedLon = lonDen === 0 ? 0 : (lon - minLon) / lonDen;
    const normalizedLat = latDen === 0 ? 0 : (lat - minLat) / latDen;
    const normalizedAlt = altDen === 0 ? 0 : (alt - minAlt) / altDen;
    
    // ボクセルインデックスを計算
    const voxelX = Math.floor(normalizedLon * numVoxelsX);
    const voxelY = Math.floor(normalizedLat * numVoxelsY);
    const voxelZ = Math.floor(normalizedAlt * numVoxelsZ);
    
    // 境界チェック
    return {
      x: Math.max(0, Math.min(numVoxelsX - 1, voxelX)),
      y: Math.max(0, Math.min(numVoxelsY - 1, voxelY)),
      z: Math.max(0, Math.min(numVoxelsZ - 1, voxelZ))
    };
  }

  /**
   * Cartesian3座標をボクセルインデックスに変換
   * @param {Cesium.Cartesian3} position - Cartesian3座標
   * @param {Object} bounds - 境界情報
   * @param {Object} grid - グリッド情報
   * @returns {Object} ボクセルインデックス {x, y, z}
   */
  static cartesianToVoxelIndex(position, bounds, grid) {
    const cartographic = Cesium.Cartographic.fromCartesian(position);
    const lon = Cesium.Math.toDegrees(cartographic.longitude);
    const lat = Cesium.Math.toDegrees(cartographic.latitude);
    const alt = cartographic.height;
    return this.coordinateToVoxelIndex(lon, lat, alt, bounds, grid);
  }
  
  /**
   * ボクセルインデックスを地理座標（中心位置）に変換
   * @param {number} x - X軸ボクセルインデックス
   * @param {number} y - Y軸ボクセルインデックス
   * @param {number} z - Z軸ボクセルインデックス
   * @param {Object} bounds - 境界情報
   * @param {Object} grid - グリッド情報
   * @returns {Object} 地理座標 {lon, lat, alt}
   */
  static voxelIndexToCoordinate(x, y, z, bounds, grid) {
    const { minLon, maxLon, minLat, maxLat, minAlt, maxAlt } = bounds;
    const { numVoxelsX, numVoxelsY, numVoxelsZ } = grid;
    
    // ボクセルの中心位置を計算
    const normalizedLon = (x + 0.5) / numVoxelsX;
    const normalizedLat = (y + 0.5) / numVoxelsY;
    const normalizedAlt = (z + 0.5) / numVoxelsZ;
    
    return {
      lon: minLon + normalizedLon * (maxLon - minLon),
      lat: minLat + normalizedLat * (maxLat - minLat),
      alt: minAlt + normalizedAlt * (maxAlt - minAlt)
    };
  }
  
  /**
   * 地理座標をCesium Cartesian3に変換
   * @param {number} lon - 経度
   * @param {number} lat - 緯度
   * @param {number} alt - 高度
   * @returns {Cesium.Cartesian3} Cesium Cartesian3
   */
  static coordinateToCartesian3(lon, lat, alt) {
    return Cesium.Cartesian3.fromDegrees(lon, lat, alt);
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CoordinateTransformer.html">CoordinateTransformer</a></li><li><a href="DataProcessor.html">DataProcessor</a></li><li><a href="Heatbox.html">Heatbox</a></li><li><a href="VoxelGrid.html">VoxelGrid</a></li><li><a href="VoxelRenderer.html">VoxelRenderer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#COLOR_CONSTANTS">COLOR_CONSTANTS</a></li><li><a href="global.html#COORDINATE_CONSTANTS">COORDINATE_CONSTANTS</a></li><li><a href="global.html#DEFAULT_OPTIONS">DEFAULT_OPTIONS</a></li><li><a href="global.html#DEFAULT_STATISTICS">DEFAULT_STATISTICS</a></li><li><a href="global.html#ERROR_MESSAGES">ERROR_MESSAGES</a></li><li><a href="global.html#PERFORMANCE_LIMITS">PERFORMANCE_LIMITS</a></li><li><a href="global.html#VERSION">VERSION</a></li><li><a href="global.html#createBoundsFromCenter">createBoundsFromCenter</a></li><li><a href="global.html#createHeatbox">createHeatbox</a></li><li><a href="global.html#generateTestEntities">generateTestEntities</a></li><li><a href="global.html#getAllEntities">getAllEntities</a></li><li><a href="global.html#getEnvironmentInfo">getEnvironmentInfo</a></li><li><a href="global.html#getTokyoStationBounds">getTokyoStationBounds</a></li><li><a href="global.html#hasValidPosition">hasValidPosition</a></li><li><a href="global.html#isValidEntities">isValidEntities</a></li><li><a href="global.html#isValidViewer">isValidViewer</a></li><li><a href="global.html#isValidVoxelSize">isValidVoxelSize</a></li><li><a href="global.html#validateAndNormalizeOptions">validateAndNormalizeOptions</a></li><li><a href="global.html#validateVoxelCount">validateVoxelCount</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Aug 19 2025 21:48:32 GMT+0900 (日本標準時)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
