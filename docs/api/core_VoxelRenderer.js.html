<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/VoxelRenderer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/VoxelRenderer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * ボクセルの描画を担当するクラス
 */
import * as Cesium from 'cesium';
import { CoordinateTransformer } from './CoordinateTransformer.js';
import { VoxelGrid } from './VoxelGrid.js';

/**
 * 3Dボクセルの描画を担当するクラス
 */
export class VoxelRenderer {
  /**
   * コンストラクタ
   * @param {Cesium.Viewer} viewer - CesiumJS Viewer
   * @param {Object} options - 描画オプション
   */
  constructor(viewer, options = {}) {
    this.viewer = viewer;
    this.options = {
      minColor: [0, 0, 255],
      maxColor: [255, 0, 0],
      opacity: 0.8,
      emptyOpacity: 0.03,
      showOutline: true,
      showEmptyVoxels: false,
      ...options
    };
    this.primitives = [];
  }

  /**
   * ボクセルデータを描画
   * @param {Map} voxelData - ボクセルデータ
   * @param {Object} bounds - 境界情報
   * @param {Object} grid - グリッド情報
   * @param {Object} statistics - 統計情報
   */
  render(voxelData, bounds, grid, statistics) {
    this.clear();

    const instances = [];
    const outlineInstances = [];

    VoxelGrid.iterateAllVoxels(grid, (x, y, z, key) => {
      const voxelInfo = voxelData.get(key);
      const hasData = !!voxelInfo;

      if (!hasData &amp;&amp; !this.options.showEmptyVoxels) {
        return;
      }

      const centerCoord = CoordinateTransformer.voxelIndexToCoordinate(x, y, z, bounds, grid);
      const worldPosition = CoordinateTransformer.coordinateToCartesian3(centerCoord.lon, centerCoord.lat, centerCoord.alt);
      
      const dimensions = new Cesium.Cartesian3(grid.voxelSizeMeters, grid.voxelSizeMeters, grid.voxelSizeMeters);
      const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(worldPosition);

      let color, opacity;
      if (hasData) {
        const normalizedDensity = statistics.maxCount > statistics.minCount
          ? (voxelInfo.count - statistics.minCount) / (statistics.maxCount - statistics.minCount)
          : 0;
        color = this.interpolateColor(normalizedDensity);
        opacity = this.options.opacity;
      } else {
        color = Cesium.Color.LIGHTGRAY;
        opacity = this.options.emptyOpacity;
      }

      // ボクセル本体のインスタンス
      instances.push(new Cesium.GeometryInstance({
        geometry: new Cesium.BoxGeometry({ dimensions }),
        modelMatrix: modelMatrix,
        attributes: {
          color: Cesium.ColorGeometryInstanceAttribute.fromColor(color.withAlpha(opacity))
        },
        id: {
          type: 'voxel',
          key: key,
          info: voxelInfo || { x, y, z, count: 0 }
        }
      }));

      // 境界線のインスタンス
      if (this.options.showOutline) {
        outlineInstances.push(new Cesium.GeometryInstance({
          geometry: new Cesium.BoxOutlineGeometry({ dimensions }),
          modelMatrix: modelMatrix,
          attributes: {
            color: Cesium.ColorGeometryInstanceAttribute.fromColor(hasData ? color : Cesium.Color.DARKGRAY)
          }
        }));
      }
    });

    if (instances.length > 0) {
      const primitive = new Cesium.Primitive({
        geometryInstances: instances,
        appearance: new Cesium.PerInstanceColorAppearance({
          translucent: true,
          closed: true
        }),
        asynchronous: false
      });
      this.viewer.scene.primitives.add(primitive);
      this.primitives.push(primitive);
    }

    if (outlineInstances.length > 0) {
      const outlinePrimitive = new Cesium.Primitive({
        geometryInstances: outlineInstances,
        appearance: new Cesium.PerInstanceColorAppearance({
          flat: true,
          translucent: false
        }),
        asynchronous: false
      });
      this.viewer.scene.primitives.add(outlinePrimitive);
      this.primitives.push(outlinePrimitive);
    }
  }

  /**
   * 密度に基づいて色を補間
   * @param {number} normalizedDensity - 正規化された密度 (0-1)
   * @returns {Cesium.Color} 計算された色
   */
  interpolateColor(normalizedDensity) {
    const [minR, minG, minB] = this.options.minColor;
    const [maxR, maxG, maxB] = this.options.maxColor;
    
    const r = Math.round(minR + (maxR - minR) * normalizedDensity);
    const g = Math.round(minG + (maxG - minG) * normalizedDensity);
    const b = Math.round(minB + (maxB - minB) * normalizedDensity);
    
    return Cesium.Color.fromBytes(r, g, b);
  }

  /**
   * ボクセルの説明文を生成
   * @param {Object} voxelInfo - ボクセル情報
   * @returns {string} HTML形式の説明文
   */
  createVoxelDescription(voxelInfo) {
    return `
      &lt;b>Voxel [${voxelInfo.x}, ${voxelInfo.y}, ${voxelInfo.z}]&lt;/b>&lt;br>
      Entity Count: ${voxelInfo.count}&lt;br>
    `;
  }

  /**
   * 描画されたプリミティブを全てクリア
   */
  clear() {
    for (const primitive of this.primitives) {
      this.viewer.scene.primitives.remove(primitive);
    }
    this.primitives = [];
  }

  /**
   * 表示/非表示を切り替え
   * @param {boolean} show - 表示する場合はtrue
   */
  setVisible(show) {
    for (const primitive of this.primitives) {
      primitive.show = show;
    }
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CoordinateTransformer.html">CoordinateTransformer</a></li><li><a href="DataProcessor.html">DataProcessor</a></li><li><a href="Heatbox.html">Heatbox</a></li><li><a href="VoxelGrid.html">VoxelGrid</a></li><li><a href="VoxelRenderer.html">VoxelRenderer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#COLOR_CONSTANTS">COLOR_CONSTANTS</a></li><li><a href="global.html#COORDINATE_CONSTANTS">COORDINATE_CONSTANTS</a></li><li><a href="global.html#DEFAULT_OPTIONS">DEFAULT_OPTIONS</a></li><li><a href="global.html#DEFAULT_STATISTICS">DEFAULT_STATISTICS</a></li><li><a href="global.html#ERROR_MESSAGES">ERROR_MESSAGES</a></li><li><a href="global.html#PERFORMANCE_LIMITS">PERFORMANCE_LIMITS</a></li><li><a href="global.html#VERSION">VERSION</a></li><li><a href="global.html#createBoundsFromCenter">createBoundsFromCenter</a></li><li><a href="global.html#createHeatbox">createHeatbox</a></li><li><a href="global.html#generateTestEntities">generateTestEntities</a></li><li><a href="global.html#getAllEntities">getAllEntities</a></li><li><a href="global.html#getEnvironmentInfo">getEnvironmentInfo</a></li><li><a href="global.html#getTokyoStationBounds">getTokyoStationBounds</a></li><li><a href="global.html#hasValidPosition">hasValidPosition</a></li><li><a href="global.html#isValidEntities">isValidEntities</a></li><li><a href="global.html#isValidViewer">isValidViewer</a></li><li><a href="global.html#isValidVoxelSize">isValidVoxelSize</a></li><li><a href="global.html#validateAndNormalizeOptions">validateAndNormalizeOptions</a></li><li><a href="global.html#validateVoxelCount">validateVoxelCount</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Tue Aug 19 2025 21:48:32 GMT+0900 (日本標準時)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
