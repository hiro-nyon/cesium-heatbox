<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/VoxelRenderer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/VoxelRenderer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * ボクセルの描画を担当するクラス
 * プロトタイプ実装ベース（シンプル・確実動作重視）
 */
import * as Cesium from 'cesium';
import { Logger } from '../utils/logger.js';

// v0.1.5: カラーマップ定義（256段階のLUTテーブル）
const COLOR_MAPS = {
  // Viridisカラーマップ（簡略化した16段階）
  viridis: [
    [68, 1, 84], [71, 44, 122], [59, 81, 139], [44, 113, 142],
    [33, 144, 141], [39, 173, 129], [92, 200, 99], [170, 220, 50],
    [253, 231, 37], [255, 255, 255], [255, 255, 255], [255, 255, 255],
    [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]
  ],
  // Infernoカラーマップ（簡略化した16段階）
  inferno: [
    [0, 0, 4], [31, 12, 72], [85, 15, 109], [136, 34, 106],
    [186, 54, 85], [227, 89, 51], [249, 142, 8], [252, 187, 17],
    [245, 219, 76], [252, 255, 164], [255, 255, 255], [255, 255, 255],
    [255, 255, 255], [255, 255, 255], [255, 255, 255], [255, 255, 255]
  ],
  // 二極性配色（blue-white-red）
  diverging: [
    [0, 0, 255], [32, 64, 255], [64, 128, 255], [96, 160, 255],
    [128, 192, 255], [160, 224, 255], [192, 240, 255], [224, 248, 255],
    [255, 255, 255], [255, 248, 224], [255, 240, 192], [255, 224, 160],
    [255, 192, 128], [255, 160, 96], [255, 128, 64], [255, 64, 32], [255, 0, 0]
  ]
};

/**
 * 3Dボクセルの描画を担当するクラス
 */
export class VoxelRenderer {
  /**
   * コンストラクタ
   * @param {Cesium.Viewer} viewer - CesiumJS Viewer
   * @param {Object} options - 描画オプション
   */
  constructor(viewer, options = {}) {
    this.viewer = viewer;
    this.options = {
      minColor: [0, 0, 255],
      maxColor: [255, 0, 0],
      opacity: 0.8,
      emptyOpacity: 0.03,
      showOutline: true,
      showEmptyVoxels: false,
      wireframeOnly: false,    // 枠線のみ表示
      heightBased: false,      // 高さベース表現
      outlineWidth: 2,         // 枠線の太さ
      ...options
    };
    this.voxelEntities = [];
    
    Logger.debug('VoxelRenderer initialized with options:', this.options);
  }

  /**
   * ボクセルデータを描画（シンプル実装）
   * @param {Map} voxelData - ボクセルデータ
   * @param {Object} bounds - 境界情報
   * @param {Object} grid - グリッド情報
   * @param {Object} statistics - 統計情報
   * @returns {number} 実際に描画されたボクセル数
   */
  render(voxelData, bounds, grid, statistics) {
    this.clear();
    Logger.debug('VoxelRenderer.render - Starting render with simplified approach', {
      voxelDataSize: voxelData.size,
      bounds,
      grid,
      statistics
    });

    // バウンディングボックスのデバッグ表示制御（v0.1.5: debug.showBounds対応）
    const shouldShowBounds = this._shouldShowBounds();
    if (shouldShowBounds) {
      this._renderBoundingBox(bounds);
    }

    // 表示するボクセルのリスト
    let displayVoxels = [];
    let topNVoxels = new Set(); // v0.1.5: TopN強調表示用

    // 空ボクセルのフィルタリング
    if (this.options.showEmptyVoxels) {
      // 全ボクセルを生成（これは上限値が大きいとメモリ消費とパフォーマンスに影響する）
      const maxVoxels = Math.min(grid.totalVoxels, this.options.maxRenderVoxels || 10000);
      Logger.debug(`Generating grid for up to ${maxVoxels} voxels`);
      
      // 空のボクセルも含めて全ボクセルを追加
      for (let x = 0; x &lt; grid.numVoxelsX; x++) {
        for (let y = 0; y &lt; grid.numVoxelsY; y++) {
          for (let z = 0; z &lt; grid.numVoxelsZ; z++) {
            const voxelKey = `${x},${y},${z}`;
            const voxelInfo = voxelData.get(voxelKey) || { x, y, z, count: 0 };
            
            displayVoxels.push({
              key: voxelKey,
              info: voxelInfo
            });
            
            if (displayVoxels.length >= maxVoxels) {
              Logger.debug(`Reached maximum voxel limit of ${maxVoxels}`);
              break;
            }
          }
          if (displayVoxels.length >= maxVoxels) break;
        }
        if (displayVoxels.length >= maxVoxels) break;
      }
    } else {
      // データがあるボクセルのみ表示
      displayVoxels = Array.from(voxelData.entries()).map(([key, info]) => {
        return { key, info };
      });
      
      // 密度でソートして上位を表示
      if (this.options.maxRenderVoxels &amp;&amp; displayVoxels.length > this.options.maxRenderVoxels) {
        displayVoxels.sort((a, b) => b.info.count - a.info.count);
        displayVoxels = displayVoxels.slice(0, this.options.maxRenderVoxels);
        Logger.debug(`Limited to ${displayVoxels.length} highest density voxels`);
      }
    }

    // v0.1.5: TopN強調表示の前処理
    if (this.options.highlightTopN &amp;&amp; this.options.highlightTopN > 0) {
      const sortedForTopN = [...displayVoxels].sort((a, b) => b.info.count - a.info.count);
      const topN = sortedForTopN.slice(0, this.options.highlightTopN);
      topN.forEach(voxel => topNVoxels.add(voxel.key));
      Logger.debug(`TopN highlight enabled: ${topNVoxels.size} voxels will be highlighted`);
    }
    
    Logger.debug(`Rendering ${displayVoxels.length} voxels`);
    
    // レンダリングカウント
    let renderedCount = 0;

    // 実際にボクセルを描画
    displayVoxels.forEach(({ key, info }) => {
      try {
        const { x, y, z } = info;
        
        // ボクセル中心座標を計算（シンプルな方法）
        const centerLon = bounds.minLon + (x + 0.5) * (bounds.maxLon - bounds.minLon) / grid.numVoxelsX;
        const centerLat = bounds.minLat + (y + 0.5) * (bounds.maxLat - bounds.minLat) / grid.numVoxelsY;
        const centerAlt = bounds.minAlt + (z + 0.5) * (bounds.maxAlt - bounds.minAlt) / grid.numVoxelsZ;
        
        // 密度に応じた色を計算
        let color, opacity;
        const isTopN = topNVoxels.has(key); // v0.1.5: TopNハイライト判定
        
        if (info.count === 0) {
          // 空ボクセルの場合
          color = Cesium.Color.LIGHTGRAY;
          opacity = this.options.emptyOpacity;
        } else {
          // データありボクセルの場合
          const normalizedDensity = statistics.maxCount > statistics.minCount ? 
            (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;
          
          color = this.interpolateColor(normalizedDensity, info.count);
          opacity = this.options.opacity;
          
          // v0.1.5: TopN強調表示で非TopNボクセルを淡色化
          if (this.options.highlightTopN &amp;&amp; !isTopN) {
            opacity *= (1 - (this.options.highlightStyle?.boostOpacity || 0.2));
          }
        }
        
        // 高さベース表現の場合、ボクセルの高さを密度に応じて調整
        // 各軸のセルサイズ（グリッドが持つ実セルサイズを優先、なければvoxelSizeMetersにフォールバック）
        const cellSizeX = grid.cellSizeX || (grid.lonRangeMeters ? (grid.lonRangeMeters / grid.numVoxelsX) : grid.voxelSizeMeters);
        const cellSizeY = grid.cellSizeY || (grid.latRangeMeters ? (grid.latRangeMeters / grid.numVoxelsY) : grid.voxelSizeMeters);
        const baseCellSizeZ = grid.cellSizeZ || (grid.altRangeMeters ? Math.max(grid.altRangeMeters / Math.max(grid.numVoxelsZ, 1), 1) : Math.max(grid.voxelSizeMeters, 1));

        let boxHeight = baseCellSizeZ;
        if (this.options.heightBased &amp;&amp; info.count > 0) {
          const normalizedDensity = statistics.maxCount > statistics.minCount ? 
            (info.count - statistics.minCount) / (statistics.maxCount - statistics.minCount) : 0;
          boxHeight = baseCellSizeZ * (0.1 + normalizedDensity * 0.9); // 10%から100%の高さ
        }
        
        // エンティティの設定
        const entityConfig = {
          position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt),
          box: {
            dimensions: new Cesium.Cartesian3(
              cellSizeX,
              cellSizeY,
              boxHeight
            ),
            outline: this.options.showOutline,
            outlineColor: color.withAlpha(1.0),
            outlineWidth: isTopN &amp;&amp; this.options.highlightTopN ? 
              (this.options.highlightStyle?.outlineWidth || this.options.outlineWidth) : 
              this.options.outlineWidth
          },
          properties: {
            type: 'voxel',
            key: key,
            count: info.count,
            x: x,
            y: y,
            z: z
          },
          description: this.createVoxelDescription(info, key)
        };
        
        // wireframeOnlyモードの場合は透明、そうでなければ通常の材質
        if (this.options.wireframeOnly) {
          entityConfig.box.material = Cesium.Color.TRANSPARENT;
          entityConfig.box.fill = false;
        } else {
          entityConfig.box.material = color.withAlpha(opacity);
          entityConfig.box.fill = true;
        }
        
        // エンティティを作成
        const entity = this.viewer.entities.add(entityConfig);
        
        this.voxelEntities.push(entity);
        renderedCount++;
      } catch (error) {
        Logger.warn('Error rendering voxel:', error);
      }
    });

    Logger.info(`Successfully rendered ${renderedCount} voxels`);
    
    // 実際に描画されたボクセル数を返す
    return renderedCount;
  }

  /**
   * バウンディングボックスを描画（デバッグ用）
   * @param {Object} bounds - 境界情報
   * @private
   */
  _renderBoundingBox(bounds) {
    if (!bounds) return;

    try {
      // 中心点
      const centerLon = (bounds.minLon + bounds.maxLon) / 2;
      const centerLat = (bounds.minLat + bounds.maxLat) / 2;
      const centerAlt = (bounds.minAlt + bounds.maxAlt) / 2;
      
      // サイズ計算（概算）
      const widthMeters = (bounds.maxLon - bounds.minLon) * 111000 * Math.cos(centerLat * Math.PI / 180);
      const depthMeters = (bounds.maxLat - bounds.minLat) * 111000;
      const heightMeters = bounds.maxAlt - bounds.minAlt;
      
      // 境界ボックスの作成
      const boundingBox = this.viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, centerAlt),
        box: {
          dimensions: new Cesium.Cartesian3(widthMeters, depthMeters, heightMeters),
          material: Cesium.Color.YELLOW.withAlpha(0.1),
          outline: true,
          outlineColor: Cesium.Color.YELLOW.withAlpha(0.3),
          outlineWidth: 2
        },
        description: `バウンディングボックス&lt;br>サイズ: ${widthMeters.toFixed(1)} x ${depthMeters.toFixed(1)} x ${heightMeters.toFixed(1)} m`
      });
      
      this.voxelEntities.push(boundingBox);
      
      Logger.debug('Debug bounding box added:', {
        center: { lon: centerLon, lat: centerLat, alt: centerAlt },
        size: { width: widthMeters, depth: depthMeters, height: heightMeters }
      });
      
    } catch (error) {
      Logger.warn('Failed to render bounding box:', error);
    }
  }

  /**
   * 密度に基づいて色を補間（v0.1.5: カラーマップ対応）
   * @param {number} normalizedDensity - 正規化された密度 (0-1)
   * @param {number} [rawValue] - 生値（二極性配色用）
   * @returns {Cesium.Color} 計算された色
   */
  interpolateColor(normalizedDensity, rawValue = null) {
    // v0.1.5: 二極性配色対応
    if (this.options.diverging &amp;&amp; rawValue !== null) {
      return this._interpolateDivergingColor(rawValue);
    }
    
    // v0.1.5: カラーマップ対応
    if (this.options.colorMap &amp;&amp; this.options.colorMap !== 'custom') {
      return this._interpolateFromColorMap(normalizedDensity, this.options.colorMap);
    }
    
    // 従来のmin/max色補間（後方互換）
    const [minR, minG, minB] = this.options.minColor;
    const [maxR, maxG, maxB] = this.options.maxColor;
    
    const r = Math.round(minR + (maxR - minR) * normalizedDensity);
    const g = Math.round(minG + (maxG - minG) * normalizedDensity);
    const b = Math.round(minB + (maxB - minB) * normalizedDensity);
    
    return Cesium.Color.fromBytes(r, g, b);
  }
  
  /**
   * カラーマップから色を補間
   * @param {number} normalizedValue - 正規化された値 (0-1)
   * @param {string} colorMapName - カラーマップ名
   * @returns {Cesium.Color} 計算された色
   * @private
   */
  _interpolateFromColorMap(normalizedValue, colorMapName) {
    const colorMap = COLOR_MAPS[colorMapName];
    if (!colorMap) {
      Logger.warn(`Unknown color map: ${colorMapName}. Falling back to custom.`);
      return this.interpolateColor(normalizedValue);
    }
    
    // マップインデックスを計算
    const scaledValue = normalizedValue * (colorMap.length - 1);
    const lowerIndex = Math.floor(scaledValue);
    const upperIndex = Math.min(lowerIndex + 1, colorMap.length - 1);
    const fraction = scaledValue - lowerIndex;
    
    // 線形補間
    const [r1, g1, b1] = colorMap[lowerIndex];
    const [r2, g2, b2] = colorMap[upperIndex];
    
    const r = Math.round(r1 + (r2 - r1) * fraction);
    const g = Math.round(g1 + (g2 - g1) * fraction);
    const b = Math.round(b1 + (b2 - b1) * fraction);
    
    return Cesium.Color.fromBytes(r, g, b);
  }
  
  /**
   * 二極性配色（blue-white-red）で色を補間
   * @param {number} rawValue - 生値
   * @returns {Cesium.Color} 計算された色
   * @private
   */
  _interpolateDivergingColor(rawValue) {
    const pivot = this.options.divergingPivot || 0;
    const colorMap = COLOR_MAPS.diverging;
    const midIndex = Math.floor(colorMap.length / 2);
    
    // ピボットからの偏差を正規化
    let normalizedValue;
    if (rawValue &lt;= pivot) {
      // 青い側 (0 to 0.5)
      normalizedValue = 0.5 * (rawValue / pivot);
      normalizedValue = Math.max(0, Math.min(0.5, normalizedValue));
    } else {
      // 赤い側 (0.5 to 1)
      normalizedValue = 0.5 + 0.5 * ((rawValue - pivot) / pivot);
      normalizedValue = Math.max(0.5, Math.min(1, normalizedValue));
    }
    
    return this._interpolateFromColorMap(normalizedValue, 'diverging');
  }

  /**
   * ボクセルの説明文を生成
   * @param {Object} voxelInfo - ボクセル情報
   * @param {string} voxelKey - ボクセルキー
   * @returns {string} HTML形式の説明文
   */
  createVoxelDescription(voxelInfo, voxelKey) {
    return `
      &lt;div style="padding: 10px; font-family: Arial, sans-serif;">
        &lt;h3 style="margin-top: 0;">ボクセル [${voxelInfo.x}, ${voxelInfo.y}, ${voxelInfo.z}]&lt;/h3>
        &lt;table style="width: 100%;">
          &lt;tr>&lt;td>&lt;b>エンティティ数:&lt;/b>&lt;/td>&lt;td>${voxelInfo.count}&lt;/td>&lt;/tr>
          &lt;tr>&lt;td>&lt;b>ID:&lt;/b>&lt;/td>&lt;td>${voxelKey}&lt;/td>&lt;/tr>
        &lt;/table>
      &lt;/div>
    `;
  }

  /**
   * 描画されたエンティティを全てクリア
   */
  clear() {
    Logger.debug('VoxelRenderer.clear - Removing', this.voxelEntities.length, 'entities');
    
    this.voxelEntities.forEach(entity => {
      try {
        // isDestroyedのチェックを安全に行う
        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;
        
        if (entity &amp;&amp; !isDestroyed) {
          this.viewer.entities.remove(entity);
        }
      } catch (error) {
        Logger.warn('Entity removal error:', error);
      }
    });
    
    this.voxelEntities = [];
  }

  /**
   * デバッグ境界ボックス表示の判定（v0.1.5: debug.showBounds対応）
   * @returns {boolean} 境界ボックスを表示する場合はtrue
   * @private
   */
  _shouldShowBounds() {
    if (!this.options.debug) {
      return false;
    }
    
    if (typeof this.options.debug === 'boolean') {
      // 従来の動作：debugがtrueの場合はバウンディングボックス表示
      return this.options.debug;
    }
    
    if (typeof this.options.debug === 'object' &amp;&amp; this.options.debug !== null) {
      // 新しい動作：debug.showBoundsで明示的に制御
      return this.options.debug.showBounds === true;
    }
    
    return false;
  }

  /**
   * 表示/非表示を切り替え
   * @param {boolean} show - 表示する場合はtrue
   */
  setVisible(show) {
    Logger.debug('VoxelRenderer.setVisible:', show);
    
    this.voxelEntities.forEach(entity => {
      try {
        // isDestroyedのチェックを安全に行う
        const isDestroyed = typeof entity.isDestroyed === 'function' ? entity.isDestroyed() : false;
        
        if (entity &amp;&amp; !isDestroyed) {
          entity.show = show;
        }
      } catch (error) {
        Logger.warn('Entity visibility error:', error);
      }
    });
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CoordinateTransformer.html">CoordinateTransformer</a></li><li><a href="DataProcessor.html">DataProcessor</a></li><li><a href="Heatbox.html">Heatbox</a></li><li><a href="VoxelGrid.html">VoxelGrid</a></li><li><a href="VoxelRenderer.html">VoxelRenderer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#COLOR_CONSTANTS">COLOR_CONSTANTS</a></li><li><a href="global.html#COORDINATE_CONSTANTS">COORDINATE_CONSTANTS</a></li><li><a href="global.html#DEFAULT_OPTIONS">DEFAULT_OPTIONS</a></li><li><a href="global.html#DEFAULT_STATISTICS">DEFAULT_STATISTICS</a></li><li><a href="global.html#ERROR_MESSAGES">ERROR_MESSAGES</a></li><li><a href="global.html#LOG_LEVELS">LOG_LEVELS</a></li><li><a href="global.html#Logger">Logger</a></li><li><a href="global.html#PERFORMANCE_LIMITS">PERFORMANCE_LIMITS</a></li><li><a href="global.html#VERSION">VERSION</a></li><li><a href="global.html#calculateDataRange">calculateDataRange</a></li><li><a href="global.html#createBoundsFromCenter">createBoundsFromCenter</a></li><li><a href="global.html#createHeatbox">createHeatbox</a></li><li><a href="global.html#estimateInitialVoxelSize">estimateInitialVoxelSize</a></li><li><a href="global.html#generateTestEntities">generateTestEntities</a></li><li><a href="global.html#getAllEntities">getAllEntities</a></li><li><a href="global.html#getEnvironmentInfo">getEnvironmentInfo</a></li><li><a href="global.html#getLogLevel">getLogLevel</a></li><li><a href="global.html#getTokyoStationBounds">getTokyoStationBounds</a></li><li><a href="global.html#hasValidPosition">hasValidPosition</a></li><li><a href="global.html#isValidEntities">isValidEntities</a></li><li><a href="global.html#isValidViewer">isValidViewer</a></li><li><a href="global.html#isValidVoxelSize">isValidVoxelSize</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#validateAndNormalizeOptions">validateAndNormalizeOptions</a></li><li><a href="global.html#validateVoxelCount">validateVoxelCount</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon Aug 25 2025 13:55:03 GMT+0900 (Japan Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
