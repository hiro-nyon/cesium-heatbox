<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Layer Aggregation - Multi-Source (Pedestrian Flow + POI)</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <link href="../common/demo.css" rel="stylesheet">
  <script>
    window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/';
    if (typeof Cesium !== 'undefined' && Cesium.Ion) {
      Cesium.Ion.defaultAccessToken = null;
    }
  </script>
  <script src="../common/camera.js"></script>
  <script src="../../dist/cesium-heatbox.umd.min.js"></script>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div class="control-panel hb-panel">
    <h3>Layer Aggregation - Multi-Source</h3>
    <p style="font-size: 0.9em; color: #666;">Pedestrian flow + POI analysis</p>
    
    <div class="control-group">
      <label for="pedestrianCount">Pedestrian Count: <span id="pedestrianCountValue">800</span></label>
      <input type="range" id="pedestrianCount" min="100" max="2000" value="800" step="100">
    </div>
    
    <div class="control-group">
      <label for="poiCount">POI Count: <span id="poiCountValue">200</span></label>
      <input type="range" id="poiCount" min="50" max="500" value="200" step="50">
    </div>
    
    <div class="control-group">
      <button id="generateBtn" class="hb-btn hb-btn-primary">1. Generate Data</button>
    </div>
    
    <hr>
    
    <div class="control-group">
      <input type="checkbox" id="enableAggregation" checked>
      <label for="enableAggregation">Enable Layer Aggregation</label>
    </div>
    
    <div class="control-group">
      <input type="checkbox" id="showInDescription" checked>
      <label for="showInDescription">Show in Description</label>
    </div>
    
    <hr>
    
    <div class="control-group">
      <input type="checkbox" id="useSpatialId">
      <label for="useSpatialId">Use Spatial ID (Ouranos)</label>
    </div>
    
    <div class="control-group" id="zoomLevelGroup" style="display: none; padding-left: 20px;">
      <label for="zoomLevel">Zoom Level: <span id="zoomLevelValue">25</span></label>
      <input type="range" id="zoomLevel" min="15" max="30" value="25" step="1">
      <div style="font-size: 0.85em; color: #666; margin-top: 5px;">
        15: ~5km | 20: ~150m | 25: ~5m | 30: ~12cm
      </div>
    </div>
    
    <div class="control-group" id="manualVoxelSizeGroup">
      <label for="voxelSize">Voxel Size (meters):</label>
      <input type="number" id="voxelSize" value="40" min="20" max="150">
    </div>
    
    <div class="control-group">
      <button id="createHeatmapBtn" class="hb-btn hb-btn-success">2. Create Heatmap</button>
    </div>
    
    <hr>
    
    <div id="statsPanel" style="display: none;">
      <h4>Statistics</h4>
      <div id="statsContent"></div>
      
      <h4 style="margin-top: 15px;">Source Distribution</h4>
      <div id="layerStats"></div>
      
      <h4 style="margin-top: 15px;">Legend</h4>
      <div id="legend"></div>
    </div>
  </div>

  <script>
    // Load Heatbox from UMD module
    const heatboxModule = window.CesiumHeatbox?.default || window.CesiumHeatbox;
    const Heatbox = heatboxModule?.Heatbox || heatboxModule;
    if (!Heatbox) {
      throw new Error('Failed to load Heatbox library. Check dist/cesium-heatbox.umd.min.js');
    }

    /* 新宿駅中心 / Shinjuku station center */
    const GENERATION_BOUNDS = {
      minLon: 139.69,
      maxLon: 139.71,
      minLat: 35.68,
      maxLat: 35.70,
      minAlt: 0,
      maxAlt: 150
    };

    const CAMERA_DEFAULTS = {
      headingDegrees: 0,
      pitchDegrees: -45,
      altitude: 2000,
      altitudeScale: 0.5,
      cameraLatOffset: -0.025
    };

    // Data source types with colors
    const DATA_SOURCES = {
      pedestrian_morning: { label: 'Pedestrian (Morning)', color: '#FF6B6B', weight: 20 },
      pedestrian_daytime: { label: 'Pedestrian (Daytime)', color: '#FFA500', weight: 30 },
      pedestrian_evening: { label: 'Pedestrian (Evening)', color: '#FFD700', weight: 25 },
      pedestrian_night: { label: 'Pedestrian (Night)', color: '#4169E1', weight: 10 },
      poi_restaurant: { label: 'POI: Restaurant', color: '#32CD32', weight: 5 },
      poi_retail: { label: 'POI: Retail', color: '#00CED1', weight: 4 },
      poi_station: { label: 'POI: Station', color: '#9370DB', weight: 3 },
      poi_park: { label: 'POI: Park', color: '#228B22', weight: 3 }
    };

    const CATEGORY_DEFINITIONS = {
      pedestrian: { label: 'Pedestrian Flow', color: '#FF6B6B' },
      poi: { label: 'Points of Interest', color: '#32CD32' }
    };

    const CATEGORY_GROUPS = {
      pedestrian: ['pedestrian_morning', 'pedestrian_daytime', 'pedestrian_evening', 'pedestrian_night'],
      poi: ['poi_restaurant', 'poi_retail', 'poi_station', 'poi_park']
    };

    let viewer, heatbox, generatedEntities;

    // Setup Viewer with CartoDB imagery
    const imageryProvider = new Cesium.UrlTemplateImageryProvider({
      url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
      subdomains: 'abcd',
      maximumLevel: 19,
      credit: '© OpenStreetMap contributors © CARTO'
    });

    viewer = new Cesium.Viewer('cesiumContainer', {
      baseLayerPicker: false,
      geocoder: false,
      homeButton: false,
      sceneModePicker: false,
      navigationHelpButton: false,
      animation: false,
      timeline: false,
      fullscreenButton: false,
      vrButton: false,
      imageryProvider
    });

    viewer.imageryLayers.removeAll();
    viewer.imageryLayers.addImageryProvider(imageryProvider);
    viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#0f172a');

    // Camera helper
    const CameraHelper = window.HeatboxDemoCamera || null;
    const focusCameraView = (config = {}) => {
      if (!CameraHelper) {
        console.warn('HeatboxDemoCamera not found, skipping camera focus');
        return null;
      }
      return CameraHelper.focus(viewer, config);
    };

    // Initial camera setup
    focusCameraView({ bounds: GENERATION_BOUNDS, pitchDegrees: CAMERA_DEFAULTS.pitchDegrees });

    // UI Elements
    const elements = {
      pedestrianCount: document.getElementById('pedestrianCount'),
      pedestrianCountValue: document.getElementById('pedestrianCountValue'),
      poiCount: document.getElementById('poiCount'),
      poiCountValue: document.getElementById('poiCountValue'),
      generateBtn: document.getElementById('generateBtn'),
      enableAggregation: document.getElementById('enableAggregation'),
      showInDescription: document.getElementById('showInDescription'),
      useSpatialId: document.getElementById('useSpatialId'),
      zoomLevel: document.getElementById('zoomLevel'),
      zoomLevelValue: document.getElementById('zoomLevelValue'),
      zoomLevelGroup: document.getElementById('zoomLevelGroup'),
      voxelSize: document.getElementById('voxelSize'),
      manualVoxelSizeGroup: document.getElementById('manualVoxelSizeGroup'),
      createHeatmapBtn: document.getElementById('createHeatmapBtn'),
      statsPanel: document.getElementById('statsPanel'),
      statsContent: document.getElementById('statsContent'),
      layerStats: document.getElementById('layerStats'),
      legend: document.getElementById('legend')
    };

    // Update count displays
    elements.pedestrianCount.addEventListener('input', (e) => {
      elements.pedestrianCountValue.textContent = e.target.value;
    });
    
    elements.poiCount.addEventListener('input', (e) => {
      elements.poiCountValue.textContent = e.target.value;
    });

    // Update zoom level display and trigger regeneration if heatbox exists
    elements.zoomLevel.addEventListener('input', (e) => {
      elements.zoomLevelValue.textContent = e.target.value;
    });
    
    elements.zoomLevel.addEventListener('change', () => {
      // Auto-regenerate if heatbox already exists
      if (heatbox && generatedEntities && generatedEntities.length > 0) {
        elements.createHeatmapBtn.click();
      }
    });

    // Auto-regenerate when voxel size changes
    elements.voxelSize.addEventListener('change', () => {
      if (heatbox && generatedEntities && generatedEntities.length > 0) {
        elements.createHeatmapBtn.click();
      }
    });

    // Toggle spatial ID options and regenerate
    elements.useSpatialId.addEventListener('change', () => {
      const useSpatialId = elements.useSpatialId.checked;
      elements.zoomLevelGroup.style.display = useSpatialId ? 'block' : 'none';
      elements.manualVoxelSizeGroup.style.display = useSpatialId ? 'none' : 'block';
      
      // Auto-regenerate if heatbox already exists
      if (heatbox && generatedEntities && generatedEntities.length > 0) {
        elements.createHeatmapBtn.click();
      }
    });

    // Weighted random selection
    function selectWeightedRandom(items) {
      const itemArray = Object.entries(items).map(([key, value]) => ({ key, ...value }));
      const totalWeight = itemArray.reduce((sum, item) => sum + item.weight, 0);
      let random = Math.random() * totalWeight;
      
      for (const item of itemArray) {
        random -= item.weight;
        if (random <= 0) return item;
      }
      
      return itemArray[0];
    }

    // Generate pedestrian flow data (clustered around hotspots)
    function generatePedestrianData(count) {
      const entities = [];
      const hotspots = [
        { lon: 139.700, lat: 35.690, radius: 0.003 },  // Station area
        { lon: 139.705, lat: 35.685, radius: 0.002 },  // Shopping district
        { lon: 139.695, lat: 35.695, radius: 0.002 }   // Office area
      ];
      
      for (let i = 0; i < count; i++) {
        const hotspot = hotspots[Math.floor(Math.random() * hotspots.length)];
        const angle = Math.random() * 2 * Math.PI;
        const distance = Math.random() * hotspot.radius;
        
        const lon = hotspot.lon + distance * Math.cos(angle);
        const lat = hotspot.lat + distance * Math.sin(angle);
        const alt = Math.random() * 50; // Ground level pedestrians
        
        // Select time period
        const timeTypes = ['pedestrian_morning', 'pedestrian_daytime', 'pedestrian_evening', 'pedestrian_night'];
        const sourceKey = timeTypes[Math.floor(Math.random() * timeTypes.length)];
        const source = DATA_SOURCES[sourceKey];
        
        const entity = viewer.entities.add({
          id: `pedestrian-${i}`,
          position: Cesium.Cartesian3.fromDegrees(lon, lat, alt),
          point: {
            pixelSize: 2,
            color: Cesium.Color.fromCssColorString(source.color),
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 0.5
          },
          properties: {
            dataSource: sourceKey,
            timestamp: Date.now() - Math.random() * 86400000 // Random within last 24h
          }
        });
        
        entities.push(entity);
      }
      
      return entities;
    }

    // Generate POI data (more sparse, strategic locations)
    function generatePOIData(count) {
      const entities = [];
      const poiTypes = ['poi_restaurant', 'poi_retail', 'poi_station', 'poi_park'];
      
      for (let i = 0; i < count; i++) {
        const lon = GENERATION_BOUNDS.minLon + Math.random() * (GENERATION_BOUNDS.maxLon - GENERATION_BOUNDS.minLon);
        const lat = GENERATION_BOUNDS.minLat + Math.random() * (GENERATION_BOUNDS.maxLat - GENERATION_BOUNDS.minLat);
        const alt = Math.random() * 30; // POIs at ground/low level
        
        const sourceKey = poiTypes[Math.floor(Math.random() * poiTypes.length)];
        const source = DATA_SOURCES[sourceKey];
        
        const entity = viewer.entities.add({
          id: `poi-${i}`,
          position: Cesium.Cartesian3.fromDegrees(lon, lat, alt),
          point: {
            pixelSize: 4,
            color: Cesium.Color.fromCssColorString(source.color),
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 1
          },
          properties: {
            dataSource: sourceKey,
            name: `${source.label} #${i}`
          }
        });
        
        entities.push(entity);
      }
      
      return entities;
    }

    // Generate all data
    elements.generateBtn.addEventListener('click', () => {
      const pedestrianCount = parseInt(elements.pedestrianCount.value);
      const poiCount = parseInt(elements.poiCount.value);
      
      // Clear existing entities
      if (generatedEntities) {
        generatedEntities.forEach(e => viewer.entities.remove(e));
      }
      
      generatedEntities = [];
      
      // Generate pedestrian flow
      const pedestrians = generatePedestrianData(pedestrianCount);
      generatedEntities.push(...pedestrians);
      
      // Generate POIs
      const pois = generatePOIData(poiCount);
      generatedEntities.push(...pois);
      
      console.log(`Generated ${pedestrianCount} pedestrian points and ${poiCount} POIs`);
      console.log(`Total entities: ${generatedEntities.length}`);
      elements.createHeatmapBtn.disabled = false;
      
      // Display legend
      displayLegend();
    });

    // Create heatmap with custom keyResolver
    elements.createHeatmapBtn.addEventListener('click', async () => {
      if (!generatedEntities || generatedEntities.length === 0) {
        alert('Please generate data first');
        return;
      }
      
      // Clear existing heatbox
      if (heatbox) {
        heatbox.clear();
      }
      
      const aggregationEnabled = elements.enableAggregation.checked;
      const useSpatialId = elements.useSpatialId.checked;
      
      // Build heatbox options
      const heatboxOptions = {
        opacity: 0.6,
        showOutline: true,
        outlineWidth: 1,
        aggregation: {
          enabled: aggregationEnabled,
          // Heatbox resolves Cesium Property/PropertyBag automatically (v0.1.18)
          keyResolver: (entity) => {
            const sourceKey = entity.properties?.dataSource;
            const source = typeof sourceKey === 'string' ? sourceKey : sourceKey?.getValue?.(Cesium.JulianDate.now());
            if (typeof source === 'string') {
              if (source.startsWith('pedestrian')) {
                return 'pedestrian';
              }
              if (source.startsWith('poi')) {
                return 'poi';
              }
            }
            return 'unknown';
          },
          showInDescription: elements.showInDescription.checked,
          topN: 10 // Show top categories (pedestrian / poi)
        }
      };
      
      // Add spatial ID or voxel size configuration
      if (useSpatialId) {
        heatboxOptions.spatialId = {
          enabled: true,
          mode: 'tile-grid',
          zoom: parseInt(elements.zoomLevel.value),
          zoomControl: 'manual'
        };
      } else {
        heatboxOptions.voxelSize = parseInt(elements.voxelSize.value);
      }
      
      // Create heatbox with aggregation using keyResolver
      heatbox = new Heatbox(viewer, heatboxOptions);
      
      await heatbox.createFromEntities(generatedEntities);
      
      // Display statistics
      const stats = heatbox.getStatistics();
      displayStatistics(stats);
      
      console.log('Heatmap created with multi-source aggregation');
      console.log('Statistics:', stats);
      
      // Verify layer aggregation is working correctly
      if (aggregationEnabled && stats.layers) {
        console.log('=== Layer Aggregation Verification ===');
        console.log(`Total unique layers: ${stats.layers.length}`);
        stats.layers.forEach((layer, index) => {
          const source = DATA_SOURCES[layer.key];
          const label = source ? source.label : layer.key;
          const percentage = (layer.total / stats.totalEntities * 100).toFixed(1);
          console.log(`${index + 1}. ${label} (${layer.key}): ${layer.total} entities (${percentage}%)`);
        });
        
        // Verify totals match
        const layerTotal = stats.layers.reduce((sum, l) => sum + l.total, 0);
        console.log(`Sum of layer totals: ${layerTotal}`);
        console.log(`Total entities: ${stats.totalEntities}`);
        if (layerTotal === stats.totalEntities) {
          console.log('✓ Layer aggregation totals match!');
        } else {
          console.warn('⚠ Warning: Layer totals do not match total entities');
        }
      }
    });

    // Display statistics
    function displayStatistics(stats) {
      elements.statsPanel.style.display = 'block';
      
      // Basic stats
      elements.statsContent.innerHTML = `
        <table style="width: 100%; font-size: 0.9em;">
          <tr><td><b>Total Entities:</b></td><td>${stats.totalEntities}</td></tr>
          <tr><td><b>Rendered Voxels:</b></td><td>${stats.renderedVoxels}</td></tr>
          <tr><td><b>Non-empty Voxels:</b></td><td>${stats.nonEmptyVoxels}</td></tr>
          <tr><td><b>Avg Count/Voxel:</b></td><td>${stats.averageCount.toFixed(1)}</td></tr>
        </table>
      `;
      
      // Layer stats
      if (stats.layers && stats.layers.length > 0) {
        const categoryTotals = new Map(stats.layers.map(layer => [layer.key, layer.total]));
        const maxTotal = Math.max(...Array.from(categoryTotals.values()));

        // Build subcategory counts for each aggregated category
        const subCounts = {};
        if (Array.isArray(generatedEntities)) {
          generatedEntities.forEach((entity) => {
            const sourceKey = entity.properties?.dataSource;
            if (!sourceKey || typeof sourceKey !== 'string') {
              return;
            }

            let categoryKey = 'unknown';
            if (sourceKey.startsWith('pedestrian')) {
              categoryKey = 'pedestrian';
            } else if (sourceKey.startsWith('poi')) {
              categoryKey = 'poi';
            }

            if (!subCounts[categoryKey]) {
              subCounts[categoryKey] = {};
            }

            const label = DATA_SOURCES[sourceKey]?.label || sourceKey;
            subCounts[categoryKey][label] = (subCounts[categoryKey][label] || 0) + 1;
          });
        }

        let layerHtml = '<div style="font-size: 0.9em;">';
        stats.layers.forEach(layer => {
          const categoryDef = CATEGORY_DEFINITIONS[layer.key] || { label: layer.key, color: '#999' };
          const total = layer.total;
          const percentage = stats.totalEntities > 0 ? ((total / stats.totalEntities) * 100).toFixed(1) : '0.0';
          const barWidth = maxTotal > 0 ? ((total / maxTotal) * 100).toFixed(1) : '0';

          layerHtml += `
            <div style="margin-bottom: 12px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2px;">
                <span style="font-size: 0.85em;"><span style="display: inline-block; width: 12px; height: 12px; background: ${categoryDef.color}; margin-right: 5px;"></span>${categoryDef.label}</span>
                <span>${total} (${percentage}%)</span>
              </div>
              <div style="background: #eee; height: 8px; border-radius: 4px;">
                <div style="background: ${categoryDef.color}; height: 100%; width: ${barWidth}%; border-radius: 4px;"></div>
              </div>
          `;

          const subEntries = Object.entries(subCounts[layer.key] || {});
          if (subEntries.length > 0) {
            layerHtml += '<div style="margin-top: 6px; padding-left: 14px; font-size: 0.8em; color: #4b5563;">';
            subEntries.sort((a, b) => b[1] - a[1]).forEach(([label, count]) => {
              const subPercentage = total > 0 ? ((count / total) * 100).toFixed(1) : '0.0';
              layerHtml += `<div style="display: flex; justify-content: space-between; margin-bottom: 2px;"><span>${label}</span><span>${count} (${subPercentage}%)</span></div>`;
            });
            layerHtml += '</div>';
          }

          layerHtml += '</div>';
        });
        layerHtml += '</div>';

        elements.layerStats.innerHTML = layerHtml;
      } else {
        elements.layerStats.innerHTML = '<p style="color: #999; font-size: 0.9em;">Aggregation disabled</p>';
      }
    }

    // Display legend
    function displayLegend() {
      let legendHtml = '<div style="font-size: 0.85em;">';
      
      // Group by category
      const pedestrianSources = Object.entries(DATA_SOURCES).filter(([key]) => key.startsWith('pedestrian_'));
      const poiSources = Object.entries(DATA_SOURCES).filter(([key]) => key.startsWith('poi_'));
      
      legendHtml += '<p style="margin: 5px 0; font-weight: bold;">Pedestrian Flow:</p>';
      pedestrianSources.forEach(([key, source]) => {
        legendHtml += `
          <div style="margin: 3px 0;">
            <span style="display: inline-block; width: 10px; height: 10px; background: ${source.color}; margin-right: 5px;"></span>
            ${source.label}
          </div>
        `;
      });
      
      legendHtml += '<p style="margin: 10px 0 5px 0; font-weight: bold;">POI:</p>';
      poiSources.forEach(([key, source]) => {
        legendHtml += `
          <div style="margin: 3px 0;">
            <span style="display: inline-block; width: 10px; height: 10px; background: ${source.color}; margin-right: 5px;"></span>
            ${source.label}
          </div>
        `;
      });
      
      legendHtml += '</div>';
      elements.legend.innerHTML = legendHtml;
    }

    // Initialize
    elements.createHeatmapBtn.disabled = true;
    console.log('Multi-Source Aggregation Demo initialized');
    console.log('Click "Generate Data" to start');
  </script>
</body>
</html>
