<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cesium Heatbox - Emulation Scope Demo</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <link href="../../common/demo.css" rel="stylesheet">
  <script>
    window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/';
    if (typeof Cesium !== 'undefined' && Cesium.Ion) {
      Cesium.Ion.defaultAccessToken = null;
    }
  </script>
  <script src="../../common/camera.js"></script>
  <script src="https://unpkg.com/cesium-heatbox@latest/dist/cesium-heatbox.umd.min.js"></script>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div class="panel hb-panel">
    <span class="hb-badge">Outlines</span>
    <h2>Outline Emulation Scope</h2>
    <p>Switch outline render modes and emulation scopes around Shinjuku to see TopN effects.</p>
    <p>Compare how <strong>outlineRenderMode</strong> and <strong>emulationScope</strong> interact with TopN highlighting.</p>
    <div class="hb-group">
      <label for="renderMode">Outline Render Mode</label>
      <select id="renderMode">
        <option value="standard">standard</option>
        <option value="inset">inset</option>
        <option value="emulation-only">emulation-only</option>
      </select>
    </div>
    <div class="hb-group">
      <label for="emulationScope">Emulation Scope</label>
      <select id="emulationScope">
        <option value="off">off</option>
        <option value="topn">topn</option>
        <option value="non-topn">non-topn</option>
        <option value="all">all</option>
      </select>
    </div>
    <div class="hb-group">
      <label for="highlightTopN">Highlight Top N</label>
      <input type="number" id="highlightTopN" min="0" max="200" value="30">
    </div>
    <div class="hb-group">
      <label><input type="checkbox" id="adaptiveOutlines" checked> Adaptive Outlines</label>
      <label><input type="checkbox" id="thickFrames"> Enable Thick Frames</label>
    </div>
    <div class="hb-buttons">
      <button class="hb-btn hb-btn-primary" id="renderBtn">Render</button>
      <button class="hb-btn hb-btn-secondary" id="clearBtn">Clear</button>
    </div>
    <div id="status" class="hb-status">Ready - choose settings and click Render.</div>
  </div>

  <script>
    const Heatbox = window.CesiumHeatbox || window.Heatbox;
    const CameraHelper = window.HeatboxDemoCamera || null;
    const SHINJUKU_CENTER = { lon: 139.6917, lat: 35.6895 }; // 新宿駅中心 / Shinjuku station center
    const CAMERA_DEFAULTS = {
      headingDegrees: 0,
      pitchDegrees: -45,
      altitude: 2000,
      altitudeScale: 0.5,
      cameraLatOffset: -0.025  // カメラを南に移動して視界の中心にデータを収める
    };
    let viewer;
    let heatbox;
    let entities = [];

    function focusCameraView(config = {}) {
      if (!viewer || !viewer.camera) return;
      const { bounds, ...overrides } = config;
      const options = { ...CAMERA_DEFAULTS, ...overrides };

      if (CameraHelper?.focus) {
        CameraHelper.focus(viewer, bounds ? { bounds, ...options } : options);
        return;
      }

      if (bounds && CameraHelper?.getViewFromBounds) {
        const view = CameraHelper.getViewFromBounds(bounds, options) || CameraHelper.getDefaultView?.(options);
        if (view) {
          viewer.camera.setView(view);
        }
        return;
      }

      if (CameraHelper?.getDefaultView) {
        const fallbackView = CameraHelper.getDefaultView(options);
        if (fallbackView) {
          viewer.camera.setView(fallbackView);
        }
      }
    }

    function createImageryProvider() {
      return new Cesium.UrlTemplateImageryProvider({
        url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
        subdomains: 'abcd',
        maximumLevel: 19,
        credit: '© OpenStreetMap contributors © CARTO'
      });
    }

    function createTerrainProvider() {
      try {
        if (Cesium.Ion && Cesium.Ion.defaultAccessToken && Cesium.Ion.defaultAccessToken !== 'null') {
          return Cesium.createWorldTerrain();
        }
      } catch (error) {
        console.warn('World Terrain unavailable, using EllipsoidTerrainProvider.', error);
      }
      return new Cesium.EllipsoidTerrainProvider();
    }

    async function initViewer() {
      if (viewer) {
        return viewer;
      }
      const imageryProvider = createImageryProvider();
      viewer = new Cesium.Viewer('cesiumContainer', {
        imageryProvider,
        terrainProvider: createTerrainProvider(),
        homeButton: false,
        sceneModePicker: false,
        baseLayerPicker: false,
        navigationHelpButton: false,
        animation: false,
        timeline: false,
        fullscreenButton: false,
        geocoder: false,
        infoBox: true,
        selectionIndicator: true,
        creditContainer: document.createElement('div')
      });

      viewer.imageryLayers.removeAll();
      viewer.imageryLayers.addImageryProvider(imageryProvider);
      viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#0f172a');
      focusCameraView();
      return viewer;
    }

    function generateEntities() {
      const list = [];
      const clusters = [
        { lon: SHINJUKU_CENTER.lon, lat: SHINJUKU_CENTER.lat, n: 420 },
        { lon: SHINJUKU_CENTER.lon + 0.0018, lat: SHINJUKU_CENTER.lat - 0.0015, n: 320 },
        { lon: SHINJUKU_CENTER.lon - 0.0022, lat: SHINJUKU_CENTER.lat + 0.001, n: 260 }
      ];

      clusters.forEach(cluster => {
        for (let i = 0; i < cluster.n; i++) {
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.sqrt(Math.random()) * 0.0015;
          const lon = Cesium.Math.clamp(cluster.lon + Math.cos(angle) * radius, SHINJUKU_CENTER.lon - 0.008, SHINJUKU_CENTER.lon + 0.008);
          const lat = Cesium.Math.clamp(cluster.lat + Math.sin(angle) * radius, SHINJUKU_CENTER.lat - 0.008, SHINJUKU_CENTER.lat + 0.008);
          const alt = Math.random() * 160;
          list.push(viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(lon, lat, alt),
            point: {
              pixelSize: 4,
              color: Cesium.Color.YELLOW.withAlpha(0.7),
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 1
            }
          }));
        }
      });
      return list;
    }

    function clearScene() {
      if (heatbox) {
        heatbox.clear();
        heatbox = null;
      }
      viewer.entities.removeAll();
      entities = [];
    }

    function updateStatus(message, type = 'info') {
      const status = document.getElementById('status');
      status.textContent = message;
      status.style.color = type === 'error' ? '#f87171' : '#5eead4';
    }

    async function render() {
      try {
        updateStatus('Rendering...');
        if (!viewer) {
          await initViewer();
        }

        clearScene();
        entities = generateEntities();

        const renderMode = document.getElementById('renderMode').value;
        const emulationScope = document.getElementById('emulationScope').value;
        const highlightTopN = parseInt(document.getElementById('highlightTopN').value, 10) || 0;
        const adaptiveOutlines = document.getElementById('adaptiveOutlines').checked;
        const thickFrames = document.getElementById('thickFrames').checked;

        heatbox = new Heatbox(viewer, {
          outlineRenderMode: renderMode,
          emulationScope,
          highlightTopN,
          adaptiveOutlines,
          enableThickFrames: thickFrames,
          outlineInset: renderMode === 'inset' ? 2.0 : 0,
          outlineInsetMode: 'all',
          showOutline: true,
          opacity: 0.85,
          debug: true
        });

        const stats = await heatbox.createFromEntities(entities);
        const bounds = heatbox.getBounds?.();
        focusCameraView({ bounds });
        updateStatus(`Rendered: voxels=${stats.renderedVoxels}, emulation=${emulationScope}`);
      } catch (error) {
        console.error(error);
        updateStatus(`Error: ${error.message}`, 'error');
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await initViewer();
      document.getElementById('renderBtn').addEventListener('click', render);
      document.getElementById('clearBtn').addEventListener('click', () => {
        clearScene();
        updateStatus('Cleared scene.');
      });
      updateStatus('Ready - choose settings and click Render.');
    });
  </script>
</body>
</html>
