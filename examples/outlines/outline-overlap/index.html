<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Outline Overlap Mitigation Demo (v0.1.6.1)</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <link href="../../common/demo.css" rel="stylesheet">
  <script>
    window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/';
    if (typeof Cesium !== 'undefined' && Cesium.Ion) {
      Cesium.Ion.defaultAccessToken = null;
    }
  </script>
  <script src="../../common/camera.js"></script>
  <!-- UMD build of cesium-heatbox -->
  <script src="../../../dist/cesium-heatbox.umd.min.js"></script>
  <script>
    const Heatbox = window.CesiumHeatbox || window.Heatbox;
    const CameraHelper = window.HeatboxDemoCamera || null;
    const SHINJUKU_CENTER = { lon: 139.6917, lat: 35.6895 }; // 新宿駅中心 / Shinjuku station center
    const CAMERA_DEFAULTS = {
      headingDegrees: 18,
      pitchDegrees: -55,
      altitude: 13000,
      altitudeScale: 1.8
    };
    let viewer;
    let heatbox;
    let entities = [];

    function focusCameraView(config = {}) {
      if (!viewer || !viewer.camera) return;
      const { bounds, ...overrides } = config;
      const options = { ...CAMERA_DEFAULTS, ...overrides };

      if (CameraHelper?.focus) {
        CameraHelper.focus(viewer, bounds ? { bounds, ...options } : options);
        return;
      }

      if (bounds && CameraHelper?.getViewFromBounds) {
        const view = CameraHelper.getViewFromBounds(bounds, options) || CameraHelper.getDefaultView?.(options);
        if (view) {
          viewer.camera.setView(view);
        }
        return;
      }

      if (CameraHelper?.getDefaultView) {
        const fallbackView = CameraHelper.getDefaultView(options);
        if (fallbackView) {
          viewer.camera.setView(fallbackView);
        }
      }
    }

    function createImageryProvider() {
      return new Cesium.UrlTemplateImageryProvider({
        url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
        subdomains: 'abcd',
        maximumLevel: 19,
        credit: '© OpenStreetMap contributors © CARTO'
      });
    }

    function createTerrainProvider() {
      try {
        if (Cesium.Ion && Cesium.Ion.defaultAccessToken && Cesium.Ion.defaultAccessToken !== 'null') {
          return Cesium.createWorldTerrain();
        }
      } catch (error) {
        console.warn('World Terrain unavailable, using EllipsoidTerrainProvider.', error);
      }
      return new Cesium.EllipsoidTerrainProvider();
    }

    async function initViewer() {
      if (viewer) {
        return viewer;
      }
      const imageryProvider = createImageryProvider();
      viewer = new Cesium.Viewer('cesiumContainer', {
        imageryProvider,
        terrainProvider: createTerrainProvider(),
        homeButton: false, sceneModePicker: false, baseLayerPicker: false,
        navigationHelpButton: false, animation: false, timeline: false,
        fullscreenButton: false, geocoder: false, infoBox: true,
        selectionIndicator: true, creditContainer: document.createElement('div')
      });
      viewer.imageryLayers.removeAll();
      viewer.imageryLayers.addImageryProvider(imageryProvider);
      viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#0f172a');
      focusCameraView();
      return viewer;
    }

    function updateStatus(msg, color = 'white') {
      const el = document.getElementById('status');
      el.textContent = msg;
      el.style.color = color;
      console.log(msg);
    }

    function genClusteredEntities() {
      // 近接配置のクラスターを複数作り、枠線重なりが起きやすい条件を作る
      const list = [];
      const bounds = {
        minLon: SHINJUKU_CENTER.lon - 0.008,
        maxLon: SHINJUKU_CENTER.lon + 0.008,
        minLat: SHINJUKU_CENTER.lat - 0.008,
        maxLat: SHINJUKU_CENTER.lat + 0.008,
        minAlt: 0,
        maxAlt: 160
      };
      const clusters = [
        { lon: SHINJUKU_CENTER.lon, lat: SHINJUKU_CENTER.lat, n: 650 },
        { lon: SHINJUKU_CENTER.lon + 0.002, lat: SHINJUKU_CENTER.lat - 0.0015, n: 520 },
        { lon: SHINJUKU_CENTER.lon - 0.0025, lat: SHINJUKU_CENTER.lat + 0.0012, n: 420 }
      ];
      clusters.forEach(c => {
        for (let i = 0; i < c.n; i++) {
          const angle = Math.random() * Math.PI * 2;
          const r = Math.sqrt(Math.random()) * 0.0015; // 密なクラスター / Dense cluster radius
          const lon = Cesium.Math.clamp(c.lon + Math.cos(angle) * r, bounds.minLon, bounds.maxLon);
          const lat = Cesium.Math.clamp(c.lat + Math.sin(angle) * r, bounds.minLat, bounds.maxLat);
          const alt = Math.random() * bounds.maxAlt;
          list.push(viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(lon, lat, alt),
            point: { pixelSize: 3, color: Cesium.Color.YELLOW.withAlpha(0.7) }
          }));
        }
      });
      return list;
    }

    function getOptionsFromUI(withMitigation) {
      const voxelGap = parseFloat(document.getElementById('voxelGap').value);
      const outlineOpacity = parseFloat(document.getElementById('outlineOpacity').value);
      const adaptive = document.getElementById('adaptiveOutline').checked;
      const colorMap = document.getElementById('colorMap').value;
      // v0.1.6.1: インセット枠線
      const insetDistance = parseFloat(document.getElementById('insetDistance').value);
      const insetMode = document.getElementById('insetMode').value;

      // v0.1.10: プリセットベース適応制御（ADR-0008 Phase 4）
      let adaptiveOutlines = false;
      let outlineWidthPreset = 'uniform';
      if (adaptive && withMitigation) {
        adaptiveOutlines = true;
        outlineWidthPreset = 'adaptive-density'; // 密度適応型プリセット
      }

      if (!withMitigation) {
        return {
          voxelSize: 25,
          opacity: 0.7,
          showOutline: true,
          outlineWidth: 2,
          colorMap,
          highlightTopN: null,
          // v0.1.6.1: ベースラインでもインセット枠線を適用可能
          outlineInset: insetMode === 'off' ? 0 : insetDistance,
          outlineInsetMode: insetMode === 'off' ? 'all' : insetMode
        };
      }

      return {
        voxelSize: 25,
        opacity: 0.7,
        showOutline: true,
        outlineWidth: 2,
        colorMap,
        highlightTopN: 10,
        voxelGap,
        outlineOpacity,
        // v0.1.10: 新API（ADR-0008 Phase 4）
        adaptiveOutlines,
        outlineWidthPreset,
        // v0.1.6.1: インセット枠線
        outlineInset: insetMode === 'off' ? 0 : insetDistance,
        outlineInsetMode: insetMode === 'off' ? 'all' : insetMode
      };
    }

    async function renderBaseline() {
      clearAll();
      if (entities.length === 0) entities = genClusteredEntities();
      heatbox = new Heatbox(viewer, getOptionsFromUI(false));
      const stats = await heatbox.createFromEntities(entities);
      const bounds = heatbox.getBounds?.();
      focusCameraView({ bounds });
      updateStatus(`Baseline rendered: voxels=${stats.renderedVoxels}`);
    }

    async function renderMitigated() {
      clearAll();
      if (entities.length === 0) entities = genClusteredEntities();
      heatbox = new Heatbox(viewer, getOptionsFromUI(true));
      const stats = await heatbox.createFromEntities(entities);
      const bounds = heatbox.getBounds?.();
      focusCameraView({ bounds });
      updateStatus(`Mitigation rendered: voxels=${stats.renderedVoxels}`);
    }

    function clearAll() {
      if (heatbox) heatbox.clear();
      viewer.entities.removeAll();
      entities = [];
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await initViewer();
      // UI wiring
      document.getElementById('voxelGap').addEventListener('input', (e) => {
        document.getElementById('voxelGapVal').textContent = parseFloat(e.target.value).toFixed(1);
      });
      document.getElementById('outlineOpacity').addEventListener('input', (e) => {
        document.getElementById('outlineOpacityVal').textContent = parseFloat(e.target.value).toFixed(1);
      });
      // v0.1.6.1: インセット枠線のイベントリスナー
      document.getElementById('insetDistance').addEventListener('input', (e) => {
        document.getElementById('insetDistVal').textContent = parseFloat(e.target.value).toFixed(1);
      });
      document.getElementById('insetMode').addEventListener('change', (e) => {
        const isOff = e.target.value === 'off';
        document.getElementById('insetDistance').disabled = isOff;
        if (isOff) {
          document.getElementById('insetDistVal').textContent = '0.0';
        } else {
          document.getElementById('insetDistVal').textContent = parseFloat(document.getElementById('insetDistance').value).toFixed(1);
        }
      });
      // 初期状態設定
      document.getElementById('insetDistance').disabled = (document.getElementById('insetMode').value === 'off');
      
      document.getElementById('btnBaseline').addEventListener('click', renderBaseline);
      document.getElementById('btnMitigated').addEventListener('click', renderMitigated);
      document.getElementById('btnClear').addEventListener('click', () => { clearAll(); updateStatus('Cleared'); });
      updateStatus('Ready - v0.1.6.1 overlap mitigation + inset outline demo');
    });
  </script>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div class="panel hb-panel">
    <span class="hb-badge">v0.1.6.1</span>
    <h2>Outline Overlap Mitigation</h2>
    <p>Compare baseline and mitigated outlines for dense voxels around Shinjuku.</p>
    <div class="hb-group">
      <label>Color Map</label>
      <div class="hb-buttons">
        <select id="colorMap">
          <option value="custom">custom (min/max)</option>
          <option value="viridis" selected>viridis</option>
          <option value="inferno">inferno</option>
        </select>
      </div>
    </div>
    <div class="hb-group">
      <label>Voxel Gap (m): <span id="voxelGapVal" class="hb-slider-value">0.0</span></label>
      <div class="hb-buttons"><input type="range" id="voxelGap" min="0" max="5" step="0.5" value="0"></div>
      <small class="hint">ボクセル寸法を縮めて枠線の重なりを軽減</small>
    </div>
    <div class="hb-group">
      <label>Outline Opacity: <span id="outlineOpacityVal" class="hb-slider-value">1.0</span></label>
      <div class="hb-buttons"><input type="range" id="outlineOpacity" min="0.1" max="1.0" step="0.1" value="1.0"></div>
      <small class="hint">重なった枠線の視覚ノイズを低減</small>
    </div>
    <div class="hb-group">
      <label><input type="checkbox" id="adaptiveOutline"> Adaptive Outline</label>
      <small class="hint">密度に応じて枠線太さを調整（TopNは太く）</small>
    </div>
    <!-- v0.1.6.1: インセット枠線 -->
    <div class="hb-group" style="border-top: 1px solid #666; padding-top: 8px; margin-top: 12px;">
      <label style="color: #81c784; font-weight: 600;">v0.1.6.1 Inset Outline</label>
      <div style="margin: 6px 0;">
        <label>Inset Distance (m): <span id="insetDistVal" class="hb-slider-value">0.0</span></label>
        <div class="hb-buttons"><input type="range" id="insetDistance" min="0" max="8" step="0.5" value="0"></div>
      </div>
      <div style="margin: 6px 0;">
        <label>Inset Mode</label>
        <div class="hb-buttons">
          <select id="insetMode">
            <option value="off">OFF</option>
            <option value="topn">TopN のみ</option>
            <option value="all">全体</option>
          </select>
        </div>
      </div>
      <small class="hint">枠線を内側にオフセット。不透明塗りでは効果限定的</small>
    </div>
    <div class="hb-buttons">
      <button class="hb-btn hb-btn-secondary" id="btnBaseline">Baseline</button>
      <button class="hb-btn hb-btn-primary" id="btnMitigated">Mitigated</button>
    </div>
    <div class="hb-buttons">
      <button class="hb-btn hb-btn-danger" id="btnClear">Clear</button>
    </div>
    <div id="status" class="hb-status">Ready</div>
  </div>
</body>
</html>
