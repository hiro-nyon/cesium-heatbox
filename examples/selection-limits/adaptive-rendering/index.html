<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>CesiumJS Heatbox v0.1.9 - Adaptive Rendering Demo</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <link href="../../common/demo.css" rel="stylesheet">
    <script>
        window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/';
        if (typeof Cesium !== 'undefined' && Cesium.Ion) {
            Cesium.Ion.defaultAccessToken = null;
        }
    </script>
    <script src="../../common/camera.js"></script>
        <style>
        .hb-panel.right { left: auto; right: 20px; }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    
    <aside id="info" class="hb-panel right">
        <h3>ğŸš€ CesiumJS Heatbox v0.1.9</h3>
        <h4>Adaptive Rendering Demo</h4>
        <p><strong>æ–°æ©Ÿèƒ½:</strong></p>
        <ul>
            <li>ğŸ“Š <strong>Adaptive Rendering Limits</strong><br>
                Density, Coverage, Hybrid ã®3æˆ¦ç•¥</li>
            <li>ğŸ’» <strong>Auto Render Budget</strong><br>
                ãƒ‡ãƒã‚¤ã‚¹æ€§èƒ½ã«åŸºã¥ãè‡ªå‹•èª¿æ•´</li>
            <li>ğŸ“ <strong>Enhanced Auto Voxel Size</strong><br>
                å æœ‰ç‡ãƒ™ãƒ¼ã‚¹ã®æœ€é©åŒ–è¨ˆç®—</li>
            <li>ğŸ¯ <strong>Smart fitView</strong><br>
                å …ç‰¢ãªã‚«ãƒ¡ãƒ©ä½ç½®è¨ˆç®—</li>
        </ul>
        
        <p><strong>æ“ä½œæ–¹æ³•:</strong></p>
        <ol>
            <li>å·¦å´ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã§è¨­å®šå¤‰æ›´</li>
            <li>ã€ŒApply Settingsã€ã§å†æç”»</li>
            <li>ã€ŒShow Statsã€ã§çµ±è¨ˆæƒ…å ±è¡¨ç¤º</li>
            <li>ã€ŒFit Viewã€ã§ã‚«ãƒ¡ãƒ©èª¿æ•´</li>
        </ol>
        
        <p><em>ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ« (F12) ã§è©³ç´°ãƒ­ã‚°ã‚’ç¢ºèªã§ãã¾ã™ã€‚</em></p>
    </aside>
    
    <div id="status" class="hb-status">
        <div id="statusText">åˆæœŸåŒ–ä¸­...</div>
    </div>

    <script type="module">
        import { Heatbox } from '../../src/index.js';
        import { generateSampleData } from '../../src/utils/sampleData.js';
        
        // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        window.currentHeatbox = null;
        window.currentData = null;
        
        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°é–¢æ•°
        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
            console.log('ğŸ“± Status:', message);
        }

        const SHINJUKU_CENTER = { lon: 139.6917, lat: 35.6895 }; // æ–°å®¿é§…ä¸­å¿ƒ / Shinjuku station center
        const CameraHelper = window.HeatboxDemoCamera || null;
        const INITIAL_BOUNDS = {
            minLon: SHINJUKU_CENTER.lon - 0.012,
            maxLon: SHINJUKU_CENTER.lon + 0.012,
            minLat: SHINJUKU_CENTER.lat - 0.012,
            maxLat: SHINJUKU_CENTER.lat + 0.012,
            minAlt: 0,
            maxAlt: 240
        };

        function createImageryProvider() {
            return new Cesium.UrlTemplateImageryProvider({
                url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                subdomains: 'abcd',
                maximumLevel: 19,
                credit: 'Â© OpenStreetMap contributors Â© CARTO'
            });
        }

        function createTerrainProvider() {
            try {
                if (Cesium.Ion && Cesium.Ion.defaultAccessToken && Cesium.Ion.defaultAccessToken !== 'null') {
                    return Cesium.createWorldTerrain();
                }
            } catch (error) {
                console.warn('World Terrain unavailable, using EllipsoidTerrainProvider.', error);
            }
            return new Cesium.EllipsoidTerrainProvider();
        }

        function focusCameraView(viewerInstance, config = {}) {
            if (!viewerInstance || !viewerInstance.camera) return;
            const { bounds = null, useDefaultBounds = !config.bounds, ...overrides } = config;
            const helperDefaults = CameraHelper?.DEFAULT_OPTIONS ?? {};
            const focusOptions = { ...helperDefaults, ...overrides };

            if (CameraHelper?.focus) {
                CameraHelper.focus(viewerInstance, {
                    ...focusOptions,
                    bounds,
                    useDefaultBounds
                });
                return;
            }

            if (bounds && CameraHelper?.setViewToBounds) {
                CameraHelper.setViewToBounds(viewerInstance, bounds, focusOptions);
                return;
            }

            if (CameraHelper?.setViewToShinjuku) {
                CameraHelper.setViewToShinjuku(viewerInstance, { ...focusOptions, useDefaultBounds });
                return;
            }

            const targetBounds = bounds || (CameraHelper?.DEFAULT_BOUNDS ?? null);
            if (targetBounds) {
                const centerLon = (targetBounds.minLon + targetBounds.maxLon) / 2;
                const centerLat = (targetBounds.minLat + targetBounds.maxLat) / 2;
                viewerInstance.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, focusOptions.altitude),
                    orientation: {
                        heading: Cesium.Math.toRadians(focusOptions.headingDegrees),
                        pitch: Cesium.Math.toRadians(focusOptions.pitchDegrees),
                        roll: 0
                    }
                });
                return;
            }

            viewerInstance.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(
                    SHINJUKU_CENTER.lon,
                    SHINJUKU_CENTER.lat,
                    focusOptions.altitude
                ),
                orientation: {
                    heading: Cesium.Math.toRadians(focusOptions.headingDegrees),
                    pitch: Cesium.Math.toRadians(focusOptions.pitchDegrees),
                    roll: 0
                }
            });
        }

        // ã‚·ãƒ¼ãƒ³è¨­å®š
        const imageryProvider = createImageryProvider();
        const viewer = new Cesium.Viewer('cesiumContainer', {
            imageryProvider,
            terrainProvider: createTerrainProvider(),
            shouldAnimate: false,
            homeButton: false,
            sceneModePicker: false,
            baseLayerPicker: false,
            geocoder: false,
            navigationHelpButton: false,
            timeline: false,
            fullscreenButton: false
        });
        viewer.imageryLayers.removeAll();
        viewer.imageryLayers.addImageryProvider(imageryProvider);
        viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#0f172a');
        
        // æ–°å®¿é§…å‘¨è¾ºã«ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š / Focus camera on Shinjuku
        focusCameraView(viewer, { bounds: INITIAL_BOUNDS, useDefaultBounds: false });
        
        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ä½œæˆ
        function createControls() {
            const controlsHtml = `
                <div id="adaptiveControls">
                    <h3>ğŸš€ v0.1.9 Adaptive Controls</h3>
                    
                    <div class="hb-group">
                        <label>ğŸ¯ Render Strategy:</label>
                        <select id="strategySelect">
                            <option value="density">ğŸ”¥ Density-based (å¯†åº¦é‡è¦–)</option>
                            <option value="coverage">ğŸ—ºï¸ Coverage-based (ç¯„å›²é‡è¦–)</option>
                            <option value="hybrid" selected>âš–ï¸ Hybrid (ãƒãƒ©ãƒ³ã‚¹)</option>
                        </select>
                    </div>
                    
                    <div class="hb-group">
                        <label>ğŸ’» Max Render Voxels:</label>
                        <select id="budgetSelect">
                            <option value="auto" selected>ğŸ¤– Auto Budget</option>
                            <option value="3000">3,000 (è»½é‡)</option>
                            <option value="8000">8,000 (æ¨™æº–)</option>
                            <option value="15000">15,000 (é«˜æ€§èƒ½)</option>
                        </select>
                    </div>
                    
                    <div class="hb-group">
                        <label>ğŸ“ Auto Voxel Size Mode:</label>
                        <select id="voxelModeSelect">
                            <option value="simple">ğŸ“ Simple (v0.1.8)</option>
                            <option value="occupancy" selected>ğŸ¯ Occupancy (v0.1.9)</option>
                        </select>
                    </div>
                    
                    <div class="hb-group">
                        <label>ğŸ“Š Dataset Size:</label>
                        <select id="dataSizeSelect">
                            <option value="small">å°è¦æ¨¡ (5,000 entities)</option>
                            <option value="medium" selected>ä¸­è¦æ¨¡ (10,000 entities)</option>
                            <option value="large">å¤§è¦æ¨¡ (20,000 entities)</option>
                        </select>
                    </div>
                    
                    <button id="applySettings" class="hb-btn hb-btn-primary">âœ… Apply Settings</button>
                    <button id="fitViewBtn" class="hb-btn hb-btn-secondary">ğŸ¯ Fit View</button>
                    <button id="showStats" class="hb-btn hb-btn-secondary">ğŸ“Š Show Stats</button>
                    <button id="clearBtn" class="hb-btn hb-btn-danger">ğŸ—‘ï¸ Clear</button>
                </div>
            `;
            
            document.body.insertAdjacentHTML('afterbegin', controlsHtml);
            setupEventListeners();
        }
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        function setupEventListeners() {
            // Apply Settings
            document.getElementById('applySettings').addEventListener('click', async () => {
                updateStatus('è¨­å®šé©ç”¨ä¸­...');
                
                const strategy = document.getElementById('strategySelect').value;
                const budget = document.getElementById('budgetSelect').value;
                const voxelMode = document.getElementById('voxelModeSelect').value;
                const dataSize = document.getElementById('dataSizeSelect').value;
                
                try {
                    // æ—¢å­˜ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç ´æ£„
                    if (window.currentHeatbox) {
                        window.currentHeatbox.dispose();
                    }
                    
                    // ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã«å¿œã˜ã¦ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆç”Ÿæˆ
                    const entityCounts = { small: 5000, medium: 10000, large: 20000 };
                    const totalEntities = entityCounts[dataSize];
                    
                    window.currentData = generateSampleData(totalEntities, {
                        clusters: [
                            { center: [SHINJUKU_CENTER.lon, SHINJUKU_CENTER.lat, 60], radius: 0.006, density: 0.8, count: Math.floor(totalEntities * 0.4) },
                            { center: [SHINJUKU_CENTER.lon + 0.0025, SHINJUKU_CENTER.lat - 0.0015, 90], radius: 0.004, density: 0.6, count: Math.floor(totalEntities * 0.3) },
                            { center: [SHINJUKU_CENTER.lon - 0.002, SHINJUKU_CENTER.lat + 0.002, 40], radius: 0.005, density: 0.4, count: Math.floor(totalEntities * 0.2) },
                            { center: [SHINJUKU_CENTER.lon + 0.004, SHINJUKU_CENTER.lat + 0.001, 120], radius: 0.003, density: 0.7, count: Math.floor(totalEntities * 0.1) }
                        ]
                    });
                    
                    // æ–°ã—ã„è¨­å®šã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
                    window.currentHeatbox = new Heatbox(viewer, {
                        autoVoxelSize: true,
                        autoVoxelSizeMode: voxelMode,
                        renderLimitStrategy: strategy,
                        maxRenderVoxels: budget === 'auto' ? 'auto' : parseInt(budget),
                        debug: true
                    });
                    
                    // ãƒ‡ãƒ¼ã‚¿è¨­å®š
                    const startTime = performance.now();
                    await window.currentHeatbox.setData(window.currentData);
                    const loadTime = performance.now() - startTime;
                    
                    // çµ±è¨ˆæƒ…å ±å–å¾—
                   const stats = window.currentHeatbox.getStatistics();
                   const bounds = window.currentHeatbox.getBounds?.();
                    focusCameraView(viewer, { bounds, useDefaultBounds: false });
                    
                    updateStatus(`âœ… å®Œäº† (${loadTime.toFixed(0)}ms) | ${stats.selectionStrategy} | ${stats.renderedVoxels}/${stats.totalVoxels} voxels`);
                    
                    console.log('ğŸ“Š Applied Settings:', {
                        strategy, budget, voxelMode, dataSize,
                        loadTime: `${loadTime.toFixed(0)}ms`,
                        stats
                    });
                    
                } catch (error) {
                    console.error('âŒ Error applying settings:', error);
                    updateStatus(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            });
            
            // Fit View
            document.getElementById('fitViewBtn').addEventListener('click', async () => {
                if (window.currentHeatbox) {
                    try {
                        updateStatus('Fit viewå®Ÿè¡Œä¸­...');
                        await window.currentHeatbox.fitView();
                        updateStatus('âœ… Fit viewå®Œäº†');
                        console.log('âœ… Fit view completed');
                    } catch (error) {
                        console.error('âŒ Fit view error:', error);
                        updateStatus(`âŒ Fit viewã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    }
                }
            });
            
            // Show Stats
            document.getElementById('showStats').addEventListener('click', () => {
                if (window.currentHeatbox) {
                    const stats = window.currentHeatbox.getStatistics();
                    const debugInfo = window.currentHeatbox.getDebugInfo();
                    
                    console.log('ğŸ“Š Current Statistics:', stats);
                    console.log('ğŸ” Debug Info:', debugInfo);
                    
                    // è©³ç´°ãªçµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º
                    const deviceInfo = debugInfo.autoRenderBudget || {};
                    alert(`
ğŸ“Š Heatbox Statistics (v0.1.9)

ğŸ¯ Strategy: ${stats.selectionStrategy}
ğŸ’» Device Tier: ${stats.renderBudgetTier || 'Manual'}
ğŸ›ï¸ Max Render Voxels: ${stats.autoMaxRenderVoxels || stats.maxRenderVoxels || 'N/A'}
ğŸ¨ Rendered Voxels: ${stats.renderedVoxels}
ğŸ“ˆ Total Voxels: ${stats.totalVoxels}
ğŸ“Š Coverage Ratio: ${((stats.coverageRatio || 0) * 100).toFixed(1)}%
âœ‚ï¸ Clipped (Non-empty): ${stats.clippedNonEmpty || 0}

ğŸ“ Final Voxel Size: ${stats.finalVoxelSize || stats.voxelSize}m
ğŸ”„ Auto Adjusted: ${stats.autoAdjusted || false}
ğŸ“ Adjustment Reason: ${stats.adjustmentReason || 'N/A'}

ğŸ’¾ Device Memory: ${deviceInfo.deviceMemory || 'N/A'} GB
âš™ï¸ Hardware Cores: ${deviceInfo.hardwareConcurrency || 'N/A'}
ğŸ–¥ï¸ Screen Resolution: ${deviceInfo.screenWidth}x${deviceInfo.screenHeight}
                    `);
                    
                    updateStatus(`ğŸ“Š çµ±è¨ˆæƒ…å ±è¡¨ç¤º: ${stats.renderedVoxels}/${stats.totalVoxels} voxels`);
                } else {
                    alert('âŒ ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã¾ãšã€ŒApply Settingsã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
                }
            });
            
            // Clear
            document.getElementById('clearBtn').addEventListener('click', () => {
                if (window.currentHeatbox) {
                    window.currentHeatbox.dispose();
                    window.currentHeatbox = null;
                    updateStatus('ğŸ—‘ï¸ ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢å®Œäº†');
                    console.log('ğŸ—‘ï¸ Heatbox cleared');
                }
            });
        }
        
        // è‡ªå‹•ãƒ‡ãƒ¢å®Ÿè¡Œ
        async function runAutoDemo() {
            updateStatus('è‡ªå‹•ãƒ‡ãƒ¢å®Ÿè¡Œä¸­...');
            
            try {
                // ä¸­è¦æ¨¡ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã§åˆæœŸåŒ–
                document.getElementById('applySettings').click();
                
                // 3ç§’å¾Œã«fitViewå®Ÿè¡Œ
                setTimeout(() => {
                    document.getElementById('fitViewBtn').click();
                }, 3000);
                
            } catch (error) {
                console.error('âŒ Auto demo error:', error);
                updateStatus(`âŒ è‡ªå‹•ãƒ‡ãƒ¢ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }
        
        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            createControls();
            
            // 3ç§’å¾Œã«è‡ªå‹•ãƒ‡ãƒ¢é–‹å§‹
            setTimeout(runAutoDemo, 1000);
        });
        
        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        window.addEventListener('error', (event) => {
            console.error('âŒ Global error:', event.error);
            updateStatus(`âŒ ã‚¨ãƒ©ãƒ¼: ${event.error?.message || 'Unknown error'}`);
        });
        
        console.log('ğŸš€ CesiumJS Heatbox v0.1.9 Adaptive Rendering Demo loaded');
    </script>
</body>
</html>
