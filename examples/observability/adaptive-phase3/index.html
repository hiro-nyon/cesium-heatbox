<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>CesiumJS Heatbox - Adaptive Control Phase 3 Demo (ADR-0011)</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <link href="../../common/demo.css" rel="stylesheet">
    <script>
        window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/';
        if (typeof Cesium !== 'undefined' && Cesium.Ion) {
            Cesium.Ion.defaultAccessToken = null;
        }
    </script>
    <script src="https://unpkg.com/cesium-heatbox@latest/dist/cesium-heatbox.umd.min.js"></script>
    <style>
        .info { background: rgba(59, 130, 246, 0.16); border-left: 3px solid rgba(59, 130, 246, 0.45); padding: 10px; border-radius: 10px; font-size: 12px; line-height: 1.5; }
        .warning { background: rgba(239, 68, 68, 0.18); border-left: 3px solid rgba(248, 113, 113, 0.45); padding: 10px; border-radius: 10px; font-size: 12px; line-height: 1.5; color: #fecaca; }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    
    <div id="controls" class="hb-panel">
        <span class="hb-badge">ADR-0011 Phase 3</span>
        <h2>Adaptive Control Demo</h2>
        <p>Generate patterned datasets around Shinjuku and adjust adaptive parameters for overlap handling.</p>
        
        <h4>üéØ Density Pattern</h4>
        <div class="hb-group">
            <label>Pattern Type:</label>
            <select id="patternSelect">
                <option value="clustered">Clustered (Dense)</option>
                <option value="scattered">Scattered (Sparse)</option>
                <option value="gradient">Gradient</option>
                <option value="mixed" selected>Mixed</option>
            </select>
        </div>
        
        <div class="hb-group">
            <label>Entity Count: <span class="hb-slider-value" id="countLabel">1000</span></label>
            <input type="range" id="countSlider" min="100" max="3000" value="1000" step="100">
        </div>
        
        <h4>‚öôÔ∏è Adaptive Parameters</h4>
        <div class="hb-group">
            <label>
                <input type="checkbox" id="zScaleCompensation" checked>
                Z-Axis Scale Compensation
            </label>
            <label>
                <input type="checkbox" id="overlapDetection" checked>
                Overlap Detection
            </label>
            <label>
                <input type="checkbox" id="adaptiveOutlines" checked>
                Adaptive Outlines
            </label>
        </div>
        
        <div class="hb-group">
            <label>Outline Render Mode:</label>
            <select id="renderModeSelect">
                <option value="standard">Standard</option>
                <option value="inset">Inset</option>
                <option value="emulation-only" selected>Emulation Only</option>
            </select>
        </div>
        
        <div class="hb-group">
            <label>Outline Preset:</label>
            <select id="presetSelect">
                <option value="thin">Thin</option>
                <option value="medium">Medium</option>
                <option value="thick">Thick</option>
                <option value="adaptive" selected>Adaptive</option>
            </select>
        </div>
        
        <div class="hb-group">
            <label>Density Threshold: <span class="hb-slider-value" id="densityThresholdLabel">3</span></label>
            <input type="range" id="densityThresholdSlider" min="1" max="10" value="3" step="1">
        </div>
        
        <div class="hb-group">
            <label>Neighborhood Radius: <span class="hb-slider-value" id="neighborhoodRadiusLabel">30</span></label>
            <input type="range" id="neighborhoodRadiusSlider" min="10" max="100" value="30" step="10">
        </div>
        
        <h4>üöÄ Actions</h4>
        <div class="hb-buttons">
            <button id="generateBtn" class="hb-btn hb-btn-primary">Generate Data</button>
            <button id="overlayBtn" class="hb-btn hb-btn-secondary">Show Overlay</button>
        </div>
        <div class="hb-buttons">
            <button id="clearBtn" class="hb-btn hb-btn-danger">Clear</button>
            <button id="benchmarkBtn" class="hb-btn hb-btn-secondary">Benchmark</button>
        </div>
        
        <div class="hb-info-box info">
            <strong>üìò Phase 3 Features:</strong><br>
            ‚Ä¢ Enhanced performance overlay with adaptive metrics<br>
            ‚Ä¢ Density pattern generation (clustered/scattered/gradient/mixed)<br>
            ‚Ä¢ Real-time Z-scale compensation<br>
            ‚Ä¢ Overlap detection and auto-mode recommendation<br>
            ‚Ä¢ Adaptive parameter fine-tuning
        </div>
        
        <div class="hb-info-box warning">
            <strong>‚ö†Ô∏è Note:</strong> Performance overlay shows adaptive control statistics including dense area detection, emulation usage, and overlap counts.
        </div>
    </div>

    <script type="module">
        // This demo requires the UMD build or ESM build of Heatbox
        const Heatbox = window.CesiumHeatbox || window.Heatbox;
        
        if (!Heatbox) {
            alert('Heatbox library not found. Please ensure the library is loaded.');
        }

        const SHINJUKU_CENTER = { lon: 139.6917, lat: 35.6895 }; // Êñ∞ÂÆøÈßÖ‰∏≠ÂøÉ / Shinjuku station center

        function createImageryProvider() {
            return new Cesium.UrlTemplateImageryProvider({
                url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                subdomains: 'abcd',
                maximumLevel: 19,
                credit: '¬© OpenStreetMap contributors ¬© CARTO'
            });
        }

        function createTerrainProvider() {
            try {
                if (Cesium.Ion && Cesium.Ion.defaultAccessToken && Cesium.Ion.defaultAccessToken !== 'null') {
                    return Cesium.createWorldTerrain();
                }
            } catch (error) {
                console.warn('World Terrain unavailable, falling back to EllipsoidTerrainProvider.', error);
            }
            return new Cesium.EllipsoidTerrainProvider();
        }

        // Initialize Cesium viewer
        const imageryProvider = createImageryProvider();
        const viewer = new Cesium.Viewer('cesiumContainer', {
            imageryProvider,
            terrainProvider: createTerrainProvider(),
            timeline: false,
            animation: false,
            baseLayerPicker: false,
            geocoder: false,
            navigationHelpButton: false,
            sceneModePicker: false
        });
        viewer.imageryLayers.removeAll();
        viewer.imageryLayers.addImageryProvider(imageryProvider);
        viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#0f172a');
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(SHINJUKU_CENTER.lon, SHINJUKU_CENTER.lat, 12000),
            orientation: {
                heading: 0,
                pitch: -Cesium.Math.PI_OVER_FOUR,
                roll: 0
            }
        });

        // Global state
        let heatbox = null;
        let currentEntities = [];
        
        // DOM elements
        const patternSelect = document.getElementById('patternSelect');
        const countSlider = document.getElementById('countSlider');
        const countLabel = document.getElementById('countLabel');
        const zScaleCompensationCheck = document.getElementById('zScaleCompensation');
        const overlapDetectionCheck = document.getElementById('overlapDetection');
        const adaptiveOutlinesCheck = document.getElementById('adaptiveOutlines');
        const renderModeSelect = document.getElementById('renderModeSelect');
        const presetSelect = document.getElementById('presetSelect');
        const densityThresholdSlider = document.getElementById('densityThresholdSlider');
        const densityThresholdLabel = document.getElementById('densityThresholdLabel');
        const neighborhoodRadiusSlider = document.getElementById('neighborhoodRadiusSlider');
        const neighborhoodRadiusLabel = document.getElementById('neighborhoodRadiusLabel');
        const generateBtn = document.getElementById('generateBtn');
        const overlayBtn = document.getElementById('overlayBtn');
        const clearBtn = document.getElementById('clearBtn');
        const benchmarkBtn = document.getElementById('benchmarkBtn');

        // Update value labels
        countSlider.addEventListener('input', () => {
            countLabel.textContent = countSlider.value;
        });
        
        densityThresholdSlider.addEventListener('input', () => {
            densityThresholdLabel.textContent = densityThresholdSlider.value;
        });
        
        neighborhoodRadiusSlider.addEventListener('input', () => {
            neighborhoodRadiusLabel.textContent = neighborhoodRadiusSlider.value;
        });

        // Generate sample data using density patterns
        function generateData(pattern, count) {
            const bounds = {
                minLon: SHINJUKU_CENTER.lon - 0.012,
                maxLon: SHINJUKU_CENTER.lon + 0.012,
                minLat: SHINJUKU_CENTER.lat - 0.012,
                maxLat: SHINJUKU_CENTER.lat + 0.012,
                minAlt: 0,
                maxAlt: 180
            };

            // Êñ∞ÂÆøÈßÖÂë®Ëæ∫„ÅÆ„Éë„Çø„Éº„É≥„Éá„Éº„Çø„ÇíÁîüÊàê / Generate patterned data around Shinjuku
            let positions = [];
            
            switch (pattern) {
                case 'clustered':
                    positions = generateClusteredPositions(bounds, count, 3);
                    break;
                case 'scattered':
                    positions = generateScatteredPositions(bounds, count);
                    break;
                case 'gradient':
                    positions = generateGradientPositions(bounds, count);
                    break;
                case 'mixed':
                    positions = generateMixedPositions(bounds, count);
                    break;
            }

            const entities = positions.map((pos, idx) => {
                return viewer.entities.add({
                    id: `entity-${pattern}-${idx}-${Date.now()}`,
                    position: Cesium.Cartesian3.fromDegrees(pos.lon, pos.lat, pos.alt),
                    point: { pixelSize: 1, show: false }
                });
            });

            return entities;
        }

        function generateClusteredPositions(bounds, count, clusterCount = 3) {
            const positions = [];
            const entitiesPerCluster = Math.floor(count / clusterCount);
            
            for (let c = 0; c < clusterCount; c++) {
                const centerLon = bounds.minLon + Math.random() * (bounds.maxLon - bounds.minLon);
                const centerLat = bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat);
                const centerAlt = bounds.minAlt + Math.random() * (bounds.maxAlt - bounds.minAlt);
                const radius = 0.005; // Á¥Ñ500m„ÅÆ„ÇØ„É©„Çπ„Çø„ÉºÂçäÂæÑ / ~500 m cluster radius
                
                const clusterSize = c < clusterCount - 1 ? entitiesPerCluster : (count - positions.length);
                
                for (let i = 0; i < clusterSize; i++) {
                    const r = Math.sqrt(Math.random()) * radius;
                    const theta = Math.random() * Math.PI * 2;
                    
                    positions.push({
                        lon: Cesium.Math.clamp(centerLon + r * Math.cos(theta), bounds.minLon, bounds.maxLon),
                        lat: Cesium.Math.clamp(centerLat + r * Math.sin(theta), bounds.minLat, bounds.maxLat),
                        alt: Math.max(bounds.minAlt, Math.min(bounds.maxAlt, centerAlt + (Math.random() - 0.5) * 30))
                    });
                }
            }
            
            return positions;
        }

        function generateScatteredPositions(bounds, count) {
            const positions = [];
            
            for (let i = 0; i < count; i++) {
                positions.push({
                    lon: bounds.minLon + Math.random() * (bounds.maxLon - bounds.minLon),
                    lat: bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat),
                    alt: bounds.minAlt + Math.random() * (bounds.maxAlt - bounds.minAlt)
                });
            }
            
            return positions;
        }

        function generateGradientPositions(bounds, count) {
            const positions = [];
            
            for (let i = 0; i < count; i++) {
                const x = Math.random();
                const densityWeight = x * x; // Quadratic gradient
                
                positions.push({
                    lon: bounds.minLon + x * (bounds.maxLon - bounds.minLon),
                    lat: bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat),
                    alt: bounds.minAlt + Math.random() * (bounds.maxAlt - bounds.minAlt)
                });
                
                // Add extra entities in high-density areas
                if (densityWeight > 0.7 && Math.random() > 0.5) {
                    const offset = 0.0015;
                    positions.push({
                        lon: Cesium.Math.clamp(positions[positions.length - 1].lon + (Math.random() - 0.5) * offset, bounds.minLon, bounds.maxLon),
                        lat: Cesium.Math.clamp(positions[positions.length - 1].lat + (Math.random() - 0.5) * offset, bounds.minLat, bounds.maxLat),
                        alt: positions[positions.length - 1].alt
                    });
                }
            }
            
            return positions;
        }

        function generateMixedPositions(bounds, count) {
            const clusteredCount = Math.floor(count * 0.4);
            const scatteredCount = count - clusteredCount;
            
            return [
                ...generateClusteredPositions(bounds, clusteredCount, 2),
                ...generateScatteredPositions(bounds, scatteredCount)
            ];
        }

        // Initialize Heatbox with current parameters
        function initializeHeatbox() {
            const options = {
                adaptiveOutlines: adaptiveOutlinesCheck.checked,
                outlineRenderMode: renderModeSelect.value,
                outlineWidthPreset: presetSelect.value,
                adaptiveParams: {
                    zScaleCompensation: zScaleCompensationCheck.checked,
                    overlapDetection: overlapDetectionCheck.checked,
                    densityThreshold: parseInt(densityThresholdSlider.value),
                    neighborhoodRadius: parseInt(neighborhoodRadiusSlider.value)
                },
                performanceOverlay: {
                    enabled: true,
                    position: 'top-right',
                    autoShow: false
                }
            };

            if (heatbox) {
                heatbox.clear();
            }

            try {
                heatbox = new Heatbox(viewer, options);
                console.log('Heatbox initialized with options:', options);
            } catch (error) {
                console.error('Failed to initialize Heatbox:', error);
                alert('Failed to initialize Heatbox. See console for details.');
            }
        }

        // Event handlers
        generateBtn.addEventListener('click', () => {
            const pattern = patternSelect.value;
            const count = parseInt(countSlider.value);
            
            console.log(`Generating ${count} entities with ${pattern} pattern...`);
            
            // Clear existing entities
            if (currentEntities.length > 0) {
                currentEntities.forEach(entity => viewer.entities.remove(entity));
                currentEntities = [];
            }
            
            // Re-initialize heatbox with current parameters
            initializeHeatbox();
            
            // Generate new data
            const startTime = performance.now();
            currentEntities = generateData(pattern, count);
            
            if (heatbox) {
                heatbox.setData(currentEntities);
                const endTime = performance.now();
                
                console.log(`Data generated and processed in ${(endTime - startTime).toFixed(2)}ms`);
                console.log('Statistics:', heatbox.getStatistics());
                
                // Fit view to data
                setTimeout(() => {
                    if (heatbox.fitView) {
                        heatbox.fitView({ paddingPercent: 0.15 });
                    }
                }, 100);
            }
        });

        overlayBtn.addEventListener('click', () => {
            if (heatbox) {
                const isVisible = heatbox.togglePerformanceOverlay();
                overlayBtn.textContent = isVisible ? 'Hide Overlay' : 'Show Overlay';
            }
        });

        clearBtn.addEventListener('click', () => {
            if (heatbox) {
                heatbox.clear();
            }
            
            if (currentEntities.length > 0) {
                currentEntities.forEach(entity => viewer.entities.remove(entity));
                currentEntities = [];
            }
            
            console.log('Data cleared');
        });

        benchmarkBtn.addEventListener('click', () => {
            if (!heatbox || currentEntities.length === 0) {
                alert('Please generate data first');
                return;
            }

            console.log('Running benchmark...');
            const iterations = 5;
            const results = [];

            for (let i = 0; i < iterations; i++) {
                heatbox.clear();
                const start = performance.now();
                heatbox.setData(currentEntities);
                const end = performance.now();
                results.push(end - start);
            }

            const avg = results.reduce((a, b) => a + b, 0) / results.length;
            const min = Math.min(...results);
            const max = Math.max(...results);
            const stats = heatbox.getStatistics();

            console.log('Benchmark Results:');
            console.log(`  Pattern: ${patternSelect.value}`);
            console.log(`  Entities: ${currentEntities.length}`);
            console.log(`  Average: ${avg.toFixed(2)}ms`);
            console.log(`  Min: ${min.toFixed(2)}ms`);
            console.log(`  Max: ${max.toFixed(2)}ms`);
            console.log(`  Rendered Voxels: ${stats.renderedVoxels}/${stats.totalVoxels}`);
            
            if (stats.adaptive) {
                console.log('  Adaptive Stats:', stats.adaptive);
            }

            alert(`Benchmark Complete!\n` +
                  `Pattern: ${patternSelect.value}\n` +
                  `Average: ${avg.toFixed(2)}ms\n` +
                  `Rendered: ${stats.renderedVoxels}/${stats.totalVoxels} voxels`);
        });

        // Initialize on load
        window.addEventListener('load', () => {
            initializeHeatbox();
            
            // Auto-generate initial data
            setTimeout(() => {
                generateBtn.click();
            }, 500);
        });
    </script>
</body>
</html>
