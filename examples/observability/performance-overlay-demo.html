<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>CesiumJS Heatbox - Performance Overlay Demo</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <script>
        window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/';
        if (typeof Cesium !== 'undefined' && Cesium.Ion) {
            Cesium.Ion.defaultAccessToken = null; // Disable Ion by default to avoid black screens
        }
    </script>
    <script src="https://unpkg.com/cesium-heatbox@latest/dist/cesium-heatbox.umd.min.js"></script>
    <style>
        html, body, #cesiumContainer {
            width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(42, 42, 42, 0.8);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-family: sans-serif;
            font-size: 14px;
            z-index: 100;
            max-width: 300px;
        }
        
        #controls h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button.secondary {
            background: #2196F3;
        }
        
        button.secondary:hover {
            background: #1976D2;
        }
        
        select, input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }
        
        .info {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 3px;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    
    <div id="controls">
        <h3>ðŸš€ Performance Overlay Demo</h3>
        
        <div class="control-group">
            <label>Profile:</label>
            <select id="profileSelect">
                <option value="none">No Profile</option>
                <option value="mobile-fast">Mobile Fast</option>
                <option value="desktop-balanced" selected>Desktop Balanced</option>
                <option value="dense-data">Dense Data</option>
                <option value="sparse-data">Sparse Data</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Voxel Count: <span id="voxelCountLabel">1000</span></label>
            <input type="range" id="voxelCountSlider" min="100" max="5000" value="1000" step="100">
        </div>
        
        <div class="control-row">
            <button id="generateData">Generate Data</button>
            <button id="toggleOverlay" class="secondary">Show Overlay</button>
        </div>
        
        <div class="control-row">
            <button id="clearData">Clear</button>
            <button id="runBenchmark">Benchmark</button>
        </div>
        
        <div class="info">
            <div><strong>Instructions:</strong></div>
            <div>â€¢ Select a profile to optimize for different scenarios</div>
            <div>â€¢ Adjust voxel count to test performance</div>
            <div>â€¢ Toggle overlay to see real-time stats</div>
            <div>â€¢ Run benchmark for detailed analysis</div>
        </div>
    </div>

    <script type="module">
        // Import Heatbox (assuming UMD build)
        const Heatbox = window.CesiumHeatbox || window.Heatbox;

        function createImageryProvider() {
            return new Cesium.UrlTemplateImageryProvider({
                url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                subdomains: 'abcd',
                credit: 'Â© OpenStreetMap contributors Â© CARTO'
            });
        }

        function createTerrainProvider() {
            try {
                if (Cesium.Ion && Cesium.Ion.defaultAccessToken && Cesium.Ion.defaultAccessToken !== 'null') {
                    return Cesium.createWorldTerrain();
                }
            } catch (error) {
                console.warn('World Terrain unavailable, falling back to EllipsoidTerrainProvider:', error);
            }
            return new Cesium.EllipsoidTerrainProvider();
        }

        // Initialize Cesium viewer
        const viewer = new Cesium.Viewer('cesiumContainer', {
            imageryProvider: createImageryProvider(),
            terrainProvider: createTerrainProvider(),
            baseLayerPicker: false,
            timeline: false,
            animation: false,
            geocoder: false,
            navigationHelpButton: false
        });

        // Global state
        let heatbox = null;
        let currentData = [];
        
        // DOM elements
        const profileSelect = document.getElementById('profileSelect');
        const voxelCountSlider = document.getElementById('voxelCountSlider');
        const voxelCountLabel = document.getElementById('voxelCountLabel');
        const generateDataBtn = document.getElementById('generateData');
        const toggleOverlayBtn = document.getElementById('toggleOverlay');
        const clearDataBtn = document.getElementById('clearData');
        const runBenchmarkBtn = document.getElementById('runBenchmark');

        // Update voxel count label
        voxelCountSlider.addEventListener('input', () => {
            voxelCountLabel.textContent = voxelCountSlider.value;
        });

        // Initialize Heatbox with performance overlay enabled
        function initializeHeatbox() {
            const profile = profileSelect.value === 'none' ? undefined : profileSelect.value;
            
            const options = {
                profile,
                performanceOverlay: {
                    enabled: true,
                    position: 'top-right',
                    autoShow: false
                },
                debug: true
            };

            if (heatbox) {
                heatbox.clear();
            }

            try {
                heatbox = new Heatbox(viewer, options);
                console.log('Heatbox initialized with profile:', profile);
                console.log('Available profiles:', Heatbox.listProfiles());
            } catch (error) {
                console.error('Failed to initialize Heatbox:', error);
                alert('Failed to initialize Heatbox. Check console for details.');
            }
        }

        // Generate test data
        function generateTestData(count) {
            const entities = [];
            const bounds = {
                minLon: 139.5,
                maxLon: 139.8,
                minLat: 35.5,
                maxLat: 35.8,
                minAlt: 0,
                maxAlt: 200
            };

            for (let i = 0; i < count; i++) {
                const lon = bounds.minLon + Math.random() * (bounds.maxLon - bounds.minLon);
                const lat = bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat);
                const alt = bounds.minAlt + Math.random() * (bounds.maxAlt - bounds.minAlt);
                
                // Create clustering for more realistic data
                if (Math.random() < 0.3) {
                    // Create cluster center
                    const centerLon = bounds.minLon + Math.random() * (bounds.maxLon - bounds.minLon);
                    const centerLat = bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat);
                    
                    // Add points around cluster
                    for (let j = 0; j < 5 && entities.length < count; j++) {
                        const clusterLon = centerLon + (Math.random() - 0.5) * 0.01;
                        const clusterLat = centerLat + (Math.random() - 0.5) * 0.01;
                        
                        entities.push(viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(clusterLon, clusterLat, alt),
                            point: {
                                pixelSize: 1,
                                show: false
                            },
                            properties: {
                                value: Math.random() * 100 + 50 // Higher values for clusters
                            }
                        }));
                    }
                } else {
                    entities.push(viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(lon, lat, alt),
                        point: {
                            pixelSize: 1,
                            show: false
                        },
                        properties: {
                            value: Math.random() * 100
                        }
                    }));
                }
            }

            return entities.slice(0, count);
        }

        // Event handlers
        profileSelect.addEventListener('change', () => {
            initializeHeatbox();
        });

        generateDataBtn.addEventListener('click', () => {
            const count = parseInt(voxelCountSlider.value);
            console.log(`Generating ${count} data points...`);
            
            // Clear existing data
            if (currentData.length > 0) {
                currentData.forEach(entity => viewer.entities.remove(entity));
            }
            
            // Generate new data
            currentData = generateTestData(count);
            
            if (heatbox) {
                const startTime = performance.now();
                heatbox.setData(currentData);
                const endTime = performance.now();
                
                console.log(`Data processed in ${(endTime - startTime).toFixed(2)}ms`);
                
                // Fit view to data
                if (heatbox.fitView) {
                    setTimeout(() => {
                        heatbox.fitView({
                            paddingPercent: 0.1,
                            pitchDegrees: -45,
                            headingDegrees: 0
                        });
                    }, 100);
                }
            }
        });

        toggleOverlayBtn.addEventListener('click', () => {
            if (heatbox) {
                const isVisible = heatbox.togglePerformanceOverlay();
                toggleOverlayBtn.textContent = isVisible ? 'Hide Overlay' : 'Show Overlay';
            }
        });

        clearDataBtn.addEventListener('click', () => {
            if (heatbox) {
                heatbox.clear();
            }
            
            if (currentData.length > 0) {
                currentData.forEach(entity => viewer.entities.remove(entity));
                currentData = [];
            }
            
            console.log('Data cleared');
        });

        runBenchmarkBtn.addEventListener('click', () => {
            if (!heatbox || currentData.length === 0) {
                alert('Please generate data first');
                return;
            }

            console.log('Running benchmark...');
            const results = [];
            const iterations = 5;

            for (let i = 0; i < iterations; i++) {
                const startTime = performance.now();
                heatbox.setData(currentData);
                const endTime = performance.now();
                
                results.push(endTime - startTime);
            }

            const avg = results.reduce((a, b) => a + b, 0) / results.length;
            const min = Math.min(...results);
            const max = Math.max(...results);

            const stats = heatbox.getStatistics();
            console.log('Benchmark Results:');
            console.log(`  Average: ${avg.toFixed(2)}ms`);
            console.log(`  Min: ${min.toFixed(2)}ms`);
            console.log(`  Max: ${max.toFixed(2)}ms`);
            console.log(`  Rendered Voxels: ${stats.renderedVoxels}`);
            console.log(`  Total Voxels: ${stats.totalVoxels}`);

            alert(`Benchmark Complete!\nAverage: ${avg.toFixed(2)}ms\nRendered: ${stats.renderedVoxels} voxels`);
        });

        // Initialize on load
        window.addEventListener('load', () => {
            initializeHeatbox();
            
            // Generate initial data
            setTimeout(() => {
                generateDataBtn.click();
            }, 1000);
        });

        // Handle errors
        window.addEventListener('error', (event) => {
            console.error('Demo error:', event.error);
        });
    </script>
</body>
</html>
