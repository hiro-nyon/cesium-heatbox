<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>CesiumJS Heatbox - Performance Overlay Demo</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <link href="../../common/demo.css" rel="stylesheet">
    <script>
        window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/';
        if (typeof Cesium !== 'undefined' && Cesium.Ion) {
            Cesium.Ion.defaultAccessToken = null; // Disable Ion by default to avoid black screens
        }
    </script>
    <script src="../../common/camera.js"></script>
    <script src="https://unpkg.com/cesium-heatbox@latest/dist/cesium-heatbox.umd.min.js"></script>
    <style>
        .hb-range-value {
            display: inline-block;
            min-width: 48px;
            text-align: right;
            font-size: 12px;
            color: #fbbf24;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    
    <aside class="hb-panel" id="controlsPanel">
        <h2>üöÄ Performance Overlay Demo</h2>
        <p>Toggle the performance overlay, run benchmarks, and explore profiles around Shinjuku.</p>

        <div class="hb-group">
            <label for="profileSelect">Profile</label>
            <select id="profileSelect">
                <option value="none">No Profile</option>
                <option value="mobile-fast">Mobile Fast</option>
                <option value="desktop-balanced" selected>Desktop Balanced</option>
                <option value="dense-data">Dense Data</option>
                <option value="sparse-data">Sparse Data</option>
            </select>
        </div>

        <div class="hb-group">
            <label for="voxelCountSlider">Voxel Count <span class="hb-range-value" id="voxelCountLabel">1000</span></label>
            <input type="range" id="voxelCountSlider" min="100" max="5000" value="1000" step="100">
        </div>

        <div class="hb-buttons">
            <button class="hb-btn hb-btn-primary" id="generateData">Generate Data</button>
            <button class="hb-btn hb-btn-secondary" id="toggleOverlay">Show Overlay</button>
        </div>

        <div class="hb-buttons">
            <button class="hb-btn hb-btn-secondary" id="clearData">Clear</button>
            <button class="hb-btn hb-btn-primary" id="runBenchmark">Benchmark</button>
        </div>

        <div class="hb-info-box">
            <div><strong>Instructions</strong></div>
            <div>‚Ä¢ Choose a profile to tune defaults</div>
            <div>‚Ä¢ Adjust voxel budget for stress-testing</div>
            <div>‚Ä¢ Toggle overlay for live metrics</div>
            <div>‚Ä¢ Run the benchmark to capture aggregation stats</div>
        </div>

        <div id="status" class="hb-status">Ready.</div>
    </aside>

    <script type="module">
        // Import Heatbox (assuming UMD build)
        const Heatbox = window.CesiumHeatbox || window.Heatbox;
        const CameraHelper = window.HeatboxDemoCamera || null;
        const SHINJUKU_CENTER = { lon: 139.6917, lat: 35.6895 }; // Êñ∞ÂÆøÈßÖ‰∏≠ÂøÉ / Shinjuku station center
        const INITIAL_BOUNDS = {
            minLon: SHINJUKU_CENTER.lon - 0.01,
            maxLon: SHINJUKU_CENTER.lon + 0.01,
            minLat: SHINJUKU_CENTER.lat - 0.01,
            maxLat: SHINJUKU_CENTER.lat + 0.01,
            minAlt: 0,
            maxAlt: 240
        };

        function createImageryProvider() {
            return new Cesium.UrlTemplateImageryProvider({
                url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
                subdomains: 'abcd',
                maximumLevel: 19,
                credit: '¬© OpenStreetMap contributors ¬© CARTO'
            });
        }

        function createTerrainProvider() {
            try {
                if (Cesium.Ion && Cesium.Ion.defaultAccessToken && Cesium.Ion.defaultAccessToken !== 'null') {
                    return Cesium.createWorldTerrain();
                }
            } catch (error) {
                console.warn('World Terrain unavailable, falling back to EllipsoidTerrainProvider:', error);
            }
            return new Cesium.EllipsoidTerrainProvider();
        }

        // Initialize Cesium viewer
        const imageryProvider = createImageryProvider();
        const viewer = new Cesium.Viewer('cesiumContainer', {
            imageryProvider,
            terrainProvider: createTerrainProvider(),
            baseLayerPicker: false,
            timeline: false,
            animation: false,
            geocoder: false,
            navigationHelpButton: false
        });

        viewer.imageryLayers.removeAll();
        viewer.imageryLayers.addImageryProvider(imageryProvider);
        viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#0f172a');
if (CameraHelper?.focus) {
    CameraHelper.focus(viewer, { bounds: INITIAL_BOUNDS, useDefaultBounds: false });
} else {
    viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(SHINJUKU_CENTER.lon, SHINJUKU_CENTER.lat, 12000),
        orientation: {
            heading: 0,
            pitch: -Cesium.Math.PI_OVER_FOUR,
            roll: 0
        }
    });
}

        // Global state
        let heatbox = null;
        let currentData = [];
        
        // DOM elements
        const profileSelect = document.getElementById('profileSelect');
        const voxelCountSlider = document.getElementById('voxelCountSlider');
        const voxelCountLabel = document.getElementById('voxelCountLabel');
        const generateDataBtn = document.getElementById('generateData');
        const toggleOverlayBtn = document.getElementById('toggleOverlay');
        const clearDataBtn = document.getElementById('clearData');
        const runBenchmarkBtn = document.getElementById('runBenchmark');

        // Update voxel count label
        voxelCountSlider.addEventListener('input', () => {
            voxelCountLabel.textContent = voxelCountSlider.value;
        });

        // Initialize Heatbox with performance overlay enabled
        function initializeHeatbox() {
            const profile = profileSelect.value === 'none' ? undefined : profileSelect.value;
            
            const options = {
                profile,
                performanceOverlay: {
                    enabled: true,
                    position: 'top-right',
                    autoShow: false
                },
                debug: true
            };

            if (heatbox) {
                heatbox.clear();
            }

            try {
                heatbox = new Heatbox(viewer, options);
                console.log('Heatbox initialized with profile:', profile);
                console.log('Available profiles:', Heatbox.listProfiles());
            } catch (error) {
                console.error('Failed to initialize Heatbox:', error);
                alert('Failed to initialize Heatbox. Check console for details.');
            }
        }

        // Generate test data
        function generateTestData(count) {
            const entities = [];
            const bounds = { ...INITIAL_BOUNDS };

            // Êñ∞ÂÆøÈßÖÂë®Ëæ∫„Åß‰π±Êï∞„Éá„Éº„Çø„ÇíÁîüÊàê / Generate random data around Shinjuku station
            for (let i = 0; i < count; i++) {
                const lon = bounds.minLon + Math.random() * (bounds.maxLon - bounds.minLon);
                const lat = bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat);
                const alt = bounds.minAlt + Math.random() * (bounds.maxAlt - bounds.minAlt);
                
                // Create clustering for more realistic data
                if (Math.random() < 0.3) {
                    // Create cluster center
                    const centerLon = bounds.minLon + Math.random() * (bounds.maxLon - bounds.minLon);
                    const centerLat = bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat);
                    
                    // Add points around cluster
                    for (let j = 0; j < 5 && entities.length < count; j++) {
                        const clusterLon = Cesium.Math.clamp(centerLon + (Math.random() - 0.5) * 0.006, bounds.minLon, bounds.maxLon);
                        const clusterLat = Cesium.Math.clamp(centerLat + (Math.random() - 0.5) * 0.006, bounds.minLat, bounds.maxLat);
                        
                        entities.push(viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(clusterLon, clusterLat, alt),
                            point: {
                                pixelSize: 1,
                                show: false
                            },
                            properties: {
                                value: Math.random() * 100 + 50 // Higher values for clusters
                            }
                        }));
                    }
                } else {
                    entities.push(viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(lon, lat, alt),
                        point: {
                            pixelSize: 1,
                            show: false
                        },
                        properties: {
                            value: Math.random() * 100
                        }
                    }));
                }
            }

            return entities.slice(0, count);
        }

        // Event handlers
        profileSelect.addEventListener('change', () => {
            initializeHeatbox();
        });

        generateDataBtn.addEventListener('click', () => {
            const count = parseInt(voxelCountSlider.value);
            console.log(`Generating ${count} data points...`);
            
            // Clear existing data
            if (currentData.length > 0) {
                currentData.forEach(entity => viewer.entities.remove(entity));
            }
            
            // Generate new data
            currentData = generateTestData(count);
            
            if (heatbox) {
                const startTime = performance.now();
                heatbox.setData(currentData);
                const endTime = performance.now();
                
                console.log(`Data processed in ${(endTime - startTime).toFixed(2)}ms`);
                
                // Fit view to data
                if (heatbox.fitView) {
                    setTimeout(() => {
                        heatbox.fitView({
                            paddingPercent: 0.1,
                            pitchDegrees: -45,
                            headingDegrees: 0
                        });
                    }, 100);
                }
            }
        });

        toggleOverlayBtn.addEventListener('click', () => {
            if (heatbox) {
                const isVisible = heatbox.togglePerformanceOverlay();
                toggleOverlayBtn.textContent = isVisible ? 'Hide Overlay' : 'Show Overlay';
            }
        });

        clearDataBtn.addEventListener('click', () => {
            if (heatbox) {
                heatbox.clear();
            }
            
            if (currentData.length > 0) {
                currentData.forEach(entity => viewer.entities.remove(entity));
                currentData = [];
            }
            
            console.log('Data cleared');
        });

        runBenchmarkBtn.addEventListener('click', () => {
            if (!heatbox || currentData.length === 0) {
                alert('Please generate data first');
                return;
            }

            console.log('Running benchmark...');
            const results = [];
            const iterations = 5;

            for (let i = 0; i < iterations; i++) {
                const startTime = performance.now();
                heatbox.setData(currentData);
                const endTime = performance.now();
                
                results.push(endTime - startTime);
            }

            const avg = results.reduce((a, b) => a + b, 0) / results.length;
            const min = Math.min(...results);
            const max = Math.max(...results);

            const stats = heatbox.getStatistics();
            console.log('Benchmark Results:');
            console.log(`  Average: ${avg.toFixed(2)}ms`);
            console.log(`  Min: ${min.toFixed(2)}ms`);
            console.log(`  Max: ${max.toFixed(2)}ms`);
            console.log(`  Rendered Voxels: ${stats.renderedVoxels}`);
            console.log(`  Total Voxels: ${stats.totalVoxels}`);

            alert(`Benchmark Complete!\nAverage: ${avg.toFixed(2)}ms\nRendered: ${stats.renderedVoxels} voxels`);
        });

        // Initialize on load
        window.addEventListener('load', () => {
            initializeHeatbox();
            
            // Generate initial data
            setTimeout(() => {
                generateDataBtn.click();
            }, 1000);
        });

        // Handle errors
        window.addEventListener('error', (event) => {
            console.error('Demo error:', event.error);
        });
    </script>
</body>
</html>
